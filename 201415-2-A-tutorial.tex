\Tutorial	{
\hyphenpenalty=400
Діяти за принципом \textsl{<<Викреслювати мінімальну цифру>>}\nolinebreak[3] --- \emph{неправильно} (всупереч підступним пр\'{и}\-кла\-дам з~умови, які провокують таку хибну думку.) Наприклад, із\nolinebreak[2] числ\'{а}\nolinebreak[3] 9891 треба викреслити~8 і отримати~991, а\nolinebreak[3] викреслення мінімальної цифри~1 дасть не~максимальне~989.

}

Оскільки розміри малі (кількість цифр~$\<5$, видаляється одна), найпростіший правильний розв’язок\nolinebreak[3] --- перебрати всі варіанти викреслення однієї цифри (усе число без\nolinebreak[3] \mbox{1-ої}, усе без\nolinebreak[3] \mbox{2-ої}, тощо), і~вибрати з~них максимальний. Зручно (хоча й не~обов'язково) перевести число у\nolinebreak[3] рядок (\verb"string"), і~займатися вилученням символів у\nolinebreak[3] рядковому поданні. Реалізацію див. \verb"ideone.com/jFBIM6"\hspace{0.5em plus 1em}
При бажанні, її можна спростити, роблячи взагалі все виключно рядками. (Взагалі буває проблема <<у~числах ${7{<}10}$, а\nolinebreak[3] у\nolinebreak[3] рядках \verb|"7"|$\dib{{>}}$\verb|"10"|>>, але \emph{тут} вона не~проявиться, бо кількості цифр усіх потрібних чисел однакові.)

Ще є правильний розв’язок \textsl{<<Знайти найлівіше місце, де зразу після меншої цифри йде більша, і викреслити меншу с\'{а}ме з\nolinebreak[2] цих двох; якщо жодного такого місця нема (наприклад, у\nolinebreak[3] числі\nolinebreak[2] 97752) --- викреслити останню цифру>>}.

Якщо мати лише мету розв'язати дану задачу при даних обмеженнях\nolinebreak[3] --- краще обмежитися першим правильним способом і не\nolinebreak[3] читати далі. А\nolinebreak[3] якщо мати бажання ще\nolinebreak[2] раз розглянути, як можна доводити правильність алгоритма (див.\nolinebreak[3] також стор.~\pageref{text:need-or-no-need-to-prove})\nolinebreak[3] --- тоді подальший текст важливий. 

\label{text:proof-max-num-by-strike-out-one-digit}
Занумеруємо цифри початкового числ\'{а} зліва направо $\overline{a_1a_2\dots{}a_n}$.
Розглянемо спочатку випадок <<нема жодного місця, щоб після меншої цифри йшла більша>>, тобто $a_1\dib{{\>}}a_2\dib{{\>}}\dots\dib{{\>}}a_n$. Згідно алгоритму, треба викреслити~$a_n$, лишивши $\overline{a_1a_2\dots{}a_{n-1}}$. Якщо всупереч алгоритму викреслити деяку~$a_j$ ($1{\<}j{<}n$), вийде $\overline{a_1a_2\dots{}a_{j-1}a_{j+1}\dots{}a_{n}}$, тобто початок $\overline{a_1a_2\dots{}a_{j-1}}$ (при $j{=}1$ порожній, але це несуттєво) спільний, а\nolinebreak[3] далі:\linebreak[1]
$a_{j+1}$\nolinebreak[1] замість\nolinebreak[3] $a_j$;\linebreak[1] 
$a_{j+2}$\nolinebreak[1] замість\nolinebreak[3] $a_{j+1}$;
\dots;\linebreak[1]
$a_{n}$\nolinebreak[1] замість\nolinebreak[3] $a_{n-1}$.
Розглядаємо ситуацію $a_1\dib{{\>}}a_2\dib{{\>}}\dots\dib{{\>}}a_n$, тож або $a_j\dib{{>}}a_{j+1}$, або $a_j\dib{{=}}a_{j+1}$. При $a_j\dib{{>}}a_{j+1}$, число, отримане всупереч алгоритму, строго менше отриманого згідно алгоритму, бо початок $\overline{a_1a_2\dots{}a_{j-1}}$ спільний, далі $a_{j+1}\dib{{<}}a_j$. Якщо ж $a_j\dib{{=}}a_{j+1}$, то можна говорити про спільний початок $\overline{a_1a_2\dots{}a_{j-1}a_j}$ і повторити \emph{всі} міркування для <<$a_{j+2}$\nolinebreak[1] замість\nolinebreak[3] $a_{j+1}$>>. І\nolinebreak[3] так\nolinebreak[2] далі. Кінець кінцем, або десь отримаємо, що <<число всупереч алгоритму>> менше (гірше) за <<число згідно алгоритму>>, або дійдемо до $a_j\dib{{=}}a_{j+1}\dib{{=}}\dots\dib{{=}}a_n$, тобто викреслення~$a_j$ призводить до \emph{того~ж} результату, що викреслення~$a_n$.

Лишилося розглянути випадок, коли місце, де\nolinebreak[3] $a_i{<}a_{i+1}$, існує. Нехай $i^{\star}$\nolinebreak[3] --- найлівіша з таких позицій, тобто $a_1\dib{{\>}}a_2\dib{{\>}}\dots\dib{{\>}}a_{i^{\star}}$ і $(a_i^{\star}{<}a_{i^{\star}+1})$. Невигідність видаляти замість~$a_{i^{\star}}$ деяку $a_j$ при $1{\<}j{<}i^{\star}$ доводиться аналогічно міркуванням попереднього абзацу. Лишилося довести невигідність видаляти $a_j$ при $i^{\star}{<}j{\<}n$, а це зовсім легко: згідно алгоритму отримуємо $\overline{a_1a_2\dots{}a_{i^{\star}-1}a_{i^{\star}+1}\dots{}a_{n}}$, всупереч\nolinebreak[3] --- $\overline{a_1a_2\dots{}a_{i^{\star}-1}a_{i^{\star}}\dots{}a_{j-1}a_{j+1}\dots{}a_{n}}$, тобто початок $\overline{a_1a_2\dots{}a_{i^{\star}-1}}$ спільний, потім ${a_{i^{\star}+1} > a_i^{\star}}$. Розглянуті випадки покрили всі можливі ситуації, доведення успішно завершене.

\myhrulefill

Чи має другий алгоритм переваги над першим? При заданих обмеженнях ${n{\<}99999}$\nolinebreak[3] --- ні. Але \emph{якби} числа могли бути значно більшими (наприклад, до мільйона цифр; не~<<$n{=}1000000$>>, це число з 7~цифр, а якби \emph{кількість цифр} могла сягати мільйона)\nolinebreak[3] --- тоді виявилося\nolinebreak[3] б, що перший алгоритм хоча теоретично правильний, але неадекватно повільний, а др\'{у}гий вкладається у розумні обмеження. Асимптотичні оцінки: $\Theta(L^2)$ для першого, $\Theta(L)$ для др\'{у}гого, де $L$\nolinebreak[3] --- кількість цифр.

