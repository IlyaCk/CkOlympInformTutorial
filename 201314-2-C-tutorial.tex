\Tutorial	Задачу можна розв'язати шляхом ручного аналізу випадків. Але це страшнуватий спосіб, вартий уваги лише коли нема кращих ідей. За\nolinebreak[2] посиланням \verb"http://ideone.com/jjq2Pq" можна бачити трохи модифікований варіант програми, яку здав один з\nolinebreak[3] учасників. Цей модифікований варіант набирає 270\nolinebreak[3] балів з\nolinebreak[3] 300, що з\nolinebreak[3] одного боку немало, з\nolinebreak[3] іншого\nolinebreak[3] --- на\nolinebreak[3] ручний розгляд великої кількості випадків явно пішло багато часу, розв'язок все\nolinebreak[2] одно виявився не\nolinebreak[3] повним, а\nolinebreak[3] шукати помилку в\nolinebreak[3] \emph{такому} нагромадженні\nolinebreak[3] --- украй марудна й невдячна справа. У\nolinebreak[3] цьому смислі краще писати осмислений алгоритм, щоб різні вхідні дані оброблялися більш-менш однотипно.

{

\hyphenpenalty=400

Коли мова йде про\nolinebreak[3] мінімальні (за\nolinebreak[3] кількістю переходів по\nolinebreak[3] ребрам) шляхи, природним є алгоритм \emph{пошуку\nolinebreak[3] вшир} (він\nolinebreak[3] же \emph{пошук у~ширину}, рос.\nolinebreak[3] \emph{поиск в~ширину}, англ.\nolinebreak[3] \emph{breadth first search} (\emph{BFS})). Застосовувати\nolinebreak[2] BFS треба до\nolinebreak[3] неорієн\-то\-ваного графа, вершини якого\nolinebreak[3] --- ті і тільки\nolinebreak[3] ті вершини\nolinebreak[1] куба, значення яких~1 (по\nolinebreak[3] яким можна проходити), а\nolinebreak[3] р\'{е}бра\nolinebreak[3] --- ті й тільки\nolinebreak[3] ті р\'{е}бра куба, що\nolinebreak[3] поєднують дві вершини зі\nolinebreak[3] значеннями~1. Причому, раз питають не\nolinebreak[3] про\nolinebreak[1] в\'{і}д\-стань (як\nolinebreak[3] число), а\nolinebreak[3] про\nolinebreak[1] шляхи (як\nolinebreak[3] послідовності вершин), то потрібен варіант\nolinebreak[2] BFS,\linebreak[1] у\nolinebreak[3] якому запам'ятовуються батьківські вершини (вони\nolinebreak[3] ж попередники),\linebreak[1] а\nolinebreak[3] потім відбувається відновлення шляху зворотнім ходом. Деталі можна знайти в\nolinebreak[3] Інтернеті або літературі.

}

Вищесказане\nolinebreak[3] --- не\nolinebreak[3] таке просте, а\nolinebreak[3] куб має лише\nolinebreak[2] 8\nolinebreak[3] вершин (що\nolinebreak[3] дуже\nolinebreak[1] мало). Тому може бути доцільним і повний перебір (наприклад, рекурсивний) усіх можливих шляхів, що не\nolinebreak[3] містять повторень вершин. Приклад такого розв'язку\nolinebreak[3] --- \verb"ideone.com/pihZzm"\hspace{0.5em plus 1em} Детальніше про цей підхід реалізації перебору можна знайти в\nolinebreak[3] Інтернеті або літературі за ключовими словами <<\emph{пошук з\nolinebreak[3] поверненнями}>>, <<\emph{бектрекінг}>> (рос.\nolinebreak[3] <<\emph{поиск с\nolinebreak[3] возвратом}>>, англ.\nolinebreak[3] <<\emph{backtracking}>>).

На\nolinebreak[3] жаль, ідея <<писати осмислений алгоритм, щоб різні вхідні дані оброблялися однотипно>> мало придатна до такої особливості даної задачі, як задання рисунком відповідності ребер куба його вершинам (між якими є ребро і між якими нема). Цю\nolinebreak[3] відповідність важко сформулювати правилом (<<позначки вершин відрізняються або на~4, або на~1, але крім $d{\leftrightarrow}e$, а~крім названих є ще $a{\leftrightarrow}d$ і\nolinebreak[3] $e{\leftrightarrow}h$>>\nolinebreak[3] --- можна, але\nolinebreak[2] заплутано й незручно).  Мабуть, легше задати явний перелік (чи\nolinebreak[3] як у\nolinebreak[3] розв'язку з попереднього абзацу, чи вписати у текст програми константний масив --- матрицю суміжності графа, чи\nolinebreak[2] ще якось). Але це треба ретельно перевіряти на відповідність умові, бо загальні засоби контролю правильності тут безсилі.
