\Tutorial	Задачу можна розв'язати шляхом ручного аналізу випадків. Але це страшнуватий спосіб, вартий уваги лише коли нема кращих ідей. За\nolinebreak[2] посиланням \verb"ideone.com/jjq2Pq" можна бачити трохи модифікований варіант програми, яку здав один з\nolinebreak[3] учасників. Він набирає 270\nolinebreak[3] балів з\nolinebreak[3] 300, що з\nolinebreak[3] одного боку немало, але\nolinebreak[2] з\nolinebreak[2] іншого\nolinebreak[3] --- на\nolinebreak[3] ручний розгляд випадків явно пішло багато часу, бали все\nolinebreak[2] одно не\nolinebreak[3] повні, а\nolinebreak[3] шукати помилку в\nolinebreak[3] \emph{такому} нагромадженні\nolinebreak[3] --- досить марудна справа. У\nolinebreak[3] цьому смислі краще писати осмислений алгоритм, щоб обробляти різні вхідні дані більш-менш однотипно.

{

\hyphenpenalty=400

Коли мова йде про\nolinebreak[3] мінімальні (за\nolinebreak[3] кількістю переходів) шляхи, природним є алгоритм \emph{пошуку\nolinebreak[3] вшир} (він\nolinebreak[3] же \emph{пошук у~ширину}, рос.\nolinebreak[3] \emph{поиск в~ширину}, англ.\nolinebreak[3] \emph{breadth first search}, \emph{BFS}). Застосовувати\nolinebreak[2] BFS треба до\nolinebreak[3] неорієн\-то\-ваного графа, вершини якого\nolinebreak[3] --- ті вершини\nolinebreak[1] куба, значення яких~1 (по\nolinebreak[3] яким можна проходити), а\nolinebreak[3] р\'{е}бра\nolinebreak[3] --- ті р\'{е}бра куба, що\nolinebreak[3] поєднують вершини зі\nolinebreak[3] значеннями~1. Причому, раз питають не\nolinebreak[3] в\'{і}д\-стань (як\nolinebreak[3] число), а\nolinebreak[3] шлях (як\nolinebreak[3] послідовність вершин), потрібен варіант\nolinebreak[2] BFS,\linebreak[1] у\nolinebreak[3] якому запам'ятовуються батьківські вершини (вони\nolinebreak[3] ж попередники),\linebreak[1] а\nolinebreak[3] потім відбувається відновлення шляху \emph{зворотнім ходом}. Деталі можна знайти в\nolinebreak[3] Інтернеті або літературі.

}

Інший можливий спосіб\nolinebreak[3] --- повний перебір (наприклад, рекурсивний) усіх можливих шляхів, що не\nolinebreak[3] містять повторень вершин. Приклад такого розв'язку\nolinebreak[3] --- \verb"ideone.com/pihZzm"\hspace{0.5em plus 1em} Детальніше про цей підхід реалізації перебору можна знайти в\nolinebreak[3] Інтернеті або літературі за назвами \emph{пошук з\nolinebreak[3] поверненнями}, \emph{бектрекінг} (рос.\nolinebreak[3] \emph{поиск с\nolinebreak[3] возвратом}, англ.\nolinebreak[3] \emph{backtracking}). Якщо говорити про бектрекінг взагалі, то цим не\nolinebreak[3] дуже складним способом суто теоретично можна розв'язати дуже багато задач; але біда в тім, що бектрекінг зазвичай працює надто довго (наприклад, $O(N!)$) і не~вкладається в обмеження часу. А тут вкладається, бо вершин-то всього~8.

На\nolinebreak[3] жаль, ідея <<писати осмислений алгоритм, щоб обробляти різні вхідні дані однотипно>> мало придатна до заданої рисунком відповідності ребер куба його вершинам. Важко сформулювати правилом, між якими вершинами є ребро і між якими нема. (Найкраще, що вдалося --- заплутане \textsl{<<Позначки вершин відрізняються або на~4, або на~1, але крім $d{\leftrightarrow}e$, а~крім названих є ще $a{\leftrightarrow}d$ і\nolinebreak[3] $e{\leftrightarrow}h$>>}.) Мабуть, легше задати явний перелік (чи\nolinebreak[3] як у\nolinebreak[3] розв'язку з попереднього абзацу, чи вписати у текст програми константний масив --- матрицю суміжності графа, чи\nolinebreak[2] ще якось). Але це треба ретельно звіряти з умовою, бо успішна побудова шляхів у одній частині графа ніяк не\nolinebreak[3] перевіряє правильність задання ребер у іншій частині. 

\MyParagraph{Прості способи набрати частину балів}\label{text:log-cube-how-to-get-part-of-points-easily}
Тести даної задачі такі, що програма, яка, не\nolinebreak[3] вирішуючи задачу по\nolinebreak[3] суті, завжди виводить~``\texttt{NO}'', набирає 90\nolinebreak[3] балів з~300. Можливо, це й несправедливо багато. Але, з\nolinebreak[3] умови очевидно, що така програма мусила хоч щось та набрати; хто не\nolinebreak[3] міг розв'язати правильно\nolinebreak[3] --- мав\nolinebreak[3] би пошукати якісь такі варіанти.
Трохи чесніший спосіб\nolinebreak[3] --- перевіряти, чи\nolinebreak[3] є вершини кінцями одного ребр\'{а}, і\nolinebreak[3] якщо так, то виводити ці вершини, а\nolinebreak[3] якщо\nolinebreak[3] ні, то\nolinebreak[3] ``\texttt{NO}''. Він набирав 150\nolinebreak[3] балів (рівно половину).