\documentclass[14pt,a4paper]{extarticle}

% % % \usepackage{arial}
\usepackage{cmap}
\usepackage[T2A]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[english,russian,ukrainian]{babel}
\usepackage[metapost,truebbox,mplabels]{mfpic}
\usepackage{enumitem}
\usepackage{epigraph}
\usepackage{floatflt}
\usepackage{multicol}
\usepackage{longtable}
\usepackage{graphicx}
\usepackage{color}
\usepackage{textcomp}
\usepackage{amstext}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsfonts}
\usepackage{verbatim}
\usepackage{alltt}

% \twocolumn

% \usepackage[landscape,russian]{olymppp}

\usepackage[ukrainian]{olymppp}

\usepackage{anysize}
\usepackage{listcorr}

\def\dib#1{\,#1\discretionary{}{\mbox{$#1$}}{}\,}

\marginsize{20mm}{20mm}{7mm}{20mm}


% \renewcommand{\baselinestretch}{1.28125}
\renewcommand{\baselinestretch}{1.3125}

\opengraphsfile{pics}

\begin{document}

\def\<{\leqslant}
\def\>{\geqslant}
\def\*{\times}
\def\dib#1{\,#1\discretionary{}{\mbox{$#1$}}{}\,}
\def\op{\mathop{\rm op}\nolimits}
\def\bdiv{\mathop{\rm div}\nolimits}
\def\opt{\mathop{\rm opt}}
\def\isdiv{\mathbin{\hbox to 0.25em{\hfill\hbox to 0 pt{\raisebox{0pt}{\hss$\cdot$\hss}}\hbox to 0 pt{\raisebox{-.6ex}{\hss$\cdot$\hss}}\hbox to 0 pt{\raisebox{.6ex}{\hss$\cdot$\hss}}\hspace{0.15em}\hfill}\,}}

\newlength{\myparindent}


\newlength{\mytemplen}
\newlength{\mytemplensecond}
\newlength{\mytemplenthird}
\newsavebox{\mypictbox}
\def\myrightfigure#1#2{%
\savebox{\mypictbox}{\noindent{}#2}%
\settowidth{\mytemplen}{\usebox{\mypictbox}}%
\settoheight{\mytemplenthird}{\usebox{\mypictbox}}%
\ifdim\mytemplen<0.8\textwidth%
\noindent%
\setlength{\mytemplensecond}{\textwidth}%
\addtolength{\mytemplensecond}{-\mytemplen}%
\addtolength{\mytemplen}{3pt}% ??? better to find alike standard len
\hspace*{\mytemplensecond}\usebox{\mypictbox}%
\par\vspace*{-0.5\baselineskip}\par%
\vspace*{-\mytemplenthird}
\vspace{-\parskip}
\hangindent=-\mytemplen
\hangafter=-#1
\else
\begin{center}
\usebox{\mypictbox}%
\par
\end{center}
% \vspace{-\baselineskip}
\fi%
}

\def\mytextandpicture#1#2{%
\setlength{\myparindent}{\parindent}%
\savebox{\mypictbox}{\noindent{}#2}%
\settowidth{\mytemplensecond}{\usebox{\mypictbox}}%
\setlength{\mytemplen}{\textwidth}%
\addtolength{\mytemplen}{-\mytemplensecond}%
\addtolength{\mytemplen}{-3mm}%
\noindent\mbox{}\hfill\parbox{\mytemplen}{\hspace*{\myparindent}#1}\hfill\hspace{2.5mm}\hfill\parbox{\mytemplensecond}{\usebox{\mypictbox}}\hfill\mbox{}\\
}

\def\myflfigaw#1{%
\savebox{\mypictbox}{\noindent{}#1}%
\settowidth{\mytemplen}{\usebox{\mypictbox}}%
% \addtolength{\mytemplen}{1mm}%
\ifdim\mytemplen<0.75\textwidth%
\begin{floatingfigure}[r]{\mytemplen}%
\mbox{\noindent%
\usebox{\mypictbox}%
\vspace{-6pt}}
\end{floatingfigure}%
\else
\begin{figure*}[h]%
\usebox{\mypictbox}%
\end{figure*}%
\fi%
}

\def\myhrulefill{\vspace{\baselineskip}\par\vspace*{-1.75\baselineskip}\par\hrulefill\par\vspace{-0.5\baselineskip}}

\newenvironment{problemAllDefault}[1]{\vspace{10mm}\par\begin{problem}{#1}{Клавіатура (stdin)}{Екран (stdout)}{1 сек}{64 мегабайти}}{\end{problem}}

\newif{\ifallIdeOneLinksCopiedHere}
\allIdeOneLinksCopiedHerefalse


%%% \in%put pseudo-title

% % % \begin{sffamily}

\begin{center}

\begin{huge}

~

\vfill

Цю сторінку замінити на сторінку з титулкою, набраною якимись іншими засобами

\vfill

~

\clearpage

~

\vfill

Цю сторінку замінити на сторінку з <<выходными сведениями>>, набраною якимись іншими засобами

\vfill

~

\end{huge}

\end{center}

\clearpage

\renewcommand{\thecontestname}{Олімпіади з інформатики (програмування)}
\renewcommand{\thecontestlocation}{Черкаська обл.}
\renewcommand{\thecontestdate}{2013--2015 роки}

\newcommand{\stdinOrInputTxt}{Або клавіатура, або input.txt}
\newcommand{\stdoutOrOutputTxt}{Або екран, або output.txt}


\tableofcontents


\section{Передмова}

Даний збірник містить задачі олімпіад з~інформатики (програмування), що відбувалися у Черкаській області у\nolinebreak[2] \mbox{2013/14} та \mbox{2014/15} навчальних роках. Точніше, він охоплює тури обласних інтернет-олімпіад, а також др\'{у}гі (районні/\linebreak[1]міські) та треті (обласні) етапи Всеукраїнської олімпіади з~інформатики. Для кожної задачі наведені умова та вказівки щодо розв'язування.

Даний збірник не~призначений замінювати собою підручник з програмування. По-перше, ідучи від конкретних задач, нереально побудувати збалансований курс, що\nolinebreak[2] розглядає продуманий перелік\nolinebreak[2] тем. По-друге, співвідношення обсягу задач (23\nolinebreak[3] задачі з\nolinebreak[3] 6\nolinebreak[3] турів) та обсягу збірника \ifallIdeOneLinksCopiedHere\else(\pageref{LastPage}~сторінок) \fi{}робить немож\-ливим детальний розгляд усіх потрібних для розв'язання цих задач алгоритмів. Тому основна увага приділена поясненням нестандартних моментів у розв'язуванні цих задач, а\nolinebreak[3] коли задача зводиться до реалізації відомого алгоритму, іноді наведені лише його назва і порада пошукати в\nolinebreak[3] Інтернеті або літературі, іноді суть викладена, але коротко. Тому рекомендується \emph{поєднувати} даний збірник із підручниками з\nolinebreak[3] програмування, монографіями \mbox{та/або} сайтами, де розглядають ефективні алгоритми, тощо.

Тим не менш, розділ~\ref{sec:FAQ}\nolinebreak[3] (стор.~\pageref{sec:FAQ}--\nolinebreak[4]\pageref{text:FAQ-end}) містить огляд деяких питань, які дуже часто потрібні при обговоренні олімпіадних задач, але можуть бути погано відомі тим, хто займався лише іншими сторонами програмування.

Оскільки на олімпіаді з~інформатики (програмування) р\'{о}зв'язком учасника є програма, логічно, щоб даний збірник містив також і\nolinebreak[3] тексти таких програм. І\nolinebreak[3] для більшості задач вони %%%to be continued inside if-else-fi
\ifallIdeOneLinksCopiedHere
включені безпосередньо у\nolinebreak[3] текст даного збірника. Точніше кажучи, лише у дану верстку, яка поширюється лише у\nolinebreak[3] електронному вигляді. С\'{а}ме через ці включення усіх програм дана верстка у деяких місцях некрасива, та й виковирювати ці тексти програм з\nolinebreak[3] даного \texttt{.pdf} не\nolinebreak[3] дуже зручно. Тому, хоч вони й є прямо тут, все\nolinebreak[3] ж спробуйте
\else
доступні. Зокрема, як\nolinebreak[3] посилання на\nolinebreak[3] 
\fi
сайт \verb"ideone.com", де їх можна бачити з\nolinebreak[3] підсвіткою синтаксиса, скачувати (у\nolinebreak[3] вигляді, придатному для редагування і компілювання), а\nolinebreak[3] при бажанні\nolinebreak[3] --- створювати власну копію (ця\nolinebreak[3] дія називається <<fork>>) і\nolinebreak[3] працювати з\nolinebreak[3] нею безпосередньо на\nolinebreak[3] сайті (буває зручно, якщо треба швиденько щось спробувати на чужому комп'ютері, де\nolinebreak[3] нема середовища програмування). 
Крім того, 
\colorbox{yellow}{(десь на сайті cit.ckipo.edu.ua --- змінити, узгодивши з ІВФ)} % TODO 
\colorbox{yellow}{розміщено} і\nolinebreak[3] дану версію збірника, і\nolinebreak[3] версію%
\ifallIdeOneLinksCopiedHere%
\ (яка власне й була надрукована офіційно), що \emph{не}\nolinebreak[3] містить текстів програм (лише посилання на \verb"ideone.com"), і\nolinebreak[3] має краще вивірену верстку.
\else%
, де всі тексти програм вверстані у сам збірник (але через це збільшується об'єм і\nolinebreak[3] погіршується якість верстки).
\fi

Насамкінець, про авторство даного збірника. Близько третини його тексту складають умови задач, які формувалися авторським колективом. Особисто свій внесок в умови задач упорядник збірника Порубльов~І.~М. оцінює приблизно у одну третину, а\nolinebreak[3] решта зроблено такими людьми: Богатирьов~О.~О.\nolinebreak[3] (ЧНУ), Фурник~І.~В.\nolinebreak[3] (ЧОІПОПП), Шемшур~В.~М.\nolinebreak[3] (ЧОІПОПП), Безпальчук~В.~М.\nolinebreak[3] (ЧНУ), Черненко~Р.~В. (програміст, випускник ЧНУ 2011~р.), Поліщук~Д.~І. (фізик та програміст, випускник \mbox{ФіМЛі} 2004~р.). 
Але всі ці інші автори задач зробили лише малу частину розборів (пояснень), переважна більшість ($\approx$70--80\%) тексту яких написана особисто Порубльовим~І.~М., а~крім того є значний внесок Полосухіна~В.~А. (випускник\nolinebreak[2] \mbox{ФіМЛі} 2014~р., брав участь лише у\nolinebreak[3] написанні розборів \emph{після} відповідних турів).


\section{Огляд особливостей <<олімпіадного>> та <<алгоритмічного>> програмування}
\label{sec:FAQ}

\MyParagraph{Який формат задач?}
На олімпіаді з~інформатики (не~інформаційних технологій, а~інформатики; пишуть також <<інформатики (програмування)>>) учасник отримує текстові задачі, розв'язком кожної з яких повинна бути програма мовою програмування, що читає вхідні дані (з\nolinebreak[3] клавіатури чи текстового файлу), обробляє їх згідно умови задачі та виводить результат (на\nolinebreak[3] екран чи у\nolinebreak[3] текстовий файл). В\nolinebreak[3] принципі існують деякі інші формати, але реально вони рідко трапляються. <<Міркування на\nolinebreak[3] тему>>, виражені словесно, не\nolinebreak[3] приймаються і не\nolinebreak[3] перевіряються ще з\nolinebreak[3] кінця \mbox{1990-х}~рр.

\MyParagraph{Звідки беруться оцінки, проміжні між 0 і максимумом за задачу?}
Як\nolinebreak[3] правило, кожна задача перевіряється за\nolinebreak[3] допомогою \emph{тестів}. Це\nolinebreak[2] розроблена (автором або журі) сукупність прикладів, кожен з\nolinebreak[1] яких\nolinebreak[3] --- вхідні дані й відповідна їм правильна відповідь. Кожен розв'язок кожного учасника запускається на усіх цих прикладах, і за ті з них, де програма вивела правильний результат, уклавшись у обмеження часу та пам'яті, нараховуються бали. 

Бувають програми, які дають іноді правильні відповіді, іноді неправильні. Бувають правильні, але неефективні програми, які частину тестів проходять (отримуючи бали), а\nolinebreak[2] на\nolinebreak[2] решті отримують замість балів вердикт <<Перевищено час роботи>>. І~так далі. Звідси й різні бали. 

У~цього способу оцінювання є недоліки. Наприклад, описані на\nolinebreak[2] стор.~\pageref{text:log-cube-how-to-get-part-of-points-easily} засоби набрати частину балів за задачу <<Логічний куб>> можна сприймати як нечесні. Але коли учасники розуміють систему оцінювання, а\nolinebreak[3] розробник тестів дбає, щоб відсоток балів за надто прості неповні розв'язки був не\nolinebreak[3] таким великим\nolinebreak[3] --- ці\nolinebreak[3] недоліки нівелюються. Крім того, поки\nolinebreak[3] що нема кращого способу проводити \emph{автоматичну} перевірку. Яка все-таки і\nolinebreak[3] швидка, і\nolinebreak[3] вільна від недоліків, подібних до <<член журі неправильно прочитав почерк учасника>>.

У\nolinebreak[3] деяких задачах можливі різні правильні відповіді. Скажімо, у\nolinebreak[3] тому~ж <<Логічному кубі>> слід виводити мінімальний шлях, і\nolinebreak[3] різні шляхи (послідовності вершин) можуть мати однакову мінімальну довжину. На\nolinebreak[3] якісно підготовленій олімпіаді для таких задач пишуть т.~зв.\nolinebreak[1] \emph{чекери} (\emph{checkers}), які перевіряють відповідь програми учасника по\nolinebreak[3] смислу. Чекери пишуть автори задач або члени журі, а\nolinebreak[3] не\nolinebreak[3] учасники, тож кому цікаво\nolinebreak[3] --- шукайте деталі самостійно (зокрема, на\nolinebreak[1] \verb"codeforces.com"), кому ні\nolinebreak[3] --- можна обмежитися правилом, що у\nolinebreak[3] таких ситуаціях треба виводити будь-яку одну правильну відповідь.

\MyParagraph{Чи можна здавати багато розв'язків однієї задачі?} Наразі на Всеукраїнській олімпіаді з~інформатики учасники можуть багатократно здавати свої розв'язки у перевіряючу систему, взнавати результати (тривалість перевірки\nolinebreak[3] --- від кількох секунд до кількох хвилин), і\nolinebreak[2] з\nolinebreak[3] усіх спроб автоматично вибирається найкращий результат. Обмеження на\nolinebreak[3] кількість спроб здачі існують, але лояльні (як-то <<до~60 на\nolinebreak[3] учасника сумарно по всім задачам>>). 

Інша справа, що правила не\nolinebreak[3] завжди були такими (на\nolinebreak[2] IV\nolinebreak[3] (фінальному) етапі вони такі з\nolinebreak[3] 2012~р., на\nolinebreak[2] III\nolinebreak[3] (обласному)\nolinebreak[3] --- з\nolinebreak[3] 2013~р.), й невідомо, як\nolinebreak[3] довго вони будуть такими. Існує точка зору, що <<такі правила спонукають клацати замість думати>>, тож на деяких інших змаганнях з~інформатики (програмування) залишили <<старий, але правильніший>> формат, коли перевірка на\nolinebreak[2] \emph{повному} наборі тестів відбувається \emph{після} туру, а\nolinebreak[3] під час туру учасник взна\'{є} лише, чи\nolinebreak[3] проходить його програма всього кілька тестів. Є\nolinebreak[3] й\nolinebreak[3] системи оцінювання, коли зайві спроби здачі можливі, але якось <<штрафуються>>. Краще уточнювати такі моменти перед туром.

\MyParagraph{Які допустимі мови програмування?}
Згідно Правил Всеукраїнської олімпіади з~інформатики --- C++, C, Pascal. Сервер Черкаського\nolinebreak[2] ОІПОПП \verb"ejudge.ckipo.edu.ua" їх підтримує (С++\nolinebreak[2] --- як\nolinebreak[3] \verb"g++", C\nolinebreak[3] ---\nolinebreak[2] \verb"gcc", Pascal\nolinebreak[3] --- \texttt{Free\nolinebreak[1] Pascal}). Фактично на \verb"ejudge.ckipo.edu.ua" наявні також Python, Java, Perl, mono~C\#, Free\nolinebreak[1] Basic, і\nolinebreak[3] на більшості олімпіад, що\nolinebreak[3] відбуваються на\nolinebreak[3] даному сервері, якщо учасник хоче\nolinebreak[3] --- може здавати на\nolinebreak[3] них, отримані бали враховуються, але адміністрація серверу та журі туру \emph{не}~несуть відповідальності та \emph{не}~приймають претензій, якщо виявиться, що деякі задачі деякими з не~рекомендованих мов не~можуть бути розв'язані на повні бали, бо, наприклад, навіть найкращий алгоритм не\nolinebreak[3] на\nolinebreak[3] всіх тестах вкладається у\nolinebreak[3] обмеження часу чи пам'яті. (Для C++, C, Pascal така відповідальність~є.)

Коли у тексті даного збірника згадується, що якусь частину задачі на Паскалі треба писати самому, а\nolinebreak[3] на\nolinebreak[3] C++ можна використати готову бібліотечну функцію\nolinebreak[3] --- часто (але\nolinebreak[3] не\nolinebreak[3] завжди) подібна функція є також і в мовах Python та Java. Так\nolinebreak[3] що знання цих мов (якщо, звісно, вони доступні на конкретному потрібному турі) все~ж може розширити можливості учасника.

\MyParagraph{Чому нема Delphi?}\label{text:notes-about-delphi-mode} Зі <<справжнім>> Delphi є і\nolinebreak[3] проблема ліцензійної чистоти, і\nolinebreak[3] складнощі взаємодії  перевіряючої системи ejudge, що\nolinebreak[1] працює під OS\nolinebreak[3] Linux, з Windows-програмами.
Як\nolinebreak[3] компроміс, у\nolinebreak[3] переліку мов \verb"ejudge."\linebreak[0]\verb"ckipo."\linebreak[1]\verb"edu.ua" є варіант <<Free\nolinebreak[1] Pascal\nolinebreak[3] --- Delphi\nolinebreak[1] mode>>. Він підключає деякі (не~всі) <<дельфійські>> особливості (\verb"integer" 32-бітовий; \verb"string" дозволяє рядки, довші~255; функції містять спеціальну змінну\nolinebreak[2] \verb"Result";~\dots). До\nolinebreak[3] речі, цей режим % часткової сумісності 
можна увімкнути і зсер\'{е}\-дини своєї програми: написати \verb"{$mode delphi}" (замість \verb"{$APPTYPE CONSOLE}") і здати під\nolinebreak[1] Free\nolinebreak[1] Pascal.


\MyParagraph{Чи потрібно доводити правильність алгоритмів?}
\label{text:need-or-no-need-to-prove}
Залежить від обставин. З~одного боку, доведення не~вимагаються та не~оцінюються. З~іншого\nolinebreak[3] --- не~вміючи доводити, важко оцінювати правильність ідей. Якщо програма видає неправильну відповідь, треба якось приймати рішення, чи\nolinebreak[3] шукати й виправляти технічну помилку, чи\nolinebreak[3] повністю відкинути дану ідею й шукати іншу. У\nolinebreak[3] цьому смислі доведення бувають  корисні, навіть якщо робити їх виключно для себе. Приклади доведень можна бачити на~стор.~\pageref{text:proof-example-parket-1},~\pageref{text:proof-example-train-to-ship},~\pageref{text:proof-max-num-by-strike-out-one-digit}.



\renewcommand{\floatpagefraction}{0.625}

\MyParagraph{Що означають записи, подібні до <<$O(N^2)$>>?} Деталі можна знайти в\nolinebreak[3] Інтернеті чи літературі за\nolinebreak[1] назвою \emph{асимптотичні позначення $O$, $o$, $\Omega$, $\omega$,~$\Theta$}; <<$O$>>\nolinebreak[2] та\nolinebreak[2] <<$o$>> нерідко читають <<o>> (одним звуком), але правильніше <<омікрон>>; <<$\Omega$>>\nolinebreak[2] та\nolinebreak[2] <<$\omega$>>\nolinebreak[3] --- <<омега>> (велика й маленька); <<$\Theta$>>\nolinebreak[3] ---\nolinebreak[2] <<тета>>. Формальні означення складнуваті, наприклад один з\nolinebreak[3] варіантів означення~$O$ такий: $f(n)$ являє собою $O(g(n))$, коли існує \mbox{деяка}\nolinebreak[3] $f_1(n)$, така, що виконуються обидва твердження <<для\nolinebreak[1] всіх~$n$, $f(n)\<f_1(n)$>> та <<$\displaystyle\lim_{n\to\infty}\frac{f_1(n)}{g(n)}=c$, де\nolinebreak[2] $c$\nolinebreak[3] --- скінч\'{е}нне число>> (можна велике, але конкретне, щоб воно \emph{не}\nolinebreak[3] зростало при ${n\to\infty}$).

Простіше (не\nolinebreak[2] зовсім точне) пояснення: нехай нас цікавить, наскільки стрімко зростає функція $2n^2\dib{{+}}17n\dib{{+}}12\sqrt{n}\dib{{+}}500$ при $n{\to}\infty$. При дуже великих~$n$, доданок $2n^2$ значно перевищує всі інші разом узяті, тож можна приблизно оцінювати всю суму самим лише~$2n^2$. Підемо ще\nolinebreak[2] далі й скажемо, що нас не\nolinebreak[3] цікавить, 
чи\nolinebreak[3] $2n^2$,
чи\nolinebreak[3] $7n^2$,
чи\nolinebreak[3] $\frac{1}{6}n^2$\nolinebreak[3] --- головне, що коефіціент при~$n^2$ є скінч\'{е}нним строго додатним числом. Оце й показує, що як $2n^2\dib{{+}}17n\dib{{+}}12\sqrt{n}\dib{{+}}500$,\linebreak[1]
так\nolinebreak[2] і\nolinebreak[1] $7n^2$,
так\nolinebreak[2] і\nolinebreak[1] $\frac{1}{6}n^2\dib{{+}}100n\sqrt{n}\dib{{+}}12345$
являють собою $O(n^2)$ та~$\Theta(n^2)$.
Відмінність між $O$ і~$\Theta$ у\nolinebreak[3] т\'{о}му, що $O(g(n))$ дозволяє, щоб досліджувана функція була хоч <<дуже\nolinebreak[2] приблизно рівною>>~$g(n)$ (у\nolinebreak[3] щойно описаному смислі), хоч значно меншою,\linebreak[1] а\nolinebreak[1] $\Theta(g(n))$\nolinebreak[3] --- \emph{лише} <<дуже приблизно рівна>>. Наприклад, $2n\sqrt{n}\dib{{+}}17n$ можна вважати хоч\nolinebreak[2] ${O(n\sqrt{n})}$, хоч\nolinebreak[2] ${O(n^2)}$, хоч\nolinebreak[2] ${\Theta(n\sqrt{n})}$, але\nolinebreak[2] не\nolinebreak[2] ${\Theta(n^2)}$.

\begin{figure}[!b]
\begin{center}
\begin{minipage}{0.99\textwidth}
\vspace*{-0.5\baselineskip}
\hrulefill
\vspace*{-0.75\baselineskip}

\renewcommand{\baselinestretch}{1}
\begin{small}
\begin{alltt}
  for i:=2 to N do begin
    curr := A[i];
    j := i-1;
    while (j>0) and (A[j]>curr) do begin
      A[j+1] := A[j];                   \raisebox{0pt}[0pt][0pt]{\begin{math}\left.\vphantom{\begin{array}{c}a\\a\\a\\a\\a\end{array}}\right\}\end{math}} {\begin{math}O\end{math}(i), а також \begin{math}O\end{math}(n)}
      dec(j);         \raisebox{0.5\baselineskip}[0pt][0pt]{\begin{math}\left.\vphantom{\begin{array}{c}a\\a\end{array}}\right\}\end{math}} \raisebox{0.5\baselineskip}[0pt][0pt]{\begin{math}\Theta\end{math}(1)}
    end;
    A[j+1] := curr;
  end;
\end{alltt}
\vspace*{-\baselineskip}
\end{small}

\begin{small}
Сумарно буде $\Theta(n)$ разів по $O(n)$, тобто $O(n^2)$.
До\nolinebreak[3] речі, це $O(n^2)$ неможливо перетворити у $\Theta$ від чого б не було: при деяких вхідних даних (наприклад, уж\'{е} відсортованих) маємо $\Theta(n)$ разів по $\Theta(1)$, тобто $\Theta(n)$; при деяких інших --- $\Theta(n)$ разів по $\Theta(i)$, які, враховуючи $1\dib{{+}}2\dib{{+}}\dots\dib{{+}}n\dib{{=}}\frac{n(n+1)}{2}$, кінець кінцем перетворюються у~$\Theta(n^2)$.

\end{small}
\end{minipage}
\end{center}
\caption{Приклад проведення асимптотичного аналізу фрагменту програми}
\label{fig:example-of-asympthotic analysis}
\end{figure}

Навіщо все це програмісту? Бо саме так зручно оцінювати залежність часу роб\'{о}ти програми від розміру вхідних даних. Кількість тактів CPU, потрібних для обчислення деякого виразу, залежить від моделі CPU та від того, чи\nolinebreak[3] поміщаються дані у\nolinebreak[3] кеші, й\nolinebreak[3] усе це аналізувати дуже складно. Але\nolinebreak[3] можна ігнорувати ці складнощі, заявляючи, що будь-який фрагмент програми, який не\nolinebreak[3] містить циклів чи\nolinebreak[3] викликів підпрограм, працює\nolinebreak[1] за~$\Theta(1)$.
Приклад такого аналізу (для алгоритму сортування вставками) наведено на\nolinebreak[3] рис.~\ref{fig:example-of-asympthotic analysis}.

Як потім використати отримані асимптотичні оцінки? Порівнювати ефективність алгоритмів (для чого не\nolinebreak[3] завжди треба реалізовувати\nolinebreak[3] їх, часто досить уявити структуру циклів). А\nolinebreak[3] також оцінювати шанси алгоритму поміститись у такі-то обмеження часу при обробці вхідних даних таких-то розмірів.

Тактова частота сучасних комп'ютерів\nolinebreak[3] --- кілька гігагерц (мільярдів тактів за секунду). Враховуючи неточності у\nolinebreak[3] питанні <<скільки тактів займають які дії>> та ігнорування констант у сам\'{и}х означеннях $O$ чи~$\Theta$, ці <<кілька мільярдів>> треба ще поділити (причому не~ясно, на\nolinebreak[3] скільки), й\nolinebreak[1] у\nolinebreak[3] висновку виходить щось дуже приблизне <<за\nolinebreak[3] секунду встигається десь $10^7$--$10^9$ дій>>. Але навіть настільки приблизні оцінки можуть бути корисні. 
\label{text:first-example-how-to-see-algo-will-not-fit-in-time-limit}
Наприклад: $N{=}10^8$, складність алгоритму\nolinebreak[3] $\Theta(N^2)$. $(10^8)^2\dib{{=}}10^{16}$, час роботи від\nolinebreak[2] $10^{16}/10^9\dib{{=}}10^7$~сек\nolinebreak[2] ($\approx$4~місяці)\linebreak[1] до\nolinebreak[1] $10^{16}/10^7\dib{{=}}10^9$~сек\nolinebreak[2] ($\approx$30~років)\nolinebreak[3] --- безнадійно далеко від того, щоб укластись у пару секунд. Або:\nolinebreak[3] при\nolinebreak[2] $N{=}10^5$ алгоритм складністю\nolinebreak[3] $O(N\sqrt{N})$ $({10^5{\cdot}\sqrt{10^5}}\dib{{\approx}}{3{,}2{\cdot}10^7})$ має шанси вкластися у\nolinebreak[3] секунду, але впритирку, можуть бути важливі всілякі оптимізації у\nolinebreak[3] дрібницях.

Звісно, можна вимірювати час і по-простому в мілісекундах. Автоматичні перевіряючі системи (включаючи ejudge) с\'{а}ме по-простому в мілісекундах і міряють. Ці\nolinebreak[3] способи не~заважають один \'{о}дному, а~доповнюють.



\MyParagraph{Що таке діапазон (цілочисельного) типу? Переповнення типу?}

\myflfigaw{\raisebox{-9pt}[0pt][0pt]{\begin{tabular}{|c|c|}\hline\raisebox{-9pt}[9pt][9pt]{\begin{mfpic}[12]{0.75}{5}{0}{2}
\tlabel[cc](1,1){0}
\tlabel[cc](2,1){2}
\tlabel[bc](3,1.1){3}
\tlabel[tc](3,0.9){4}
\tlabel[bc](4,1.1){9}
\tlabel[tc](4,0.9){0}
\gclear\rect{(0.75,1.625),(4.75,2)}
\gclear\rect{(0.75,0.375),(4.75,0)}
\arrow\lines{(4.75,0.5),(4.75,1.5)}
\pen{1mm}
\arrow[l5]\lines{(4.75,0.5),(4.75,1.5)}
\end{mfpic}}
&
\raisebox{-9pt}[9pt][9pt]{\begin{mfpic}[12]{0.75}{5}{0}{2}
\tlabel[bc](1,1.1){9}
\tlabel[tc](1,0.9){0}
\tlabel[bc](2,1.1){9}
\tlabel[tc](2,0.9){0}
\tlabel[bc](3,1.1){9}
\tlabel[tc](3,0.9){0}
\tlabel[bc](4,1.1){9}
\tlabel[tc](4,0.9){0}
\gclear\rect{(0.75,1.625),(4.75,2)}
\gclear\rect{(0.75,0.375),(4.75,0)}
\pen{1mm}
\arrow[l5]\lines{(4.75,0.5),(4.75,1.5)}
\end{mfpic}}\\\hline\end{tabular}}}

Уявіть лічильник електроенергії (чи\nolinebreak[3] води, чи\nolinebreak[2] кілометрів\nolinebreak[3] --- байдуже). Кожен десятковий розряд відобра\-жа\-ється окремим барабаном, при завершенні значень одного відбувається збільшення наступного\dots{} й\nolinebreak[3] у\nolinebreak[3] деякий момент не\nolinebreak[3] вистачає розрядів, і\nolinebreak[3] після великого числ\'{а} настає~0. Це\nolinebreak[1] і\nolinebreak[1] є \emph{переповнення} (\emph{overflow}).
У\nolinebreak[3] комп'ютері не\nolinebreak[3] барабани (і\nolinebreak[3] не\nolinebreak[3] буває зображених на\nolinebreak[3] рисунку проміжних станів), але\nolinebreak[2] теж скінч\'{е}нна кількість розрядів. Тільки розряди двійкові, а\nolinebreak[3] не\nolinebreak[3] десяткові, тому переповнення настає не\nolinebreak[3] після\nolinebreak[1] 9999 чи\nolinebreak[1] 999999, а\nolinebreak[3] після чисел вигляду $2^k{-}1$ (де\nolinebreak[3] $k$\nolinebreak[3] --- кількість бітів), тобто, у\nolinebreak[3] двійковому поданні, $\underbrace{11\dots1}_{k\textnormal{ штук}}$. Звідси, діапазон беззнакових типів\nolinebreak[3] --- від\nolinebreak[2] 0 до\nolinebreak[2] ${2^k{-}1}$ (тут і далі обидві межі включно). Знакові типи мають діапазон від $-2^{k{-}1}$ до\nolinebreak[2] ${2^{k{-}1}{-}1}$ (кому цікаво, звідки така несиметричність, див.\nolinebreak[1] \verb"uk.wikipedia."\linebreak[0]\verb"org/"\linebreak[0]\verb"wiki/"\linebreak[0]\verb"Доповняльний_код"). 

\label{text:overflow-example}
Наприклад, при спробі обчислити у\nolinebreak[3] 16\nolinebreak[3] бітах $1000_{Dec}{\*}100_{Dec}\dib{{=}}100000_{Dec}\dib{{=}}11000011010100000_{Bin}$ (<<$_{Dec}$>> означає десяткову систему, <<$_{Bin}$>>\nolinebreak[3] --- двійкову) фактично буде отримано лише 16 останніх бітів $1000011010100000_{Bin}$, котрі у\nolinebreak[3] беззнаковому типі задають число $34464_{Dec}$, а\nolinebreak[2] у\nolinebreak[2] знаковому\nolinebreak[3] --- $({-}31072_{Dec})$. 

Окремо відзначимо вирази, подібні до \texttt{c:=a*b}, де\nolinebreak[3] \texttt{a} та\nolinebreak[3] \texttt{b} мають вужчий тип, \texttt{c}\nolinebreak[3] --- ширший, і\nolinebreak[3] результат поміщається у\nolinebreak[2] ширший тип, але\nolinebreak[3] не\nolinebreak[2] у\nolinebreak[3] вужчий. Чи\nolinebreak[3] результат буде обчислений правильно у\nolinebreak[3] ширшому типі, чи\nolinebreak[2] з\nolinebreak[3] переповненням у\nolinebreak[3] вужчому\nolinebreak[3] --- залежить від багатьох обставин. Можна вивч\'{а}ти ті обставини, й такі знання бувають корисними. Можна в\nolinebreak[3] усіх сумнівних ситуаціях робити \emph{приведення типів} (\emph{type\-casting}), наприклад \texttt{c:=int64(a)*int64(b)}.

Можна знайти таблички з точними діапазонами (напр., \verb"www.freepascal."\linebreak[0]\verb"org/"\linebreak[1]\verb"docs-html/"\linebreak[0]\verb"ref/"\linebreak[0]\verb"refsu5.html"). Але до них слід ставитися обережно, бо ці діапазони можуть залежати від архітектури <<заліза>>, операційної системи та компілятора. Скажімо, у\nolinebreak[1] \verb"en.cppreference."\linebreak[0]\verb"com/"\linebreak[1]\verb"w/cpp/"\linebreak[0]\verb"language/"\linebreak[0]\verb"types" часто говориться <<at~least>>, тобто може бути й більше.

Найсумніше, коли типи з\nolinebreak[3] однаковими назвами мають різну розрядність на локальному комп'ютері, де пише учасник, і на сервері, де відбувається перевірка. Зокрема (але\nolinebreak[1] не\nolinebreak[1] тільки), така проблема виникає, коли учасник локально пише під Delphi чи PascalABC, а\nolinebreak[1] здає під Free\nolinebreak[1] Pascal, який наразі при відсут\-ності додаткових вказівок вважає \texttt{integer} 16-\nolinebreak[1]бітовим (директива \verb"{$mode delphi}" робить \texttt{integer} 32-\nolinebreak[1]бітовим; див.\nolinebreak[2] також стор.~\pageref{text:notes-about-delphi-mode}).


% % % У\nolinebreak[3] більшості випадків варто просто бр\'{а}ти тип <<дещо з~запасом
% % % >>. Якщо так чинити не\nolinebreak[3] вдається, можна взнавати розмір типу 
% % % через функцію \texttt{sizeof} (яка вертає значення у\nolinebreak[3] байтах, а
% % % \nolinebreak[3] не\nolinebreak[3] бітах, тому $2^k$ чи $2^{k{-}1}$ міняється на 
% % % $2^{8{\cdot}\texttt{sizeof}}$ чи $2^{(8{\cdot}\texttt{sizeof})-1}$ відповідно). 
% % % Тільки тут  легко взнати, що вертає \texttt{sizeof} локально (на\nolinebreak[3] 
% % % тому комп'єютері, де\nolinebreak[3] пишемо); \emph{нема} гарантій, чи так
% % % \nolinebreak[2] с\'{а}мо буде й на сервері, де відбувається перевірка. Як
% % % \nolinebreak[3] крайні (насправді рідко потрібні) засоби\nolinebreak[3] --- (а)~
% % % пробувати питати прямим тектом у\nolinebreak[3] журі; (б)~витратити кілька 
% % % спроб здачі виключно на те, щоб з'ясувати\nolinebreak[3] це. (Як? Творчо 
% % % розвиваючи такий помірно брудний прийом: коли вже є програма, яка проходить хоч 
% % % якісь тести, поміняємо її виведення на \texttt{if \mbox{sizeof(integer)<4} then 
% % % writeln(\dots<щось геть не те>\dots) else writeln(\dots<те що набирало хоч 
% % % якісь бали>\dots)}; якщо результат роботи програми змінився\nolinebreak[3] --- 
% % % значить,\nolinebreak[3] \texttt{\mbox{sizeof(integer)<4}}. Цей прийом буває 
% % % корисним і в\nolinebreak[3] інших ситуаціях, але не\nolinebreak[3] варто ним 
% % % зловживати: можна вичерпати усі спроби здачі, а\nolinebreak[3] якщо журі 
% % % вирішить, що ці спроби дестабілізують роботу перевіряючої системи, можна 
% % % отримати дискваліфікацію.)



\MyParagraph{Формат з плаваючою комою (floating point) та похибка}\label{sec:floating-point}
Є експоненційний формат виведення дробових чисел: наприклад, \texttt{1.234e2} означає ${1{,}234{\cdot}10^2}\dib{{=}}123{,}4$; частина після~<<\texttt{E}>> називається \emph{порядок}; власне цифри до~<<\texttt{E}>>\nolinebreak[3] --- \emph{мантиса}. У~пам'яті зберігається теж експоненційний формат, але двійковий. Розрядні сітки як у порядку, так і в мантиси обмежені.

Обмеженість порядку критична для дуже великих чи дуже близьких до~0 чисел. Наприклад,  \texttt{double}, реалізований згідно IEEE~754, не\nolinebreak[3] може містити значення, модуль яких більший $10^{307}$ або менший $10^{-324}$ (нуль можливий; немож\-ливі значення між\nolinebreak[3] 0\nolinebreak[1] і~$10^{-324}$).
Обмеженість же мантиси призводить до \emph{втрати точності} або \emph{похибки}\nolinebreak[3] --- наприклад, неможливості розрізнити у\nolinebreak[2] типі \texttt{double} $1{,}0000000000000001_{Dec}$ від~1 (або $1{,}0000000000000001{\cdot}10^{-9}$ від\nolinebreak[2] $10^{-9}$, або $1{,}0000000000000001{\cdot}10^{98}$ від\nolinebreak[2] $10^{98}$\nolinebreak[3] --- важливий не\nolinebreak[3] порядок, 
а\nolinebreak[3] те, що цифри, якими ч\'{и}сла відрізняються, не~поміщаються у\nolinebreak[3] мантису.
% а\nolinebreak[3] факт, що цифри не~поміщаються у\nolinebreak[3] розрядність мантиси).

В\nolinebreak[3] інших типах конкретні діапазони можуть бути іншими; але суть двох обмежень однакова в усіх типах з плаваючою комою. 

Проблема похибок загострюється тим, що у\nolinebreak[3] тексті програми та вхідних даних ч\'{и}сла пишуть у десятковій системі, а\nolinebreak[2] фактичне внутрішнє подання двійкове. 
Наприклад, програма 
\verb"ideone.com/rnGPEl"


{\color{green}\begin{small}

\renewcommand{\baselinestretch}{0.875}

(Повний вміст даного посилання \verb"ideone.com/rnGPEl" такий:
\verbatiminput{rnGPEl.pas}
--- кінець цитати посилання \verb"ideone.com/rnGPEl")

\end{small}}


 показує, що 10-\nolinebreak[2]кратне додавання \texttt{0.3} до\nolinebreak[2] (\texttt{-3}) \emph{не}~дає рівно~0. Адже $0{,}3_{Dec}$ стає нескін\-ч\'{е}н\-ним періодичним двійковим дробом $0{,}0(1001)_{Bin}$, обмеженість мантиси призводить до його заокруглення, і похибка з'являється у самій константі.\label{text:floating-point-error-in-0.3}

Дії над числами теж можуть призводити до утворення чи зростання похибки. Cильно роздувають похибку тригонометричні та інші складн\'{і} функції (але \verb"sqrt"\nolinebreak[1] якщо й збільшує, то не\nolinebreak[3] сильно; щодо цього \verb"sqrt(x)" набагато краща за \verb"power(x,0.5)"). А\nolinebreak[3] ще можуть сильно роздути похибку віднімання \verb"a-b" при\nolinebreak[2] ${a{\approx}b}$ та додавання \verb"a+b" при\nolinebreak[3] ${a{\approx}{-}b}$. Наприклад, для вагів, якими можна зважити людину, похибка $\pm$10~г дрібна; але якщо спробувати взнати масу аркуша паперу шляхом того, що хтось зважиться один раз, тримаючи цей аркуш у руках, потім ще\nolinebreak[3] раз без цього аркуша, й обчислить різницю вимірювань\nolinebreak[3] --- результат безнадійно втоне у похибці.
Приклад програми, де демонструється аналогічна втрата результату\nolinebreak[3] --- 
\verb"ideone.com/bKXT0z"


{\color{green}\begin{small}

\renewcommand{\baselinestretch}{0.875}

(Повний вміст даного посилання \verb"ideone.com/bKXT0z" такий:
\verbatiminput{bKXT0z.pas}
--- кінець цитати посилання \verb"ideone.com/bKXT0z")

\end{small}}


\hspace{0.5em plus 1em}
Тому буває важливо провести аналітичні перетворення, щоб отримати математично еквівалентну формулу з меншим впливом похибок. 

\myflfigaw{\begin{tabular}{c|l}
$a=b$	&	\texttt{abs(a-b) < EPS} \\\hline
$a<b$	&	\texttt{a + EPS < b} \\\hline
$a\<b$	&	\texttt{a < b + EPS} \\\hline
$\vdots$&	$\qquad\vdots$
\end{tabular}}
Інший поширений прийом, який намагається нівелювати похибки\nolinebreak[3] --- не\nolinebreak[2] порівнювати ч\'{и}сла з плаваючою точкою <<по-простому>>, а\nolinebreak[3] лише з <<допуском на похибку>>, як у табличці праворуч.

<<\texttt{EPS}>> означає <<якесь маленьке число>>, його треба задати самому (наприклад, \texttt{const \mbox{EPS=1e-6}}). Як\nolinebreak[3] правильно вибирати \texttt{EPS}\nolinebreak[3] --- питання складн\'{е}. Буває легше йти не від того, якої величини можуть сягати похибки, а від того, наскільки близькими можуть бути значення, які треба розрізняти, й бр\'{а}ти \texttt{EPS} у кілька разів меншим\dots{} Іноді варто переписувати умови так, щоб враховувати не\nolinebreak[3] абсолютну, а\nolinebreak[3] відносну похибки\dots

Детальніше про floating point та похибки можна прочитати у багатьох місцях, зокрема \verb"habrahabr.ru/post/112953"\label{text:floating-point-end}

\MyParagraph{Щодо cin/cout та scanf/printf мовою\nolinebreak[3] C++}\label{text:io-streams-versus-scanf-printf}
Є такий сумний факт, що введення/\nolinebreak[2]виведення засобами \texttt{istream}/\nolinebreak[2]\texttt{ostream} (зокрема, \texttt{cin}/\nolinebreak[2]\texttt{cout}) працює повільно. Настільки повільно, що, наприклад, на\nolinebreak[2] ІІ~етапі 2013/14\nolinebreak[3] н.~р. у\nolinebreak[2] найбільшому тесті задачі <<Всюдисущі ч\'{и}сла>> (стор.~\mbox{\pageref{sec:omnipresent-numbers}--\pageref{text:omnipresent-numbers-end}}) саме лише читання\nolinebreak[1] \mbox{\verb"cin"-ом} вхідних даних, взагалі без обробки по~суті, вже перевищувало обмеження часу. Вихід\nolinebreak[3] --- читати функцією \texttt{scanf}, яка з незвички може здаватися незруч\-ною, зате швидко працює. Ще один спосіб зменшення проблеми (лише часткового зменшення, тобто його не~завжди достатньо)\nolinebreak[3] --- виклик \verb"cin.sync_with_stdio(false)", який трохи пришвидшує читання \verb"cin"-ом за рахунок вимикання синхронізації, тобто після цього не\nolinebreak[3] можна читати поперемінно то засобами \verb"cin", то засобами \verb"scanf".

А\nolinebreak[3] взагалі, є дуже вже багато моментів, коли C++ виграє у Паскаля; тож окремі ситуації, коли неграмотне використання~С++ призводить до результатів гірших, ніж Паскаль, можна вважати проявом справедливості\dots

Ще гострішою проблема швидкості читання є у мові Java, але то вже за\nolinebreak[3] межами даного посібника. Шукайте самостійно.\label{text:FAQ-end}




\section{Задачі та розбори}
\vspace{-0.5\baselineskip}

\contest{Обласна інтернет-олімпіада 2013/14 навч. року}{Черкаська обл.}{08.10.2013}

\subsection{Обласна інтернет-олімпіада 2013/14 н.~р.}
\renewenvironment{problemAllDefault}[1]{\vspace{10mm}\par\begin{problem}{#1}{Клавіатура (stdin)}{Екран (stdout)}{1 сек}{64 мегабайти}}{\end{problem}}

Задачі доступні для дорішування (\verb"ejudge.ckipo.edu.ua", змагання $\No$10).

\vspace{-0.5\baselineskip minus 1cm}
\begin{problemAllDefault}{Тор}

Як відомо, \emph{тор}\nolinebreak[3] --- це поверхня бублика, яку можна отримати таким чином: узяти прямокутник розміром $n$~клітинок по~вертикалі на $m$~клітинок по~горизонталі, склеїти верхню сторону з нижньою (отримається циліндр), потім закрутити циліндр у бублик і склеїти ліву сторону з правою.

\parbox{100pt}{%
\begin{mfpic}[2]{0}{50}{0}{20}
\pen{2pt}
\polygon{(0,0),(10,20),(50,20),(40,0)}
\pen{0.5pt}
\lines{(0.5 , 1),(40.5, 1)}
\lines{(1   , 2),(41  , 2)}
\lines{(1.5 , 3),(41.5, 3)}
\lines{(2   , 4),(42  , 4)}
\lines{(2.5 , 5),(42.5, 5)}
\lines{(3   , 6),(43  , 6)}
\lines{(3.5 , 7),(43.5, 7)}
\lines{(4   , 8),(44  , 8)}
\lines{(4.5 , 9),(44.5, 9)}
\lines{(5   ,10),(45  ,10)}
\lines{(5.5 ,11),(45.5,11)}
\lines{(6   ,12),(46  ,12)}
\lines{(6.5 ,13),(46.5,13)}
\lines{(7   ,14),(47  ,14)}
\lines{(7.5 ,15),(47.5,15)}
\lines{(8   ,16),(48  ,16)}
\lines{(8.5 ,17),(48.5,17)}
\lines{(9   ,18),(49  ,18)}
\lines{(9.5 ,19),(49.5,19)}
\arrow[l5]\reverse\arrow[l5]\ellipse[-30]{(0,10),2,5}
\end{mfpic}}%
\hfill\hfill\hfill%
\begin{Huge}$\Rightarrow$\end{Huge}
\hfill\hfill\hfill%
\parbox{120pt}{%
\begin{mfpic}[1.6]{0}{70}{0}{10}
\pen{1pt}
\ellipse{(5,5),2,5}
\fillcolor{gray(0.75)}
\gfill\ellipse{(5,5),2,5}
\curve{
(65+2*cosd(-90), 5+5*sind(-90)),
(65+2*cosd(-60), 5+5*sind(-60)),
(65+2*cosd(-30), 5+5*sind(-30)),
(65+2*cosd(  0), 5+5*sind(  0)),
(65+2*cosd( 30), 5+5*sind( 30)),
(65+2*cosd( 60), 5+5*sind( 60)),
(65+2*cosd( 90), 5+5*sind( 90))}
\pen{0.5pt}
\lines{(5+2*cosd(-90), 5+5*sind(-90)),  (65+2*cosd(-90), 5+5*sind(-90))}
\lines{(5+2*cosd(-72), 5+5*sind(-72)),  (65+2*cosd(-72), 5+5*sind(-72))}
\lines{(5+2*cosd(-54), 5+5*sind(-54)),  (65+2*cosd(-54), 5+5*sind(-54))}
\lines{(5+2*cosd(-36), 5+5*sind(-36)),  (65+2*cosd(-36), 5+5*sind(-36))}
\lines{(5+2*cosd(-18), 5+5*sind(-18)),  (65+2*cosd(-18), 5+5*sind(-18))}
\lines{(5+2*cosd(  0), 5+5*sind(  0)),  (65+2*cosd(  0), 5+5*sind(  0))}
\lines{(5+2*cosd( 18), 5+5*sind( 18)),  (65+2*cosd( 18), 5+5*sind( 18))}
\lines{(5+2*cosd( 36), 5+5*sind( 36)),  (65+2*cosd( 36), 5+5*sind( 36))}
\lines{(5+2*cosd( 54), 5+5*sind( 54)),  (65+2*cosd( 54), 5+5*sind( 54))}
\lines{(5+2*cosd( 72), 5+5*sind( 72)),  (65+2*cosd( 72), 5+5*sind( 72))}
\lines{(5+2*cosd( 90), 5+5*sind( 90)),  (65+2*cosd( 90), 5+5*sind( 90))}
\begin{coords}
\reflectabout{(30,10)}{(40,20)}
\arrow[l5]\reverse\arrow[l5]\ellipse{(35,15),2,5}
\end{coords}
\end{mfpic}}%
\hfill\hfill\hfill%
\begin{Huge}$\Rightarrow$\end{Huge}
\hfill\hfill\hfill% 
\parbox{120pt}{%
\begin{mfpic}[1]{-50}{50}{-30}{30}
\yscale{0.4}
\arc[p]{(0,25*sind(288)), 60,120,(50-10*cosd(288))}
\arc[p]{(0,25*sind(306)), 28,152,(50-10*cosd(306))}
\arc[p]{(0,25*sind(324)), 20,160,(50-10*cosd(324))}
\arc[p]{(0,25*sind(342)), 12,168,(50-10*cosd(342))}
\arc[p]{(0,25*sind(  0)),  3,177,(50-10*cosd(  0))}
\arc[p]{(0,25*sind( 18)),-10,190,(50-10*cosd( 18))}
\arc[p]{(0,25*sind( 36)),-20,200,(50-10*cosd( 36))}
\arc[p]{(0,25*sind( 54)),-50,230,(50-10*cosd( 54))}
\circle{(0,25*sind( 72)),(50-10*cosd( 72))}
\circle{(0,25*sind( 90)),(50-10*cosd( 90))}
\circle{(0,25*sind(108)),(50-10*cosd(108))}
\arc[p]{(0,25*sind(126)),135,405,(50-10*cosd(126))}
\arc[p]{(0,25*sind(144)),155,385,(50-10*cosd(144))}
\arc[p]{(0,25*sind(162)),165,375,(50-10*cosd(162))}
\arc[p]{(0,25*sind(180)),172,368,(50-10*cosd(180))}
\arc[p]{(0,25*sind(198)),180,360,(50-10*cosd(198))}
\arc[p]{(0,25*sind(216)),190,350,(50-10*cosd(216))}
\arc[p]{(0,25*sind(234)),200,340,(50-10*cosd(234))}
\arc[p]{(0,25*sind(252)),225,315,(50-10*cosd(252))}
\end{mfpic}}%
\hfill~\\                                 

Назвемо дві клітинки \emph{сусідніми}, якщо вони мають спільну сторону. Нехай за\nolinebreak[2] одну секунду можна перейти з\nolinebreak[2] клітинки до\nolinebreak[2] будь-якої сусідньої з~нею. За~який мінімальний час можна потрапити з\nolinebreak[2] клітинки\nolinebreak[2] $(r_1; c_1)$ у\nolinebreak[2] клітинку\nolinebreak[2] $(r_2; c_2)$? Перше число у\nolinebreak[2] позначенні клітинки\nolinebreak[3] --- номер рядка початкового прямокутника, друге\nolinebreak[3] --- номер стовпчика.

\InputFile  Програма повинна прочитати зі\nolinebreak[3] стандартного входу (клавіатури) шість натуральних чисел, у~порядку $n$,~$m$, $r_1$,~$c_1$,\nolinebreak[2] $r_2$,~$c_2$. 
Виконуються обмеження: $2\dib{{\<}}{n, m}\dib{{\<}}{1\,000\,000\,000}$,\hspace{1em plus 2em}\linebreak[1]$1\dib{{\<}}{r_1, r_2}\dib{{\<}}n$,\hspace{1em plus 2em}\linebreak[1]$1\dib{{\<}}{c_1,c_2}\dib{{\<}}m$.

\OutputFile Програма має вивести на стандартний вихід (екран) єдине ціле число\nolinebreak[3] --- мінімальний час.

\Examples
\begin{exampleSimple}{7em}{3em}%
\exmp{10 10 5 5 1 1}{8}%
\exmp{10 10 9 9 1 1}{4}%
\end{exampleSimple}


\end{problemAllDefault}
	

{\hyphenpenalty=400

\Tutorial	Необхідно дістатися з точки $(r_1, c_1)$ у~точку $(r_2, c_2)$ по <<зацикленому>> простору. 
Скориставшися відомим принципом незалежності переміщень, можна побачити, що переміщення в горизонтальному і вертикальному напрямках не~залежать одне від одного. Розглянемо переміщення як перетин вертикальних і горизонтальних сторін клітинки. Не~залежно від траєкторії, необхідно перетнути лише певну конкретну кількість вертикальних ліній (позначимо цю кількість~$\Delta{}r$) і горизонтальних ліній (відповідно~$\Delta{}c$). (Звісно, якщо не\nolinebreak[3] розглядати відверто не\nolinebreak[3] мінімальні шляхи, де одна й та ж лінія перетинається багатократно.) Тоді відповідь на задачу є ${\Delta{}r+\Delta{}c}$, оскільки для зміни будь якої з координат на~1 необхідно затратити 1~секунду.

Є 2 способи переміститися з рядка $r_1$ у~$r_2$\nolinebreak[3] --- перетинаючи край початкового (до згинів і склеювань) прямокутника і не~перетинаючи. Вважаємо спочатку, що ${r_1{<}r_2}$. Тоді не~перетинаючи край витратимо ${(r_2{-}r_1)}$\nolinebreak[2] сек, а~перетинаючи спочатку доберемося до рядка~1 (${(r_1{-}1)}$\nolinebreak[2] сек),  потім до\nolinebreak[1] рядка~$n$ (1~сек), і\nolinebreak[2] з\nolinebreak[2] нього у\nolinebreak[3] $r_2$\nolinebreak[3] --- (${(n{-}r_2)}$\nolinebreak[2] сек). Сумарно ${(r_1{-}r_2{+}n)}$\nolinebreak[2] сек. 
Тобто, треба вибрати мінімум зі значень ${(r_2{-}r_1)}$ (не~перетинаючи край) і\nolinebreak[3] ${(r_1{-}r_2{+}n)}$ (через\nolinebreak[3] край). Але це лише для випадку ${r_1{<}r_2}$, а\nolinebreak[3] при ${r_1{>}r_2}$ аналогічними міркуваннями отримуються схожі, але інші формули ${(r_1{-}r_2)}$ і\nolinebreak[3] ${(r_2{-}r_1{+}n)}$. Щоб\nolinebreak[2] не\nolinebreak[2] задумуватися, яка з\nolinebreak[3] координат більша, можна використати формулу
$$
\Delta{}r \, = \, \min\bigl((r_1-r_2+n) \bmod n,\quad (r_2-r_1+n) \bmod n\bigr)
$$
З~$\Delta{}c$ слід вчинити аналогічно, потім додати ${\Delta{}r+\Delta{}c}$.

}


\begin{problemAllDefault}{Паркет--1}

{\tolerance=9999

Щоб зобразити за допомогою паркету Супер-Креативний Візерунок, треба\linebreak[1]
$N_1$\nolinebreak[3] дощечок розмірами\nolinebreak[2] $1{\*}1$,\linebreak[1]
$N_2$\nolinebreak[3] дощечок розмірами\nolinebreak[2] $2{\*}1$,\linebreak[1]
$N_3$\nolinebreak[3] розмірами\nolinebreak[1] $3{\*}1$,\linebreak[1]
$N_4$\nolinebreak[4] розмірами\nolinebreak[1] $4{\*}1$ та 
$N_5$\nolinebreak[3] дощечок розмірами\nolinebreak[3] $5{\*}1$. 
Купити можна лише дощечки розмірами\nolinebreak[2] $5{\*}1$. Дощечки можна різати, але не~можна склеювати. Наприклад, коли потрібні п’ять дощечок $2{\*}1$, їх не~можна зробити з двох дощечок $5{\*}1$, але можна з трьох. Для цього дві з них розріжемо на три частини $2{\*}1$, $2{\*}1$ та $1{\*}1$ кожну, а третю\nolinebreak[3] --- на дві частини $2{\*}1$ та $3{\*}1$. Отримаємо потрібні п’ять дощечок $2{\*}1$, а дві дощечки $1{\*}1$ та одна $3{\*}1$ підуть у відходи.

}

Напишіть програму, яка, прочитавши кількості дощечок $N_1$, $N_2$, $N_3$, $N_4$ та\nolinebreak[3] $N_5$, знайде, яку мінімальну кількість дощечок $5{\*}1$ необхідно купити.

\InputFile	слід прочитати зі стандартного входу (клавіатури). Це будуть п’ять чисел $N_1$, $N_2$, $N_3$, $N_4$ та $N_5$ (саме в такому порядку), розділені пропусками (пробілами).

\OutputFile	Єдине число (скільки дощечок треба купити) виведіть на стандартний вихід (екран).


\Examples
\begin{exampleSimple}{5em}{3em}%
\exmp{0 5 0 0 0}{3}%
\exmp{1 1 1 1 1}{3}%
\end{exampleSimple}

\Scoring	Усі кількості невід’ємні; 90~балів (з~250) припадатиме на\nolinebreak[3] тести, в~яких сумарна кількість $N_1\dib{{+}}N_2\dib{{+}}N_3\dib{{+}}N_4\dib{{+}}N_5$ перебуває в межах від 0 до 20, ще~80~балів\nolinebreak[3] --- від 100 до 10 000, решта 80~балів\nolinebreak[3] --- від 500 000 000 до 2 000 000 000. 

Здати потрібно одну програму, а не для кожного випадку окремо; різні обмеження вводяться виключно для того, щоб дати приблизне уявлення, скільки балів можна отримати, розв’язавши задачу не повністю.



\end{problemAllDefault}
	

\Tutorial	
Задача складн\'{а} необхідністю дуже акуратно розглядати випадки, але проста тим, що потрібні \emph{лише} розгалуження та присвоєння.
% Задача досить складн\'{а} тим, що треба дуже акуратно розглядати випадки, і разом з тим дуже проста тим, що для остаточної реалізації програми не\nolinebreak[3] потрібні ніякі засоби, крім розгалужень та присвоєнь. 

Нехай змінні \texttt{n1}, \texttt{n2}, \texttt{n3}, \texttt{n4} та \texttt{n5} містять потрібні кількості дощечок розмірами $1{\*}1$, $2{\*}1$, $3{\*}1$, $4{\*}1$ та $5{\*}1$ відповідно, у змінній \texttt{res} будемо будувати відповідь задачі. Протягом роботи алгоритму значення деяких зі змінних \texttt{n1}, \texttt{n2}, \texttt{n3}, \texttt{n4} або \texttt{n5} можуть зменшуватися\nolinebreak[3] --- по мірі того, як враховуємо відповідні кількості у змінній \texttt{res}, яка наприкінці міститиме остаточну відповідь. 






{

\def\leftColumnWidth{0.35\textwidth}
\def\rightColumnWidth{0.6\textwidth}
\def\leftCell#1{\ttfamily\obeylines\obeyspaces\frenchspacing
\begin{minipage}[t]{\leftColumnWidth}
{\ttfamily\obeylines\obeyspaces\frenchspacing #1}
\end{minipage}}
\def\rightCell#1{
\begin{minipage}[t]{\rightColumnWidth}
{#1}
\end{minipage}\medskip}

\def\tabbb{\hspace*{2em}}

\begin{longtable}{|p{\leftColumnWidth}|p{\rightColumnWidth}|}
\hline
\multicolumn{1}{|c|}{Фрагмент коду} 
&
\multicolumn{1}{|c|}{Коментар}
\\\hline\endhead

\leftCell{res = n5}
&
\rightCell{(1)~На кожну дощечку $5{\*}1$ неминуче потрібна окрема ціла дощечка.}
\\\hline

\leftCell{res += n4}
&
\rightCell{(2)~На кожну дощечку $4{\*}1$ теж потрібна окрема дощечка\dots}
\\\hline

\leftCell{n1 -= min(n1,n4)}
&
\rightCell{(3)~\dots{}і кожен обрізок можна взяти як дощечку $1{\*}1$. Тому \emph{подальша} потреба в дощечках $1{\*}1$ складає вже не\nolinebreak[3] \texttt{n1}, а\nolinebreak[1] або\nolinebreak[2] \mbox{\texttt{n1–n4}}, або~\texttt{0}.}
\\\hline

\leftCell{res += n3}
&
\rightCell{(4)~На кожну дощечку розмірами $3{\*}1$ теж неминуче потрібна окрема дощечка\dots}
\\\hline

\leftCell{if n2 > n3:\\
\tabbb{}n2 -= n3}
&
\rightCell{(5)~\dots{}причому, при $N_2{>}N_3$ використовуємо кожен обрізок як дощечку $2{\*}1$\dots}
\\\hline

\leftCell{else:\\
\tabbb{}n3 -= n2\\
\tabbb{}n2 = 0\\
\tabbb{}n1 -= min(n3*2, n1)}
&
\rightCell{(6)~\dots{}а при $N_2{\<}N_3$ формуємо з обрізків \emph{усі} дощечки $2{\*}1$, а\nolinebreak[1] з\nolinebreak[1] решти ще й \texttt{\mbox{min(n3*2,}\nolinebreak[2] \mbox{n1)}} дощечок $1{\*}1$ (доки\nolinebreak[3] не\nolinebreak[1] закінчаться дощечки\nolinebreak[2] $3{\*}1$ або потреба у\nolinebreak[3] дощечках\nolinebreak[2] $1{\*}1$).}
\\\hline

\leftCell{res += n2//2\\
n1 -= min(n1,n2//2)\\
n2 \%= 2}
&
\rightCell{(7)~Оскільки всі дощечки $3{\*}1$ \emph{вже} сформовані, тепер на кожну пару дощечок $2{\*}1$ потрібна окрема дощечка, причому обрізок можна використати як дощечку $1{\*}1$.}
\\\hline

\leftCell{if n2==1:\\
\tabbb{}res += 1\\
\tabbb{}n1 -= min(n1,3)\\
\tabbb{}n2 = 0}
&
\rightCell{(8)~Якщо на попередньому кроці кількість дощечок $2{\*}1$ була непарна, то зараз треба сформувати останню дощечку $2{\*}1$, причому з\nolinebreak[3] обрізку можна зробити до~3 дощечок $1{\*}1$.}
\\\hline

\leftCell{res += n1//5\\
\tabbb{}n1 \%= 5}
&
\rightCell{(9)~Якщо після усіх попередніх кроків усе ще є потреба в дощечках $1{\*}1$, формуємо їх, розрізаючи кожну дощечку на 5 частин.}
\\\hline


\leftCell{if n1 > 0:\\
\tabbb{}res += 1}
&
\rightCell{(10)~Якщо після попереднього кроку все ще є потреба у дощечках $1{\*}1$, то вона $\<$4~штук, для чого достатньо ще\nolinebreak[2] \emph{однієї} дощечки.}
\\\hline
\end{longtable}

}

\vspace{-\baselineskip}

(Мова коду\nolinebreak[3] --- Python~3;\hspace{0.5em plus 1em}\linebreak[1]
``\verb"="''\nolinebreak[3] (одинарне)\nolinebreak[3] --- присвоєння;\hspace{0.5em plus 1em}\linebreak[1]
``\verb"=="''\nolinebreak[3] (подвійне)\nolinebreak[3] --- перевірити, чи\nolinebreak[3] дорівнює;\hspace{0.5em plus 1em}\linebreak[1]
``\verb"%"''\nolinebreak[3] --- залишок від ділення (\texttt{mod});\hspace{0.5em plus 1em}\linebreak[1]
``\verb"//"''\nolinebreak[3] (подвійне)\nolinebreak[3] --- \emph{цілочисельне} ділення (\texttt{div});\hspace{0.5em plus 1em}\linebreak[1]
``\verb"a+=b"''\nolinebreak[3] --- те\nolinebreak[2] само, що \verb"a=a+b", тобто до~\verb"a" додати~\verb"b" і покласти результат у\nolinebreak[1] ту\nolinebreak[2] саму змінну~\verb"a"; аналогічно ``\verb"a-=b"'', ``\verb"a%=b"''.)

Аргументація дій у\nolinebreak[3] коментарях зовсім\nolinebreak[1] не\nolinebreak[3] зайва
(див.\nolinebreak[2] також стор.~\pageref{text:need-or-no-need-to-prove}). Бо\nolinebreak[3] задача є частковим випадком \emph{задачі упаковки корзин} (\emph{bin\nolinebreak[1] packing problem}), для загального вигляду якої не\nolinebreak[3] відомо правильного швидкого алгоритма (про\nolinebreak[1] простий не\nolinebreak[3] йдеться; наука не~знає навіть складн\'{о}го, щоб був правильний та швидкий одночасно). Наприклад, \emph{якби} розміри початкових дощечок були не\nolinebreak[3] $5{\*}1$, а\nolinebreak[3] $7{\*}1$, і\nolinebreak[3] треба було сформувати 2~шт.\nolinebreak[3] $3{\*}1$ і 4~шт.\nolinebreak[3] $2{\*}1$, то\nolinebreak[3] треба було~б узяти дві стандартні $7{\*}1$ і розрізати кожну на $(3{\*}1)\dib{{+}}(2{\*}1)\dib{{+}}(2{\*}1)$, діючи \emph{всупереч} ідеї <<перш за\nolinebreak[3] все вибирати якнайбільші розміри>>.

Посилити аргументацію (провести більш строге доведення цих коментарів) можна приблизно так. На\nolinebreak[2] усіх кроках\nolinebreak[2] (3),\nolinebreak[1] \mbox{(5)--(8)} справедливо <<нема смислу викидати у\nolinebreak[3] відходи те, що можна використати; навіть якщо виявиться, що його можна узяти й пізніше, ми нічого не\nolinebreak[3] втрачаємо, узявши раніше>>. 
\label{text:proof-example-parket-1}
На\nolinebreak[3] кроках\nolinebreak[3] (5), \nolinebreak[1] (6), \nolinebreak[1] (8)\nolinebreak[3] --- <<де\nolinebreak[3] можна, варто віддавати перевагу $2{\*}1$ над $1{\*}1$, бо замість кожної $2{\*}1$ завжди можна зробити хоч\nolinebreak[1] дві\nolinebreak[3] $1{\*}1$, хоч\nolinebreak[1] одну, а\nolinebreak[3] зробити $2{\*}1$ замість двох $1{\*}1$ можна далеко не~завжди>>. На\nolinebreak[3] кроках\nolinebreak[2] (9),\nolinebreak[3] (10), формується залишок тих дощечок\nolinebreak[3] $1{\*}1$, які ніяк не\nolinebreak[3] могли бути сформовані раніше, бо,\nolinebreak[2] станом на початок кроку\nolinebreak[3] (9), \verb"n1>0" \emph{лише} якщо на усіх попередніх кроках усі дощечки використовувалися геть без відходів.

А для більших розмірів стандартної дощечки десь колись настає момент, коли узагальнення таких міркувань перестають бути правильними\dots


\begin{problemAllDefault}{Сума квадратів}

Для заданого натурального числ\'{а}~$N$, визначити, скількома різними способами можна розкласти його в~суму двох точних додатних квадратів. 

Іншими словами: для заданого~$N$, з’ясувати, скільки є різних способів подати його як $N\dib{{=}}x^2\dib{{+}}y^2$, причому $x$ та\nolinebreak[3] $y$ являють собою цілі строго додатні числа, а\nolinebreak[3] розкладення, в\nolinebreak[3] яких значення $x$ та\nolinebreak[3] $y$ лише обміняні місцями, вважаються однаковими.


\InputFile	--- натуральне число\nolinebreak[3] $N$\nolinebreak[3] --- слід прочитати зі\nolinebreak[3] стандартного входу (клавіатури).

\OutputFile	--- знайдену кількість способів\nolinebreak[3] --- слід вивести на\nolinebreak[3] стандартний вихід (екран).


\Examples

\begin{exampleSimpleThree}{5em}{3em}{25.5em}{Примітка}%
\exmp{16}{0}{\begin{rmfamily}Розкласти у суму \emph{додатних} точних квадратів неможливо\end{rmfamily}}%
\exmp{10}{1}{\begin{rmfamily}Єдине розкладення $10\dib{{=}}1^2{+}3^2$\end{rmfamily}}%
\exmp{4225}{4}{\begin{rmfamily}Чотири різні розкладення: $4225\dib{{=}}16^2{+}63^2\dib{{=}}25^2{+}60^2\dib{{=}}33^2{+}562\dib{{=}}39^2{+}52^2$\end{rmfamily}}%
\end{exampleSimpleThree}

\Scoring	100~балів (з~250) припадатиме на\nolinebreak[3] тести, в\nolinebreak[3] яких $1{\<}N{\<}1234$.

Ще\nolinebreak[3] 50~балів\nolinebreak[3] --- на тести, в яких $12345{\<}N{\<}123456$.

Решта\nolinebreak[2] 100~балів\nolinebreak[3] --- на тести, в яких $12345678{\<}N{\<}123456789$.

Здати потрібно одну програму, а не окремі для трьох випадків; різні обмеження вводяться виключно для того, щоб дати приблизне уявлення, скільки балів можна отримати, розв’язавши задачу не повністю.

\end{problemAllDefault}
	

\Tutorial	Задача передбачає \emph{перебір}\nolinebreak[3] --- проби різних значень, з\nolinebreak[3] перевіркою, чи\nolinebreak[3] виконується рівність. Треба лише організувати це правильно.

Один з класичних способів уникати подвійних урахувань розкладень, у\nolinebreak[3] яких значення $x$ та\nolinebreak[3] $y$ лише обміняні місцями\nolinebreak[3] --- враховувати лише ті, де $x{\<}y$.

{

\def\tabbb{\hspace*{1em}}

\mytextandpicture{Деякі учасники здавали реалізацію, наведену праворуч. Вона неправильна: і\nolinebreak[3] працює надто довго, і\nolinebreak[3] може знаходити зайві розкладення.}{\begin{minipage}{11em}\begin{small}\renewcommand{\baselinestretch}{0.875}\begin{alltt}res:=0;\\
for x:=1 to N do\\
\tabbb{}for y:=1 to N do\\
\tabbb\tabbb{}if x<=y then\\
\tabbb\tabbb\tabbb{}if x*x+y*y=N then\\
\tabbb\tabbb\tabbb\tabbb{}res:=res+1;\end{alltt}\end{small}\end{minipage}}

\vspace{-0.25\baselineskip}

На стор.~\pageref{text:first-example-how-to-see-algo-will-not-fit-in-time-limit} роз'яснено, чому такий ($O(N^2)$) алгоритм очевидно не\nolinebreak[3] вкладеться у\nolinebreak[3] 1~сек. А\nolinebreak[3] на\nolinebreak[3] стор.~\pageref{text:overflow-example}\nolinebreak[3] --- що таке переповнення, внаслідок яких \texttt{x*x+y*y=N} може виконатися, наприклад, при $x{=}1$, $y{=}65537$, $N{=}131074$.

\vspace{0.25\baselineskip plus 1pt}

\mytextandpicture{Через помилку автора, задача вийшла простішою, ніж планувалося. Повний бал набирає в~т.~ч. й <<вилизана>> у деталях програма, де принципова оптимізація лише одна: верхні м\'{е}жі циклів змінені з\nolinebreak[3] $N$ на\nolinebreak[3] $\sqrt{N}$.}{\begin{minipage}{10em}\begin{small}\renewcommand{\baselinestretch}{0.875}\begin{alltt}res:=0;\\
sqrtN:=round(sqrt(N));\\
for x:=1 to sqrtN do\\
\tabbb{}for y:=x to sqrtN do\\
\tabbb\tabbb{}if x*x+y*y=N then\\
\tabbb\tabbb\tabbb{}res:=res+1;\end{alltt}\end{small}\end{minipage}}

}

Все ж розглянемо можливу подальшу оптимізацію, яка зменшує складність з ${O(\sqrt{N}{\*}\sqrt{N})}\dib{{=}}{O(N)}$ до $O(\sqrt{N})$. Коли $x$ вибраний, рівність $x^2\dib{{+}}y^2\dib{{=}}N$ не~може виконатися для різних натуральних~$y$. Тож вкладеного цикла по~$y$ можна позбутися, замінивши на\nolinebreak[3] перевірку, чи $\sqrt{N{-}x^2}$ ціле та~${\>}x$.

\label{text:how-to-test-if-sqrt-N-integer}
Перевірку, чи деяке $\sqrt{K}$ ціле, можна робити як \verb"frac(sqrt(K))=0". Або як \verb"sqr(round(sqrt(K)))=K". Теоретично, у \mbox{1-му} виразі можливий підвох, якщо \texttt{sqrt} поверне значення з\nolinebreak[3] похибкою і \texttt{frac} верне не~0, де насправді~0, а\nolinebreak[3] у\nolinebreak[3] др\'{у}гому\nolinebreak[3] --- якщо \texttt{round} матиме вужчий тип і виникне переповнення. Практично вони обидва працюють правильно.


\begin{problem}{Дільники}{Клавіатура (stdin)}{Екран (stdout)}{2 сек}{64 мегабайти}

Для натурального числ\'{а}~$N$, виведіть у порядку зростання всі його різні натуральні дільники.

\InputFile	слід прочитати зі стандартного входу (клавіатури). Це буде єдине натуральне число\nolinebreak[3] $N$. $1\dib{{\<}}N\dib{{\<}}1234567891011$.

\OutputFile	--- послідовність усіх різних натуральних дільників, у порядку зростання — слід вивести на стандартний вихід (екран). Виводити обов’язково в один рядок, розділяючи пробілами.


\Examples
\begin{exampleSimple}{5em}{21em}%
\exmp{9}{1 3 9}%
\exmp{120}{1 2 3 4 5 6 8 10 12 15 20 24 30 40 60 120}%
\end{exampleSimple}

\Scoring	120 балів (з~250) припадатиме на тести, в яких $1\dib{{\<}}N\dib{{\<}}4321$.

Решта 130\nolinebreak[3] балів\nolinebreak[3] --- на тести, в яких $12345678\dib{{\<}}N\dib{{\<}}1234567891011$.

Здати потрібно одну програму, а не окремі для двох випадків; різні обмеження вводяться виключно для того, щоб дати приблизне уявлення, скільки балів можна отримати, розв’язавши задачу не\nolinebreak[3] повністю.

\end{problem}
	

\Tutorial	Перш за все, слід розуміти, що основна проблема алгоритма \texttt{for \mbox{i:=1 to n} do\linebreak[2] if \mbox{n mod i = 0} then \mbox{write(i, ' ')}}\nolinebreak[3] --- він не\nolinebreak[3] має ніяких шансів устигнути за потрібний час (див.\nolinebreak[3] також стор.~\pageref{text:first-example-how-to-see-algo-will-not-fit-in-time-limit}).

\label{text:about-sqrt-n-in-divisors-list}
Є\nolinebreak[3] сенс перебирати дільники лише до\nolinebreak[2] \verb"sqrt(N)". Дільники, більші за $\sqrt{N}$, можна обчислити діленням $N$ на якийсь із дільників, менших~$\sqrt{N}$. Адже: (1)~якщо $a$\nolinebreak[3] --- дільник\nolinebreak[3] $N$, то $N/a$\nolinebreak[3] --- ціле, й також дільник~$N$; (2)~ч\'{и}сла $a$ та $N/a$ не~можуть одночасно бути більшими~$\sqrt{N}$. 

Можна один раз прокрутити цикл від 1 до\nolinebreak[3] $\sqrt{N}$, і повиводити всі знайдені дільники, а потім наступний (не\nolinebreak[3] вкладений, а\nolinebreak[3] наступний) цикл від $\sqrt{N}$ \texttt{downto}~1 і повиводити \verb"N div i". Такий алгоритм матиме складність $O(\sqrt{N})$, що очевидно поміститься у обмеження часу ($\sqrt{1234567891011}\dib{{\approx}}{1{,}1{\cdot}10^6}$). Можна трохи оптимізувати, якщо у першому циклі не\nolinebreak[3] лише виводити дільники, а\nolinebreak[3] ще й запам'ятовувати їх у масив, щоб др\'{у}гий цикл перебирав лише дільники, а\nolinebreak[3] не\nolinebreak[3] всі ч\'{и}сла проміжку. Але така оптимізація \emph{не}\nolinebreak[3] принципова.

Незалежно від способу організації др\'{у}гого циклу, варто перевірити, чи\nolinebreak[3] правильно програма розбирається з такими випадками: (а)~$\sqrt{N}$\nolinebreak[1] цілий і є\nolinebreak[2] одним (а\nolinebreak[3] не\nolinebreak[3] двома) з\nolinebreak[2] дільників, як 6 для~36;
(б)~$\sqrt{N}$\nolinebreak[1] не\nolinebreak[3] цілий, але є два дільники близько до $\sqrt{N}$, як 6 і~7 для~42;
(в)~дільників, близьких до\nolinebreak[3] $\sqrt{N}$, нема.

Приклад розв'язку\nolinebreak[3] --- 
\verb"ideone.com/wY3IY0"


{\color{green}\begin{small}

\renewcommand{\baselinestretch}{0.875}

(Повний вміст даного посилання \verb"ideone.com/wY3IY0" такий:
\verbatiminput{wY3IY0.pas}
--- кінець цитати посилання \verb"ideone.com/wY3IY0")

\end{small}}


\hspace{0.5emplus 1em}
Варто відзначити такі його моменти: \texttt{N} мусить бути 64-\nolinebreak[3]бітовим, але решту зручніше лишити 32-\nolinebreak[3]бітовими;
для масиву\nolinebreak[3] \texttt{dividers}, розмір мільйон узятий з\nolinebreak[3] величезним запасом, насправді досить\nolinebreak[3] 7000; але правильно оцінити цю кількість дуже складно, тож якщо не знати, то краще взяти з запасом (але враховуючи обмеження пам'яті).





\contest{ІІ (районний/міський) етап 2013/14 навч. року}{Черкаська обл.}{14.12.2013}
\renewenvironment{problemAllDefault}[1]{\vspace{10mm}\par\begin{problem}{#1}{Клавіатура (stdin)}{Екран (stdout)}{1 сек}{64 мегабайти}}{\end{problem}}

\subsection{ІІ (районний/міський) етап 2013/14 н.~р.}

Задачі доступні для дорішування (\verb"ejudge.ckipo.edu.ua", змагання $\No$14).

\vspace{-0.5\baselineskip minus 1cm}
\begin{problemAllDefault}{Електричка}

На кожному вагоні електрички є табличка, на якій фарбою написано його номер. Вагони занумеровані натуральними числами\nolinebreak[1] 1,\nolinebreak[2] 2,~\dots,\nolinebreak[2] $N$ (крайній вагон має номер~1, сусідній з ним\nolinebreak[3] --- номер~2, і~т.~д., до\nolinebreak[3] крайнього з протилежного боку вагону, який має номер~$N$). Електричка має кабіни з обох боків, і\nolinebreak[3] може поїхати хоч\nolinebreak[2] \mbox{1-им} вагоном уперед, хоч\nolinebreak[3] \mbox{$N$-им}.

\ifnum\pdfoutput>0
\includegraphics[width=\textwidth,keepaspectratio=true]{elTrain.png}
\else
\begin{tiny}\colorbox{yellow}{Run not latex but pdflatex to insert picture}\par\end{tiny}
\begin{small}\colorbox{yellow}{Run not latex but pdflatex to insert picture}\end{small}
\ifnum\number\month > 7 \ERROR \fbox{Run not latex but pdflatex to insert picture}\fi
\fi

Під час прибуття електрички на платформу, Вітя помітив, що ${(i{-}1)}$ штук вагонів електрички проїхали мимо нього, а\nolinebreak[2] \mbox{$i$-й} по\nolinebreak[2] порядку зупинився якраз навпроти. Ще\nolinebreak[2] він помітив, що\nolinebreak[2] на\nolinebreak[2] табличці цього вагона написаний номер~$j$. Ще\nolinebreak[2] він точно знає (і\nolinebreak[2] ці\nolinebreak[2] знання відповідають дійсності), що\nolinebreak[2] електрички ніколи не\nolinebreak[3] бувають ні\nolinebreak[3] коротшими 4~вагонів, ні\nolinebreak[3] довшими 12~вагонів. Вітя хоче визначити, скільки всього вагонів у\nolinebreak[2] електричці. Напишіть програму, яка або\nolinebreak[2] знаходитиме цю кількість, або\nolinebreak[2] повідомлятиме, що без\nolinebreak[1] додаткової інформації це\nolinebreak[1] зробити неможливо.

\InputFile
Програма має прочитати зі\nolinebreak[3] стандартного входу (клавіатури) два цілі числ\'{а} $i$ та~$j$, розділені пропуском. ${2{\<}i{\<}12}$, ${2{\<}j{\<}12}$, ч\'{и}сла гарантовано задовольняють всі вищезгадані обмеження.

\OutputFile
Виведіть на стандартний вихід (екран) одне число\nolinebreak[3] --- кількість вагонів у\nolinebreak[3] електричці. Якщо однозначно визначити кількість вагонів неможливо, виведіть замість кількості число~\texttt{0}.

\Example
\begin{exampleSimple}{3em}{3em}%
\exmp{4 2}{5}%
\end{exampleSimple}

\end{problemAllDefault}
	

\Tutorial	Розглянемо два випадки: 

\begin{itemize}[leftmargin=*,itemsep=0pt,partopsep=0pt,topsep=0pt,parsep=0pt]
\item
електричка їде \mbox{1-им} вагоном вперед: тоді 
\mbox{1-ий} по порядку слідування вагон має напис\nolinebreak[2] <<$\No\,1$>>, 
\mbox{2-ий} по порядку слідування\nolinebreak[3] --- напис\nolinebreak[2] <<$\No\,2$>>, 
і~т.~д. Тобто, ${i{=}j}$, причому незалежно від кількості вагонів електрички.
\item
електричка їде \mbox{$N$-им} вагоном вперед: тоді 
\mbox{1-ий} по порядку слідування вагон має напис\nolinebreak[2] <<$\No\,N$>>, 
\mbox{2-ий} по порядку слідування\nolinebreak[3] --- напис\nolinebreak[2] <<$\No(N{-}1)$>>, 
і~т.~д. Тобто, ${i{+}j}\dib{{=}}{N{+}1}$.
\end{itemize}

Звідси ясно, що при $i{\neq}j$ точно має місце \mbox{2-й} випадок, для якого $N\dib{{=}}{i{+}j{-}1}$. Може здатися, ніби при $i{=}j$ слід виводити\nolinebreak[3] \texttt{0} (<<без\nolinebreak[1] додаткової інформації визначити неможливо>>); але є виключення: при $i{=}j{=}12$, відповідь~12 (електрички не~бувають довшими\nolinebreak[2] 12~вагонів). А\nolinebreak[3] при\nolinebreak[1] $({i{=}j})$\nolinebreak[3] \texttt{and}\nolinebreak[2] $({j{<}12})$, таки виводити\nolinebreak[3] \texttt{0}, бо така ситуація можлива при будь-якому\nolinebreak[3] $N$ 
% від\nolinebreak[3] $j$\nolinebreak[1] до\nolinebreak[3] 12 (обидві межі включно).
у\nolinebreak[3] межах $j\dib{{\<}}N\dib{{\<}}12$.
Приклад реалізації: 
\verb"ideone.com/vIUkUt"


{\color{green}\begin{small}

\renewcommand{\baselinestretch}{0.875}

(Повний вміст даного посилання \verb"ideone.com/vIUkUt" такий:
\verbatiminput{vIUkUt.pas}
--- кінець цитати посилання \verb"ideone.com/vIUkUt")

\end{small}}


\hspace{0.5em plus 1em}
Програма містить виконання всього кількох дій, тому має складність $\Theta(1)$ і\nolinebreak[3] виконується миттєво.

Розв'язки, які виводили правильну відповідь при\nolinebreak[2] $i{\neq}j$, а\nolinebreak[3] при\nolinebreak[2]  $i{=}j$\nolinebreak[3] --- \emph{завжди}\nolinebreak[3] \texttt{0}, оцінювалися на 180\nolinebreak[3] балів з~200.




\begin{problemAllDefault}{Цифрові ріки}

Цифрова ріка\nolinebreak[3] --- це послідовність чисел, де\nolinebreak[2] число, що\nolinebreak[2] слідує за\nolinebreak[2] числом\nolinebreak[3] $n$, це $n$ плюс сума його цифр. Наприклад, якщо число ${n{=}12345}$, то за ним буде йти $12345\dib{{+}}{(1{+}2{+}3{+}4{+}5)}\dib{{=}}12360$\nolinebreak[1] і~т.~д. Якщо перше число цифрової річки $N$, ми будемо називати її <<\begin{bfseries}{річка~\begin{itshape}{N}\end{itshape}}\end{bfseries}>>.

Для прикладу, \textbf{річка\nolinebreak[3] 480}\nolinebreak[3] --- це послідовність чисел, яка починається з чисел 
480, 492, 507, 519,~\dots, а\nolinebreak[3] \textbf{річка\nolinebreak[3] 483}\nolinebreak[3] --- послідовність, що починається з 483, 498, 519,~\dots

Напишіть програму, яка приймає на вхід два цілих значення $k$ ($1\dib{{\<}}k\dib{{\<}}16384$) та  $N$ ($1\dib{{\<}}N\dib{{\<}}10000$), і\nolinebreak[3] виводить \mbox{$k$-те}\nolinebreak[1] число річки~$N$.

\Example
\begin{exampleSimple}{3em}{3em}%
\exmp{4 480}{519}%
\end{exampleSimple}

\end{problemAllDefault}
	

\Tutorial	Задача робиться <<в~лоб>>, тобто без усяких придумок $k{-}1$ раз (<<мінус один>>, бо треба отримати \mbox{$k$-те} число з\nolinebreak[3] \mbox{1-го}, а\nolinebreak[3] не\nolinebreak[3] \mbox{0-го}) застосовується дія <<порахувати й додати суму цифр поточного числа>>. 

\label{text:sum-of-digits}
Найпоширеніший спосіб рахувати суму цифр числа --- у\nolinebreak[3] циклі розглядати останню цифру числа (Pascal:\nolinebreak[2] \mbox{\texttt{n~mod~10}};\linebreak[1] С/С++:\nolinebreak[2] \mbox{\texttt{n\%10}}), а\nolinebreak[3] потім <<відсікати>>\nolinebreak[2] її (Pascal:\nolinebreak[2] \mbox{\texttt{n:=n~div~10}}; С/С++:\nolinebreak[2] \mbox{\texttt{n/=10}}). Ці\nolinebreak[2] операції треба робити з\nolinebreak[3] <<копією>> (а\nolinebreak[3] не\nolinebreak[3] самим поточним числом, щоб воно не\nolinebreak[3] втратилося від <<відсікань>>); це\nolinebreak[1] може бути забезпечено або присвоєнням у додаткову змінну, або передачею у\nolinebreak[3] функцію параметром-значенням (у\nolinebreak[3] Pascal\nolinebreak[3] --- без\nolinebreak[2] модифікатора\nolinebreak[2] \texttt{var}). Приклад реалізації\nolinebreak[3] --- 
\verb"ideone.com/YWcv5B"


{\color{green}\begin{small}

\renewcommand{\baselinestretch}{0.875}

(Повний вміст даного посилання \verb"ideone.com/YWcv5B" такий:
\verbatiminput{YWcv5B.pas}
--- кінець цитати посилання \verb"ideone.com/YWcv5B")

\end{small}}




Іншим способом є перетворення числа у рядкову величину й подальші звернення до окремих символів-цифр. Деталі сильно залежать від конкретної мови програмування, навіть конкретних бібліотек, тому їх важко пояснити теоретично. Дивіться конкретні р\'{о}зв'язки: 
\verb"ideone.com/5poAvj"


{\color{green}\begin{small}

\renewcommand{\baselinestretch}{0.875}

(Повний вміст даного посилання \verb"ideone.com/5poAvj" такий:
\verbatiminput{5poAvj.cpp}
--- кінець цитати посилання \verb"ideone.com/5poAvj")

\end{small}}


 (мовою\nolinebreak[2] C++) та 
\verb"ideone.com/d2FOrb"


{\color{green}\begin{small}

\renewcommand{\baselinestretch}{0.875}

(Повний вміст даного посилання \verb"ideone.com/d2FOrb" такий:
\verbatiminput{d2FOrb.pas}
--- кінець цитати посилання \verb"ideone.com/d2FOrb")

\end{small}}


 (мовою\nolinebreak[1] Pascal із функціями \texttt{IntToStr} та\nolinebreak[2] \texttt{StrToInt}\nolinebreak[3] --- найбільш лаконічний з усіх наведених).

Протягом перетворень значення числ\'{а} може перевищити\nolinebreak[2] 32767, тому треба забезпечити, щоб тип мав хоча\nolinebreak[3] б 32\nolinebreak[3] біти (див.\nolinebreak[2] також стор.~\pageref{text:overflow-example}).
% Протягом перетворень значення поточного числа може стати більшим\nolinebreak[2] 32767, тому треба забезпечити, щоб цілий тип був не\nolinebreak[1] 16-бітовим, а\nolinebreak[3] 32-бітовим. У\nolinebreak[3] Pascal: або писати тип \texttt{longint}, або здавати не\nolinebreak[3] під <<Free\nolinebreak[3] Pascal>>, а\nolinebreak[3] під <<Free\nolinebreak[3] Pascal in Delphi\nolinebreak[3] mode>> (останній варіант, який можна забезпечити також шляхом написання на\nolinebreak[3] початку програми рядка \verb"{$mode delphi}", робить 32-бітовим тип \texttt{integer}). У\nolinebreak[3] С/С++ це не\nolinebreak[3] повинно бути проблемою, бо просто \texttt{int} вже 32-бітовий. 


\begin{problemAllDefault}{Логічний куб}

Логічний куб\nolinebreak[3] --- це куб, у\nolinebreak[3] вершинах якого знаходяться значення 0\nolinebreak[3] (\texttt{false}) або\nolinebreak[3] 1\nolinebreak[3] (\texttt{true}). Потрібно знайти шлях від однієї заданої вершини до\nolinebreak[2] іншої; якщо такого шляху не\nolinebreak[3] існує, то вивести відповідне повідомлення. В\nolinebreak[3] кубі можна проходити через усі р\'{е}бра, а\nolinebreak[3] також через вершини, значення яких рівне~1.

\myflfigaw{\raisebox{-84pt}[0pt][72pt]{\begin{mfpic}[15]{0}{5}{0}{5}
\polygon{(0,0),(3,0),(3,3),(0,3)}
\lines{(3,0),(5,2),(5,5),(3,3)}
\lines{(0,3),(2,5),(5,5),(3,3)}
\dotted\lines{(2,2),(0,0)}
\dotted\lines{(2,2),(2,5)}
\dotted\lines{(2,2),(5,2)}
\tlabel[tc](0,0){$\phantom{9\over a}$\font\mysize = cmmi10 scaled 1440 \mysize e$\phantom{9\over a}$}
\tlabel[tc](2,2){$\phantom{9\over a}$\font\mysize = cmmi10 scaled 1440 \mysize f$\phantom{9\over a}$}
\tlabel[tc](5,2){$\phantom{9\over a}$\font\mysize = cmmi10 scaled 1440 \mysize g$\phantom{9\over a}$}
\tlabel[tc](3,0){$\phantom{99\over aa}$\font\mysize = cmmi10 scaled 1440 \mysize h$\phantom{9\over a}$}
\tlabel[bc](0,3){$\phantom{9\over a}$\font\mysize = cmmi10 scaled 1440 \mysize a$\phantom{9\over a}$}
\tlabel[bc](2,5){$\phantom{9\over a}$\font\mysize = cmmi10 scaled 1440 \mysize b$\phantom{9\over a}$}
\tlabel[bc](5,5){$\phantom{9\over a}$\font\mysize = cmmi10 scaled 1440 \mysize c$\phantom{9\over a}$}
\tlabel[bc](3,3){$\phantom{9\over a}$\font\mysize = cmmi10 scaled 1440 \mysize d$\phantom{9\over a}$}
\end{mfpic}}}
Напишіть програму яка знаходить шлях між двома вершинами (якщо він існує), та виводить його у вигляді послідовності вершин куба. Гарантовано, що ці дві задані вершини мають значення 1.

\InputFile
В\nolinebreak[3] першому рядку задаються через пробіл дві вершини куба, це\nolinebreak[1] можуть бути дві з\nolinebreak[3] наступних маленьких латинських літер: $a$,\nolinebreak[3] $b$, $c$, $d$, $e$, $f$, $g$,\nolinebreak[3] $h$. В\nolinebreak[3] наступному рядку, послідовно записуються значення кожної з вершин куба (0\nolinebreak[2] або\nolinebreak[3] 1). Значення у\nolinebreak[2] вершинах перелічені в\nolinebreak[2] алфавітному порядку.

\OutputFile\label{text:log-cude-as-example-of-non-unique-correct-answer}
Якщо шлях існує, то\nolinebreak[2] вивести (без\nolinebreak[2] пробілів) послідовність\linebreak[1] маленьких латинських літер мінімальної довжини, які\nolinebreak[2] визначають шуканий\nolinebreak[2] шлях. Якщо\nolinebreak[2] такого шляху не\nolinebreak[3] існує, то\nolinebreak[2] вивести рядок\nolinebreak[3] ``\texttt{NO}''.

\Examples
\begin{exampleSimple}{3em}{3em}%
\exmp{e d
10011011}{ead}%
\exmp{e d
00011110}{NO}%
\end{exampleSimple}

\end{problemAllDefault}

	

\Tutorial	Задачу можна розв'язати шляхом ручного аналізу випадків. Але це страшнуватий спосіб, вартий уваги лише коли нема кращих ідей. За\nolinebreak[2] посиланням 
\verb"ideone.com/jjq2Pq"


{\color{green}\begin{small}

\renewcommand{\baselinestretch}{0.875}

(Повний вміст даного посилання \verb"ideone.com/jjq2Pq" такий:
\verbatiminput{jjq2Pq.pas}
--- кінець цитати посилання \verb"ideone.com/jjq2Pq")

\end{small}}


 можна бачити трохи модифікований варіант програми, яку здав один з\nolinebreak[3] учасників. Він набирає 270\nolinebreak[3] балів з\nolinebreak[3] 300, що з\nolinebreak[3] одного боку немало, але\nolinebreak[2] з\nolinebreak[2] іншого\nolinebreak[3] --- на\nolinebreak[3] ручний розгляд випадків явно пішло багато часу, бали все\nolinebreak[2] одно не\nolinebreak[3] повні, а\nolinebreak[3] шукати помилку в\nolinebreak[3] \emph{такому} нагромадженні\nolinebreak[3] --- досить марудна справа. У\nolinebreak[3] цьому смислі краще писати осмислений алгоритм, щоб обробляти різні вхідні дані більш-менш однотипно.

{

\hyphenpenalty=400

Коли мова йде про\nolinebreak[3] мінімальні (за\nolinebreak[3] кількістю переходів) шляхи, природним є алгоритм \emph{пошуку\nolinebreak[3] вшир} (він\nolinebreak[3] же \emph{пошук у~ширину}, рос.\nolinebreak[3] \emph{поиск в~ширину}, англ.\nolinebreak[3] \emph{breadth first search}, \emph{BFS}). Застосовувати\nolinebreak[2] BFS треба до\nolinebreak[3] неорієн\-то\-ваного графа, вершини якого\nolinebreak[3] --- ті вершини\nolinebreak[1] куба, значення яких~1 (по\nolinebreak[3] яким можна проходити), а\nolinebreak[3] р\'{е}бра\nolinebreak[3] --- ті р\'{е}бра куба, що\nolinebreak[3] поєднують вершини зі\nolinebreak[3] значеннями~1. Причому, раз питають не\nolinebreak[3] в\'{і}д\-стань (як\nolinebreak[3] число), а\nolinebreak[3] шлях (як\nolinebreak[3] послідовність вершин), потрібен варіант\nolinebreak[2] BFS,\linebreak[1] у\nolinebreak[3] якому запам'ятовуються батьківські вершини (вони\nolinebreak[3] ж попередники),\linebreak[1] а\nolinebreak[3] потім відбувається відновлення шляху \emph{зворотнім ходом}. Деталі можна знайти в\nolinebreak[3] Інтернеті або літературі.

}

Інший можливий спосіб\nolinebreak[3] --- повний перебір (наприклад, рекурсивний) усіх можливих шляхів, що не\nolinebreak[3] містять повторень вершин. Приклад такого розв'язку\nolinebreak[3] --- 
\verb"ideone.com/pihZzm"


{\color{green}\begin{small}

\renewcommand{\baselinestretch}{0.875}

(Повний вміст даного посилання \verb"ideone.com/pihZzm" такий:
\verbatiminput{pihZzm.pas}
--- кінець цитати посилання \verb"ideone.com/pihZzm")

\end{small}}


\hspace{0.5em plus 1em} Детальніше про цей підхід реалізації перебору можна знайти в\nolinebreak[3] Інтернеті або літературі за назвами \emph{пошук з\nolinebreak[3] поверненнями}, \emph{бектрекінг} (рос.\nolinebreak[3] \emph{поиск с\nolinebreak[3] возвратом}, англ.\nolinebreak[3] \emph{backtracking}). Якщо говорити про бектрекінг взагалі, то цим не\nolinebreak[3] дуже складним способом суто теоретично можна розв'язати дуже багато задач; але біда в тім, що бектрекінг зазвичай працює надто довго (наприклад, $O(N!)$) і не~вкладається в обмеження часу. А тут вкладається, бо вершин-то всього~8.

На\nolinebreak[3] жаль, ідея <<писати осмислений алгоритм, щоб обробляти різні вхідні дані однотипно>> мало придатна до заданої рисунком відповідності ребер куба його вершинам. Важко сформулювати правилом, між якими вершинами є ребро і між якими нема. (Найкраще, що вдалося --- заплутане \textsl{<<Позначки вершин відрізняються або на~4, або на~1, але крім $d{\leftrightarrow}e$, а~крім названих є ще $a{\leftrightarrow}d$ і\nolinebreak[3] $e{\leftrightarrow}h$>>}.) Мабуть, легше задати явний перелік (чи\nolinebreak[3] як у\nolinebreak[3] розв'язку з попереднього абзацу, чи вписати у текст програми константний масив --- матрицю суміжності графа, чи\nolinebreak[2] ще якось). Але це треба ретельно звіряти з умовою, бо успішна побудова шляхів у одній частині графа ніяк не\nolinebreak[3] перевіряє правильність задання ребер у іншій частині. 

\MyParagraph{Прості способи набрати частину балів}\label{text:log-cube-how-to-get-part-of-points-easily}
Тести даної задачі такі, що програма, яка, не\nolinebreak[3] вирішуючи задачу по\nolinebreak[3] суті, завжди виводить~``\texttt{NO}'', набирає 90\nolinebreak[3] балів з~300. Можливо, це й несправедливо багато. Але, з\nolinebreak[3] умови очевидно, що така програма мусила хоч щось та набрати; хто не\nolinebreak[3] міг розв'язати правильно\nolinebreak[3] --- мав\nolinebreak[3] би пошукати якісь такі варіанти.
Трохи чесніший спосіб\nolinebreak[3] --- перевіряти, чи\nolinebreak[3] є вершини кінцями одного ребр\'{а}, і\nolinebreak[3] якщо так, то виводити ці вершини, а\nolinebreak[3] якщо\nolinebreak[3] ні, то\nolinebreak[3] ``\texttt{NO}''. Він набирав 150\nolinebreak[3] балів (рівно половину).


\begin{problem}{Всюдисущі ч\'{и}сла}{Клавіатура (stdin)}{Екран (stdout)}{3 сек}{64 мегабайти}\label{sec:omnipresent-numbers}

Дано прямокутну таблицю $N{\*}M$\nolinebreak[3] чисел. Гарантовано, що\nolinebreak[2] у\nolinebreak[3] кожному окремо взятому рядку всі ч\'{и}сла різні й монотонно зростають.

Напишіть програму, яка шукатиме перелік (також у\nolinebreak[3] порядку зростання) всіх тих чисел, які зустрічаються\linebreak[1] в\nolinebreak[3] усіх $N$ рядках.

\InputFile	слід прочитати зі стандартного входу (клавіатури). У~першому рядку задано два числ\'{а} $N$ та~$M$. Далі йдуть $N$ рядків, кожен з яких містить рівно~$M$ розділених пропусками чисел (гарантовано у~порядку зростання). 

\OutputFile	виведіть на стандартний вихід (екран). Програма має вивести в один рядок через пробіли у порядку зростання всі ті числа, які зустрілися абсолютно в усіх рядках. Кількість чисел виводити не~треба. Після виведення всіх чисел потрібно зробити одне переведення рядка. Якщо нема жодного числа, що зустрілося в усіх рядках, виведення повинно не~містити жодного видимого символу, але містити переведення рядка.


\Example
\begin{exampleSimple}{6em}{3em}%
\exmp{4 5
6 8 10 13 19
8 9 13 16 19
6 8 12 13 15
3 8 13 17 19}{8 13}%
\end{exampleSimple}

\Scoring
20\% балів припадатиме на тести, в~яких $3{\<}{N,M}{\<}20$, значення чисел від~0 до~100.

Ще 20\% --- на тести, в~яких $3{\<}{N,M}{\<}20$, значення чисел від $-10^9$ до~$+10^9$.

Ще 20\% --- на тести, в~яких $1000{\<}{N,M}{\<}1234$, значення від 0 до 12345.

Решта 40\% --- на тести, в~яких $1000{\<}{N,M}{\<}1234$, значення від $-10^9$ до~$+10^9$.

Здавати потрібно одну програму, а~не~чотири; різні обмеження вказані, щоб пояснити, скільки балів можна отримати, розв’язавши задачу не~повністю.


\end{problem}
	

\Tutorial	
Очевидний підхід\nolinebreak[3] --- бр\'{а}ти кожне число \mbox{1-го} рядка, і шукати його в\nolinebreak[3] усіх інших рядках. Якщо знайдене в\nolinebreak[3] усіх\nolinebreak[3] --- поточне число слід включити у\nolinebreak[3] відповідь (а\nolinebreak[3] якщо\nolinebreak[2] ні, то\nolinebreak[3] ні).
І\nolinebreak[3] цей підхід \emph{може} бути правильним. Але\nolinebreak[2] \emph{залежно} від того, чи\nolinebreak[3] реалізувати його наївно, чи\nolinebreak[3] ефективно. 

Наївний підхід\nolinebreak[3] --- для пошуку кожного числ\'{а} в кожному рядку запускати свій цикл, переглядаючи увесь рядок. Такий розв'язок потребує $O(N{\cdot}M^2)$ часу, що може не\nolinebreak[3] поміщатися в обмеження. Власне, $1234^3\dib{{\approx}}{1{,}88{\cdot}10^9}$ простих порівнянь на\nolinebreak[2] потужнішому сервері могло~б і поміститися у\nolinebreak[3] 3~сек. Але в\nolinebreak[3] тому й смисл задачі, щоб реалізувати щось ефективніше, і\nolinebreak[3] на\nolinebreak[3] потужнішому сервері ставили~б жорсткіший time\nolinebreak[2] limit. А\nolinebreak[3] такий розв'язок благополучно отримує свої 120\nolinebreak[3] балів з~300 (якщо вчасно робити \texttt{break}\nolinebreak[3] --- \emph{трохи} більше).

\MyParagraph{Правильний розв'язок $\No\,$1}
Той самий підхід можна реалізувати ефективніше завдяки тому, що кожен рядок гарантовано впорядкований. Адже для впорядкованих масивів можливий \emph{бінарний пошук} (скорочено \emph{бін\-пошук}, він\nolinebreak[3] же \emph{двійковий пошук}, він\nolinebreak[3] же \emph{дихотомія}). Суть бінпошуку: щоб знайти значення, починають з\nolinebreak[3] середнього (за\nolinebreak[3] індексом) елемента; якщо раптом він якраз рівний шуканому значенню, пошук успішно завершений; якщо шукане значення більше за\nolinebreak[3] середній елемент, то\nolinebreak[3] можна відкинути усю ліву половину масиву, а\nolinebreak[3] якщо менше\nolinebreak[3] --- усю праву половину. На\nolinebreak[3] наступному кроці (якщо він взагалі потрібен) робиться те\nolinebreak[3] с\'{а}ме, але з половиною, що залишилась. І\nolinebreak[3] так далі. Тобто, за 1--2 порівняння можна зменшити діапазон пошуку щонайменше вдвічі, і пошук у масиві розміром 1234 потребує до\nolinebreak[2] ${\approx}20$\nolinebreak[3] порівнянь (асимптотично\nolinebreak[3] --- $O(\log{}M)$). А\nolinebreak[3] $N{\cdot}M$\nolinebreak[2] штук \emph{таких} пошуків поміщаються у обмеження. 

Рекомендується знайти в\nolinebreak[3] Інтернеті або літературі додаткові деталі щодо бін\-пошуку. Бо\nolinebreak[3] це такий алгоритм, у\nolinebreak[3] якому, навіть добре знаючи загальну ідею, легко помил\'{и}тися й отримати код, який часто працює правильно, але іноді зациклюється або/та видає неправильні результати. 

Тим, хто пише мовою\nolinebreak[3] C++, рекомендується вивчити, як у\nolinebreak[3] деяких ситуаціях (включно з цією задачею) можна не\nolinebreak[3] писати бін\-пошук самому, якщо навчитися правильно користуватися функцією \verb"lower_bound" бібліотеки\nolinebreak[2] \texttt{algorithm}.


\MyParagraph{Правильний розв'язок $\No\,$2}
Ще один правильний розв'язок (із\nolinebreak[2] \emph{кращою} асимптотичною оцінкою $O(N{\cdot}M)$ проти $O(N{\cdot}M{\cdot}\log{}M)$ у\nolinebreak[3] попереднього; але ловити цю відмінність за часом роб\'{о}ти програми не~дуже реально, тому попередній розв'язок теж вважається ефективним)\nolinebreak[3] --- багатократно застосовувати модифікацію \emph{злиття} (рос.\nolinebreak[3] \emph{слияние}, англ.\nolinebreak[3] \emph{merge}). 

Суть стандартного злиття така. Нехай є дві (\emph{обов'язково впорядковані!}) послідовності (зазвичай масиви або фрагменти одного масиву, але можуть бути й інші, як-то файли чи зв'язні списки). З~них можна легко й швидко сформувати впорядковану послі\-дов\-ність-від\-повідь, куди входять усі елемети обох заданих, якщо діяти так. Призначаємо кожній зі вхідних послідовностей поточну позицію як початок цієї послідовності. І\nolinebreak[3] повторюємо у\nolinebreak[3] циклі такі дії: (1)~беремо (пишемо у відповідь) менший з поточних елементів; (2)~зсуваємо поточну позицію тієї вхідної послідовності (\emph{лише однієї з двох!}), звідки взятий цей менший елемент. Коли одна з послідовностей закінчується, дописуємо у послі\-дов\-ність-від\-по\-відь увесь ще\nolinebreak[3] не\nolinebreak[3] використаний <<хвіст>> іншої. Це\nolinebreak[3] --- \emph{стандартне} злиття, яке робить те\nolinebreak[3] саме (але\nolinebreak[3] швидше), що дописування однієї з послідовностей після іншої та сортування всього разом. Очевидно, воно працює за час $O(l_1{+}l_2)$ (де\nolinebreak[3] $l_1$\nolinebreak[1] та\nolinebreak[3] $l_2$\nolinebreak[3] --- довж\'{и}ни вхідних послідовностей).

У\nolinebreak[3] задачі треба інше (спільні елементи). Але, виявляється, під це легко модифікувати злиття. Треба при порівнянні поточних елементів різних послідовностей розрізняти три випадки: якщо поточний елемент \mbox{1-ої} послідовності строго менший за поточний елемент \mbox{2-ої}, то зсунути поточну позицію \mbox{1-ої} (нічого не~пишучи у~відповідь); якщо строго більший, то зсунути позицію \mbox{2-ої} (теж не~пишучи); якщо поточні елементи рівні, то записати це однакове (спільне) значення у результат та зсунути поточні позиції обох послідовностей. При завершенні однієї з послідовностей треба \emph{не}~дописувати <<хвіст>> іншої. Час роботи такого модифікату злиття теж $O(l_1{+}l_2)$.

Зрештою, це\nolinebreak[3] --- злиття \emph{двох} послідовностей; пропонується першого разу злити \mbox{1-ий} рядок з \mbox{2-им}, а\nolinebreak[3] потім зливати з кожним черговим (\mbox{3-ім},\nolinebreak[2] \mbox{4-им},~\dots) результат попереднього злиття. \emph{Завдяки} тому, що завжди вибираються лише спільні елементи, розмір кожної з послідовностей${}\<M$, тому ${N{-}1}$ застосувань злиття займуть сумарний час $O(N{\cdot}M)$. (\emph{Якби} робилося стандартне злиття і розміри зростали, оцінка була~б значно більшою.)

Знайдіть додаткову інформацію про злиття. Її\nolinebreak[2] багато, але про злиття часто пишуть як про складову сортування, а\nolinebreak[3] тут потрібне \emph{сам\'{е} злиття, без} рекурсивної надбудови сортування. Крім того, не\nolinebreak[3] всі алгоритми, які правильно виконують стандартне злиття, легко модифікуються на вибір лише спільних.

Користувачам С++ можна також ознайомитися з \emph{готовою} потрібною модифікацією злиття\nolinebreak[3] --- функцією \verb"set_intersection" бібліотеки \verb"algorithm".

Таким чином, грамотні користувачі\nolinebreak[3] C++ в\nolinebreak[3] обох наведених способах розв'язання у~виграші, бо можуть значну частину потрібного алгоритму не~писати самостійно, а\nolinebreak[3] використати бібліотечні засоби. Водночас, малодосвідчені користувачі\nolinebreak[3] C++ у~програші, бо можуть і не~знати, як вирішити проблему, що читання \verb"cin"-ом не~вкладається у\nolinebreak[3] обмеження часу. (Як? Див.~стор.~\pageref{text:io-streams-versus-scanf-printf}.)

\MyParagraph{Навіщо в умові згадані групи тестів зі значеннями до 12345?}
Щоб дати можливість набрати ще~${\approx}20$\%~балів тим, хто не~додумався ні до одного з правильних способів, але\nolinebreak[3] знає наступний, складністю $\Theta(N{\cdot}M\dib{{+}}V)$, де\nolinebreak[3] $V$\nolinebreak[3] --- діапазон значень. (Мається на увазі якось на кшталт <<\texttt{if} (розміри малі) \texttt{then} (вирішити способом згаданим на самому початку розбору) \texttt{else} (вирішити описаним далі способом)>>. Вхідні дані, коли великі одночасно і\nolinebreak[3] кількості, і\nolinebreak[3] значення, такий розв'язок не\nolinebreak[3] пройде, але можливо набере більше балів.)

Так от, для малих значень ефективний такий підхід. Заведемо масив, \emph{індексами} якого будуть \emph{значення} зі\nolinebreak[3] вхідних даних, щоб щоразу, прочитавши деяке~\texttt{v}, збільшувати\nolinebreak[2] \texttt{num[v]}\nolinebreak[2] на~1 (спочатку всі\nolinebreak[3] \texttt{num[$\cdot$]} ініціалізуються нулями). Таким чином, після обробки усіх вхідних даних кожне значення\nolinebreak[2] \texttt{num[v]} означатиме, скільки разів зустрілося число~\texttt{v}; оскільки у\nolinebreak[3] кожному окремо взятому рядку всі ч\'{и}сла різні, то \mbox{\texttt{num[v]=N}} рівносильно <<\texttt{v}~зустрілося в усіх рядках>>.\label{text:omnipresent-numbers-end}





\contest{Дистанційний тур ІІІ (обласного) етапу 2013/14 навч. року}{Черкаська обл.}{18.01.2014}
\renewenvironment{problemAllDefault}[1]{\vspace{10mm}\par\begin{problem}{#1}{Клавіатура (stdin)}{Екран (stdout)}{1 сек}{64 мегабайти}}{\end{problem}}


\subsection{Дистанційний тур ІІІ (обласного) етапу 2013/14 н.~р.}

У 2013/14 навч.\nolinebreak[3] році III (обласний) етап у Черкаській області складався з двох турів, де один був частково дистанційним (учасники приїздили не\nolinebreak[3] до\nolinebreak[3] м.~Черкаси, а\nolinebreak[3] до\nolinebreak[3] своїх райцентрів) і проводився на задачах черкаських авторів. С\'{а}ме він і наведений у даному збірнику. Цей тур позиціонувався одночасно і\nolinebreak[2] як\nolinebreak[2] змагальний, і\nolinebreak[2] як\nolinebreak[2] відбірковий; тому рівень складності комплекта задач дещо нижчий, ніж зазвичай на~III~етапі.

Задачі доступні для дорішування (\verb"ejudge.ckipo.edu.ua", змагання $\No$15). 

2-й тур відбувався у~Черкасах, але\nolinebreak[2] на\nolinebreak[2] задачах інших авторів, іншій системі (ejudge, але\nolinebreak[2] не\nolinebreak[2] \verb"ejudge.ckipo.edu.ua"), та\nolinebreak[3] й\nolinebreak[3] про його дорішування автору даного збірника нічого не\nolinebreak[3] відомо; тому він до збірника не~включений.


\vspace{-0.5\baselineskip minus 1cm}
\begin{problemAllDefault}{ISBN}

ISBN (з~англ.\nolinebreak[2] International Standard Book Number\nolinebreak[3] --- міжнародний стандартний номер книги) універсальний ідентифікаційний номер, що присвоюється книзі або брошурі з\nolinebreak[3] метою їх класифікації. ISBN\nolinebreak[3] призначений для ідентифікації окремих книг або різних видань та є унікальним для кожного видання книги. Даний номер містить десять цифр, перші дев'ять з\nolinebreak[3] яких ідентифікують книгу, а\nolinebreak[3] остання цифра використовується для перевірки коректності всього номеру\nolinebreak[3] ISBN. Для\nolinebreak[3] перевірки\nolinebreak[3] ISBN обчислюється сума добутків цифр на їхній номер, нумерація при цьому починається з крайньої правої цифри. В~результаті має бути отримано число, що без остачі ділиться на~11.

Наприклад: \textbf{0201103311}\nolinebreak[3] --- коректний номер, тому\nolinebreak[3] що ${\mathbf{0}{\*}10}\dib{{+}}{\mathbf{2}{\*}9}\dib{{+}}{\mathbf{0}{\*}8}\dib{{+}}{\mathbf{1}{\*}7}\dib{{+}}{\mathbf{1}{\*}6}\dib{{+}}{\mathbf{0}{\*}5}\dib{{+}}{\mathbf{3}{\*}4}\dib{{+}}{\mathbf{3}{\*}3}\dib{{+}}{\mathbf{1}{\*}2}\dib{{+}}{\mathbf{1}{\*}1}\dib{{=}}55$, що\nolinebreak[3] націло ділиться на~11.

Кожна з~перших дев'яти цифр може приймати значення від 0 до~9. 

Напишіть програму, що читає ISBN\nolinebreak[2] код з\nolinebreak[3] однією пропущеною цифрою (вона буде позначатись як символ\nolinebreak[2] <<~>>\nolinebreak[3] (пробіл)) і виводить значення пропущеної цифри.


\Example
\begin{exampleSimple}{5em}{3em}%
\exmp{020110 311}{3}%
\end{exampleSimple}

\Note	У~справжніх ISBN-номерах в\nolinebreak[3] якості останньої цифри може бути також велика латинська~\texttt{X}, що позначає~10. Але в\nolinebreak[3] цій задачі таких номерів гарантовано не~буде.

\end{problemAllDefault}
	

\Tutorial	В\nolinebreak[3] принципі, \emph{можна} вивести аналітичну формулу, але\nolinebreak[2] це\nolinebreak[1] потреб\'{у}є знань з\nolinebreak[3] теорії чисел (бажаючі можуть знайти, що таке \emph{кільце залишків за модулем} та \emph{мал\'{а} теорема Ферма}, і застосувати до даної задачі). Все\nolinebreak[3] це було\nolinebreak[3] \emph{би} доцільним, \emph{якби} довжина ISBN-коду становила, наприклад, \mbox{сотні}\nolinebreak[1] \mbox{тисяч}, так що розглянутий далі простіший і значно більш <<програмістський>> (а\nolinebreak[3] не\nolinebreak[3] <<математичний>>) підхід працював\nolinebreak[3] \emph{би} надто довго.

А\nolinebreak[3] для 10~цифр підходить і значно простіший перебір, тобто перепробувати усі варіанти від~0\nolinebreak[1] до~9 і для кожного подивитися, чи\nolinebreak[3] виконується описана в\nolinebreak[3] умові правильність\nolinebreak[3] ISBN. Приклад реалізації див.\nolinebreak[1] 
\verb"ideone.com/g3SbMb"


{\color{green}\begin{small}

\renewcommand{\baselinestretch}{0.875}

(Повний вміст даного посилання \verb"ideone.com/g3SbMb" такий:
\verbatiminput{g3SbMb.pas}
--- кінець цитати посилання \verb"ideone.com/g3SbMb")

\end{small}}


\hspace{0.5em plus 1em} Правда, при різних правильних відповідях ця програма вивела~б усі, хоча на~олімпіадах треба виводити будь-яку одну. Але насправді це неактуально, бо різні правильні відповіді неможливі (хто вивчав питання, згадані у попередньому абзаці, можуть це довести; решта можуть або\nolinebreak[3] повірити, або\nolinebreak[3] дописати у розв'язок \verb"break" для обривання роб\'{о}ти після виведення першої відповіді.)

Говорити про асимптотичну складність некоректно, бо нема того розміру вхідних даних, який міг~би прямувати до~$\infty$. \emph{Якби} довжина ISBN-коду становила довільне\nolinebreak[3] $N$ (але таке, щоб $N{+}1$ було простим, і\nolinebreak[3] щоб аналогічна сума добутків ділилася без остачі на\nolinebreak[2] $N{+}1$), можна було~\emph{би} сказати, що перебір має складність\nolinebreak[3] $\Theta(N^2)$, а\nolinebreak[3] теоретико-числовий розв'язок\nolinebreak[3] --- ${\Theta(N+\log{}N)}\dib{{=}}{\Theta(N)}$.

Ще \emph{може} бути проблемою формат вхідних даних, особливо для малодосвідчених користувачів~\mbox{С++}: \verb"cin>>a>>b" ніби читає в~\verb"a" те, що до пробіла, й у~\verb"b" те, що після; але\nolinebreak[3] в\nolinebreak[2] \emph{обох} випадках <<пробіл замінює найпершу цифру>> та <<\dots~найостаннішу~\dots>> всі\nolinebreak[3] 9\nolinebreak[1] осмислених цифр ідуть в~\verb"a". Може сп\'{а}сти на думку читати у циклі окремі \mbox{\verb"char"-и}; але при стандартних налаштуваннях \verb"cin>>c" (\verb"c"~---\nolinebreak[1] типу\nolinebreak[2] \verb"char") взагалі пропускає пробіл, і взнати його позицію неможливо. Один зі способів\nolinebreak[3] --- перед читанням \mbox{\verb"char"-ів} викликати % метод
\verb"cin.unsetf(ios::skipws)", щоб пробіли та переведення рядка таки читались у ті \mbox{\verb"char"-и}. Інший\nolinebreak[3] --- використати функцію \verb"getline(cin,s)" (\verb"s"~---\nolinebreak[1] типу\nolinebreak[1] \verb"string"); вона (як\nolinebreak[2] і\nolinebreak[2] паскалівський \verb"readln") читає все, включаючи пробіли, до кінця рядка.



\begin{problemAllDefault}{Точні квадрати}

Напишіть програму, яка знаходитиме кількість натуральних чисел із проміжку $[a; b]$, які задовольняють одночасно двом таким вимогам:
\begin{enumerate}
\item
число є точним квадратом, тобто корінь з нього цілий (наприклад, точними квадратами є ${1{=}1^2}$, ${9{=}3^2}$, ${1024{=}32^2}$; а\nolinebreak[3] 8, 17, 1000 не~є точними квадратами).
\item
сума цифр цього числа кратна~$K$. (Наприклад, сума цифр числа 16 рівна ${1{+}6{=}7}$.)
\end{enumerate}
Програма повинна прочитати три числа в одному рядку $a$~$b$~$K$ і вивести одне число\nolinebreak[3] --- кількість чисел, які задовольняють умовам.

\Scoring	В усіх тестах виконується $1\dib{{\<}}a\dib{{\<}}b\dib{{\<}}2\cdot10^9$, $2\dib{{\<}}K\dib{{\<}}42$. 

40\%~балів припадає на тести, в~яких виконується $1\dib{{\<}}a\dib{{\<}}b\dib{{\<}}30\,000$, ${K{=}9}$.


\Example
\begin{exampleSimple}{5em}{3em}%
\exmp{7 222 9}{4}%
\end{exampleSimple}

\Note	Цими чотирма числами є 9, 36, 81, 144. 

\end{problemAllDefault}
	

\Tutorial	Ніби нескладна задача\nolinebreak[3] --- перебрати, кожне перевірити (причому, <<чи~є точним квадратом>> вже розглядали на\nolinebreak[3] стор.~\pageref{text:how-to-test-if-sqrt-N-integer}, суму цифр\nolinebreak[3] --- на\nolinebreak[3] стор.~\pageref{text:sum-of-digits})\dots{}
Але 
\verb"ideone.com/gLqsYd"


{\color{green}\begin{small}

\renewcommand{\baselinestretch}{0.875}

(Повний вміст даного посилання \verb"ideone.com/gLqsYd" такий:
\verbatiminput{gLqsYd.pas}
--- кінець цитати посилання \verb"ideone.com/gLqsYd")

\end{small}}


 набирає лише 50~балів зі~100.

Проблема у тому, що перевіряти аж 2~млрд чисел\nolinebreak[3] --- забагато. Навіть якщо (абсолютно слушно) рахувати суму цифр лише для тих, які пройшли перевірку <<чи~є точним квадратом>>. Пришвидшити розв'язок досить просто\nolinebreak[3] --- \emph{генерувати} \emph{лише} точні квадрати, а\nolinebreak[3] не\nolinebreak[3] перебирати й перевіряти геть усі ч\'{и}сла проміжку. Достатньо запускати цикл не\nolinebreak[3] від\nolinebreak[3] $a$ до~$b$, а\nolinebreak[2] від~${\approx}\sqrt{a}$ до~${\approx}\sqrt{b}$ й працювати\nolinebreak[2] з~$i^2$. Правда, тут можна заплутатися, \emph{як} перетворити <<${\approx}\sqrt{a}$>> та <<${\approx}\sqrt{b}$>> у~точні цілі значення. Не~дуже красивий, зате точно правильний спосіб\nolinebreak[3] --- узяти м\'{е}жі з невеличким <<запасом>>, а~потім отримане~$i^2$ все-таки перевірити на належність проміжку~\mbox{$[a; b]$}. Такий розв'язок, навіть із цією зайвою перевіркою, безсумнівно вкладатиметься у 1~сек з великим запасом, бо тепер кількість ітерацій${}\<\sqrt{2{\cdot}10^9}\approx{45\textnormal{~тис}}$.
Див.\nolinebreak[2] 
\verb"ideone.com/EplT1L"


{\color{green}\begin{small}

\renewcommand{\baselinestretch}{0.875}

(Повний вміст даного посилання \verb"ideone.com/EplT1L" такий:
\verbatiminput{EplT1L.pas}
--- кінець цитати посилання \verb"ideone.com/EplT1L")

\end{small}}




З асимптотичною оцінкою даного розв'язку є неоднозначність. Попередній абзац наштовхує на ${\Theta(\sqrt{b}-\sqrt{a})}$ або $O(\sqrt{b})$; але \emph{якщо} враховувати ще цикл у \texttt{sumOfDigits}, вийде $O(\sqrt{b}\cdot\log{}b)$. 
% % % Слово <<якщо>> виділене, бо з~одного боку, кількість цифр обмежена 
% % % розрядністю типу, а асимптотична оцінка ігнорує константи; з~іншого
% % % \nolinebreak[3] --- цей цикл всер\'{е}дині \texttt{sumOfDigits} все ж 
% % % займає час\dots


\begin{problemAllDefault}{Ложбан}

\emph{Ложбан} (англ.\nolinebreak[3] \emph{Lojban})\nolinebreak[3] --- це штучна мова, яка була створена у\nolinebreak[3] 1987~році Групою Логічних Мов та базується на логлані (логічна мова). При створенні основною ціллю була повніша, вільно доступна, зручна для використання мова. Вона є експериментальною і сконструйована для перевірки гіпотези Сепіра-Ворфа. Ця гіпотеза припускає, що люди, які говорять різними мовами, по-різному сприймають світ і по-різному мислять.

Дана мова є однією з найпростіших штучних мов. Наприклад цифри від\nolinebreak[2] 0\nolinebreak[1] до\nolinebreak[3] 9 записуються наступним чином:

\vspace{-0.25\baselineskip plus 6pt minus 6pt}

\begin{center}
\begin{ttfamily}
\begin{tabular}{cc@{ ~ ~ ~ }cc@{ ~ ~ ~ }cc@{ ~ ~ ~ }cc}
1 & pa	&	4 & vo	&	7 & ze				\\
2 & re	&	5 & mu	&	8 & bi	&	0 & no	\\
3 & ci	&	6 & xa	&	9 & so				
\end{tabular}
\end{ttfamily}

\end{center}

\vspace{-0.25\baselineskip plus 6pt minus 6pt}

Великі числа утворюються склеюванням цифр разом. Наприклад, число~123 це \texttt{pareci}.

\Task	\hspace{0pt minus 0.5em}Напишіть програму, яка зчитує рядок на\nolinebreak[2] Ложбані (що\nolinebreak[3] представляє собою число${}\<1\,000\,000$) та виводить цей рядок у цифровому вигляді.

\Example
\begin{exampleSimple}{5em}{3em}%
\exmp{renopavo}{2014}%
\end{exampleSimple}

\end{problemAllDefault}
	

\Tutorial	По-перше, слід знайти в умові справді потрібну частину: \textsl{<<Є\nolinebreak[3] текст, який гарантовано отриманий таким чином: взяли число$\dib{{\<}}$1000000, й замінили кожну цифру на дві букви згідно наведеної таблички. Провести зворотнє перетворення цього текста у\nolinebreak[3] число.>>}.

По-друге, все могло\nolinebreak[3] \emph{би} бути вельми складн\'{и}м, \emph{якби} траплялися ситуації, коли одне зі\nolinebreak[2] слів\nolinebreak[3] --- початок іншого (як-то <<7\nolinebreak[3] позначається як \texttt{mis}, 8\nolinebreak[3] --- як\nolinebreak[2] \texttt{misiv}>>). Так що треба відмовитися від ідеї писати універсальну програму, яка могла\nolinebreak[3] би працювати з різними позначеннями цифр, і\nolinebreak[3] ретельно дослідити, якими конкретними, заданими в\nolinebreak[3] умові, словами кодуються цифри. І\nolinebreak[3] побачити, що тут не\nolinebreak[3] лише нема такої ситуації, а\nolinebreak[3] ще й усі ці слова дволітерні. 

Так що задача насправді досить проста. Треба лише зуміти прочитати це у\nolinebreak[3] громіздкій умові. Наприклад, див.\nolinebreak[2] 
\verb"ideone.com/BNuDlL"


{\color{green}\begin{small}

\renewcommand{\baselinestretch}{0.875}

(Повний вміст даного посилання \verb"ideone.com/BNuDlL" такий:
\verbatiminput{BNuDlL.pas}
--- кінець цитати посилання \verb"ideone.com/BNuDlL")

\end{small}}


\hspace{0.5em plus 1em} Або, ще нахабніше використавши, що вхідні дані \emph{гарантовано} являють собою якесь закодоване число, можна написати щось іще простіше, наприклад 
\verb"ideone.com/Odw21F"


{\color{green}\begin{small}

\renewcommand{\baselinestretch}{0.875}

(Повний вміст даного посилання \verb"ideone.com/Odw21F" такий:
\verbatiminput{Odw21F.pas}
--- кінець цитати посилання \verb"ideone.com/Odw21F")

\end{small}}




Така умова задачі в~принципі могла~б містити підвох: ніде не\nolinebreak[3] сказано прямо, чи\nolinebreak[3] ч\'{и}сла натуральні. (А~раптом від'ємні? А~раптом взагалі десяткові дроби? А~якщо від'ємні, то скільки може бути цифр, адже ${({-}10^{100500}){<}10^6}$?) За\nolinebreak[3] правилами переважної більшості олімпіад з~інформатики, учасник має право задати питання журі щодо таких моментів умови. Або, враховуючи можливість багатократної здачі, пробувати варіанти\dots\ Конкретно в даній задачі даного туру підвоху не~було (ч\'{и}сла були цілі невід'ємні).


\begin{problem}{Графічний пароль}{Клавіатура (stdin)}{Екран (stdout)}{4 сек}{64 мегабайти}

\hyphenpenalty=400

\myflfigaw{\raisebox{-72pt}[0pt][72pt]{\begin{mfpic}[28]{-0.5}{2.5}{-0.5}{2.5}
\def\c#1#2{\circle{(#1,#2),0.06}\gclear\circle{(#1,#2),0.03}}
\c{0}{0}
\c{0}{1}
\c{0}{2}
\c{1}{0}
\c{1}{1}
\c{1}{2}
\c{2}{0}
\c{2}{1}
\c{2}{2}
\pen{2pt}
\circle{(0,0),0.325}
\circle{(0,1),0.325}
\circle{(0,2),0.325}
\circle{(1,0),0.325}
\circle{(1,1),0.325}
\circle{(1,2),0.325}
\circle{(2,0),0.325}
\circle{(2,1),0.325}
\circle{(2,2),0.325}
\drawcolor{gray(0.375)}
\lines{(1,1),(0,1),(0,0),(2,0),(2,2),(0,2)}
\end{mfpic}}}
Програміст Василь недавно придбав собі новий смартфон і встановив на ньому графічний пароль. Графічний пароль представляє собою ламану лінію, яка проходить через вершини сітки розміром $3{\*}3$ (не\nolinebreak[3] обов'язково через всі). Але згодом Василь зрозумів, що пароль на сітці $3{\*}3$ не\nolinebreak[3] є досить безпечним, і\nolinebreak[3] вирішив виправити цю проблему. Для цього він збільшив розмір сітки до $5000{\*}5000$, але при цьому наклав обмеження на відрізки ламаної\nolinebreak[3] --- тепер вони можуть бути лише горизонтальними та вертикальними. Василь ще хотів добавити функцію, яка\nolinebreak[3] б виводила кількість самоперетинів у графічному паролі, але так склалося, що він не\nolinebreak[3] досить знайомий з ефективними алгоритмами, тому він просить вашої допомоги.

\InputFile
Перший рядок містить ціле число\nolinebreak[3] $N$\nolinebreak[3] --- кількість вершин в ламаній лінії ($2\dib{{\<}}N\dib{{\<}}{1\,000\,000}$). Кожен з наступних $N$ рядків містить два цілих числ\'{а}\nolinebreak[1] $x$ та\nolinebreak[3] $y$\nolinebreak[3] --- координати відповідної вершини ламаної ($0\dib{{\<}}{x, y}\dib{{<}}5000$). Гарантується, що ламана у вхідних даних містить лише горизонтальні та вертикальні відрізки, які можуть перетинатися, але\nolinebreak[1] не\nolinebreak[3] можуть накладатись один на одного. Ніякі дві вершини ламаної (в~т.~ч. старт та\nolinebreak[2] фініш) не\nolinebreak[3] знаходяться в одній і тій самій точці.

\OutputFile
Необхідно вивести єдине ціле число\nolinebreak[3] --- кількість самоперетинів у\nolinebreak[3] ламаній.

\vspace{-\baselineskip}

\Examples
\begin{exampleSimple}{5em}{3em}%
\exmp{6
1 1
0 1
0 0
2 0
2 2
0 2}{0}%
\end{exampleSimple} %\hspace{1cm}
\begin{exampleSimple}{5em}{3em}%
\exmp{5
0 1
3 1
3 2
2 2
2 0}{1}%
\end{exampleSimple}

\end{problem}

	

\Tutorial	
Головне при розв'язуванні цієї задачі\nolinebreak[3] --- не\nolinebreak[3] перестаратися й не\nolinebreak[3] почати писати <<чесні>> перевірки перетинів. Такі перевірки могли\nolinebreak[3] б бути доречними при більших розмірах сітки та меншій кількості відрізків ламаної. А\nolinebreak[3] при заданій кількості, відомі автору даного розбору оптимізації перебору всіх можливих перетинів не\nolinebreak[3] вкладаються у\nolinebreak[3] обмеження\nolinebreak[2] часу.

У даній конкретній задачі краще помітити такі факти: 

\begin{enumerate}
\item
$5000{\*}5000\dib{{=}}25\textnormal{~млн}$\nolinebreak[3] --- дуже багато для людини, але для комп'ютера\nolinebreak[3] --- не\nolinebreak[3] так і багато. Не\nolinebreak[3] лише у\nolinebreak[3] розрізі <<виконати 25~млн\nolinebreak[2] дій>>, а\nolinebreak[3] також і у\nolinebreak[3] розрізі <<тримати в\nolinebreak[3] пам'яті 25~млн\nolinebreak[2] елементів>>.
\item
Хоча один окремо взятий відрізок (ланка ламаної) може мати довжину аж~5000, а\nolinebreak[3] кількість відрізків може сягати мільйона, сумарна довжина відрізків насправді обмежується не\nolinebreak[2] $5000\dib{{\*}}10^6\dib{{=}}{5{\cdot}10^9}$, а\nolinebreak[3] тим, що раз відрізки лише горизонтальні й вертикальні, а\nolinebreak[3] накладання заборонені, то кожна з $5000{\*}5000$ вершин сітки може бути задіяна щонайбільше двічі, тобто сума довжин усіх відрізків не\nolinebreak[3] перевищує\nolinebreak[3] 50~млн. 
\end{enumerate}

\label{text:drawing-by-coords-in-graphics-password-problem}
Завдяки цьому, виявляється допустимим такий простий підхід, як \textsl{<<завести масив $5000{\*}5000$, ініціалізувавши всі елементи нулями; ходити уздовж ліній, збільшуючи на~1 значення у комірках, відповідних пройденим вершинам сітки; відповіддю буде кількість комірок зі значенням~2>>}. Великий time\nolinebreak[2] limit 4~сек потрібен не\nolinebreak[3] для роб\'{о}ти алгоритму, а\nolinebreak[3] для читання величезних вхідних даних. Приклад реалізації такого алгоритма\nolinebreak[3] --- 
\verb"ideone.com/SlR8oV"


{\color{green}\begin{small}

\renewcommand{\baselinestretch}{0.875}

(Повний вміст даного посилання \verb"ideone.com/SlR8oV" такий:
\verbatiminput{SlR8oV.pas}
--- кінець цитати посилання \verb"ideone.com/SlR8oV")

\end{small}}










\contest{Обласна інтернет-олімпіада 2014/15 навч. року}{Черкаська обл.}{15.10.2014}
\renewenvironment{problemAllDefault}[1]{\vspace{10mm}\par\begin{problem}{#1}{Клавіатура (stdin)}{Екран (stdout)}{1 сек}{64 мегабайти}}{\end{problem}}

\subsection{Обласна інтернет-олімпіада 2014/15 н.~р.}

Задачі доступні для дорішування (\verb"ejudge.ckipo.edu.ua", змагання $\No$18).

\vspace{-0.5\baselineskip minus 1cm}
\begin{problemAllDefault}{Три круги}

Є три круги радіусами $R_1$, $R_2$ та $R_3$.

Чи можна перекласти їх так, щоб відразу два менші круги лежали один поруч з іншим на найбільшому, не~накладаючись один на одного і не~звисаючи за його межі? Торкатися один одного менші круги можуть.

\InputFile  Програма повинна прочитати три цілі числа $R_1$, $R_2$ та $R_3$, в один рядок, через пропуски (пробіли). Усі три значення $R_1$, $R_2$ та $R_3$ є цілими числами в межах від 1 до~1000.

\OutputFile Якщо перекласти круги вказаним чином неможливо, програма повинна вивести єдине слово ``\texttt{NO}'' (без лапок).

Якщо можливо, то в єдиному рядку повинно бути записано ``\texttt{YES, the }\dots{}\texttt{ disk is the maximal}'' (без\nolinebreak[3] лапок), де\nolinebreak[3] замість ``\dots'' повинно бути одне з трьох значень:

\begin{itemize}[leftmargin=*,itemsep=0pt,partopsep=0pt,topsep=0pt,parsep=0pt]
\item
``\texttt{1st}'' (без\nolinebreak[3] лапок), якщо 2-й і 3-й круги можна покласти поверх 1-го;
\item
``\texttt{2nd}'' (без\nolinebreak[3] лапок), якщо 1-й і 3-й круги можна покласти поверх 2-го;
\item
``\texttt{3rd}'' (без\nolinebreak[3] лапок), якщо 1-й і 2-й круги можна покласти поверх 3-го.
\end{itemize}

Зверніть увагу: фраза повинна бути однаковою з правильною байт-у-байт, тобто всі великі чи маленькі літери, всі пропуски (пробіли) та інші подібні дрібниці важливі.


\Examples
\begin{exampleSimple}{5em}{16em}%
\exmp{1 2 3}{YES, the 3rd disk is the maximal}%
\exmp{2 3 4}{NO}%
\exmp{9 3 1}{YES, the 1st disk is the maximal}%
\end{exampleSimple}


\end{problemAllDefault}
	

\myflfigaw{\mbox{\raisebox{-30pt}[24pt][0pt]{\begin{mfpic}[6]{0}{10}{-3}{3}
\coords
\rotate{-15}
\circle{(3,0),3}
\circle{(8,0),2}
\circle{(5,0),5}
\endcoords
\end{mfpic}}}}
\Tutorial
Два менші диски, яким заборонено накладатися, займають найменше місця, коли торкаються. 
Тому гранична ситуація, коли при хоч трохи меншому найбільшому диску вони вже звисають, а\nolinebreak[3] при рівно такому або більшому все гаразд, зображена на\nolinebreak[2] рисунку. Наприклад, \mbox{2-й} і \mbox{3-й} круги можна покласти поверх \mbox{1-го} тоді й тільки тоді, коли $R_1\dib{{\>}}R_2\dib{{+}}R_3$. Решта випадків аналогічні.
Щоб правильно виводити\nolinebreak[3] ``\texttt{NO}'', легше не~формулювати умову цього випадку, а\nolinebreak[3] зробити розгалуження вкладеними, щоб виводити\nolinebreak[3] ``\texttt{NO}'', коли не~виконалася жодна з трьох інших умов.
Реалізацію див.\nolinebreak[2] 
\verb"ideone.com/rx2Odn"


{\color{green}\begin{small}

\renewcommand{\baselinestretch}{0.875}

(Повний вміст даного посилання \verb"ideone.com/rx2Odn" такий:
\verbatiminput{rx2Odn.pas}
--- кінець цитати посилання \verb"ideone.com/rx2Odn")

\end{small}}



%%% Приклад програми-розв'язку\nolinebreak[3] --- 
\verb"ideone.com/rx2Odn"


{\color{green}\begin{small}

\renewcommand{\baselinestretch}{0.875}

(Повний вміст даного посилання \verb"ideone.com/rx2Odn" такий:
\verbatiminput{rx2Odn.pas}
--- кінець цитати посилання \verb"ideone.com/rx2Odn")

\end{small}}




Можливий інший підхід\nolinebreak[3] --- спочатку знайти, який з\nolinebreak[3] дисків максимальний, а\nolinebreak[3] вже потім провести одне порівняння. Для даної задачі це погана ідея:\linebreak[1] і\nolinebreak[3] тому, що треба виводити номер максимального диску (ще\nolinebreak[3] й у\nolinebreak[3] вигляді ``1st''/``2nd''/``3rd''), і\nolinebreak[3] тому, що з'ясування, який диск максимальний, займе чи\nolinebreak[3] не\nolinebreak[3] більше дій, ніж розгляд випадків у~попередньому розв'язку. Але для багатьох інших задач \mbox{деякий} аналог др\'{у}гого підходу виявляється набагато кращим за аналіз випадків, аналогічний першому підходу.


\begin{problemAllDefault}{Перевезення вантажу}

Перевізник транспортує вантаж залізницею, а потім річковим транспортом.

Товар транспортується в потязі, який складається з $N$ ($1{\<}N{\<}100$) вагонів в кожному з яких $k_1$~\dots{} $k_N$ ($1{\<}k_i{\<}1000$) коробок вантажу.

У річковому порті вантаж з потягу перевантажують на корабель, який може взяти не більше ніж $P$ ($1{\<}P{\<}10000$) коробок. Якщо якісь коробки не\nolinebreak[3] помістяться на цей корабель, вони дуже довго чекатимуть наступного. Причому чекатимуть обов'язково у тих вагонах, в\nolinebreak[3] яких прибули у~порт.

Для ефективного транспортування диспетчеру необхідно розвантажити якомога більше вагонів, завантаживши корабель, та відправити звільнені вагони на наступне завантаження.

\Task	Напишіть програму \texttt{transport}, яка визначала\nolinebreak[3] б максимальну кількість вагонів, які можна розвантажити, не~перевищуючи вантажопідйомність корабля.

\InputFile  1-й рядок: єдине число $N$ --- кількість вагонів в потязі.

2-й рядок: $k_1$~\dots{} $k_N$ через пропуски (пробіли)\nolinebreak[3] --- кількості коробок у вагонах.

3-й рядок: $P$\nolinebreak[3] --- кількість коробок, яку може взяти на~борт корабель.


\OutputFile Максимальна кількість вагонів потягу, які вдасться розвантажити.


\Example
\begin{exampleSimple}{5em}{3em}%
\exmp{3\par
5 7 3\par
9}{2}%
\end{exampleSimple}

\end{problemAllDefault}
	

\Tutorial	Ця задача, хоч і нескладна, потребує і~з'ясувати правило, за яким слід вибирати вагони, і~написати не~зовсім елементарну програму. 

Тож правило\nolinebreak[3] --- \textsl{<<Щоразу вибирати (ще\nolinebreak[3] не\nolinebreak[3] вибраний) вагон з мінімальною кількістю коробок, доки\nolinebreak[3] не\nolinebreak[3] вичерпається вантажопідйомність корабля або не будуть задіяні всі вагони>>}.

\label{text:proof-example-train-to-ship} %%% міркування про доведень перенесені звідси у FAQ
\emph{Доведемо} (див.\nolinebreak[2] також стор.~\pageref{text:need-or-no-need-to-prove}), що це дасть максимальну кількість вагонів.
\textsl{<<Припустимо, ніби замість вагона з мінімальною кількістю коробок взяли вагон з деякою більшою кількістю. Це\nolinebreak[3] збільшило кількість розвантажених вагонів так\nolinebreak[3] с\'{а}мо\nolinebreak[1] на~1, якби взяли вагон з мінімальною, а\nolinebreak[3] залишок вантажо\-підйом\-ності корабля зменшило сильніше. Отже, ніякого виграшу від того, щоб брати вагон з немімінальною кількістю коробок,\nolinebreak[1] \mbox{нема}>>.} 
Ця\nolinebreak[2] схема доведень типова, тобто її аналоги придатні у багатьох ситуаціях.

% Ні\nolinebreak[3] ці\nolinebreak[2] правила, ні\nolinebreak[3] це
% \nolinebreak[2] доведення не\nolinebreak[2] враховують природне 
% бажання відправити кораблем якомога більше коробок; але це питання 
% більше до умови задачі, чим\nolinebreak[1] до\nolinebreak[2] р\'
% озв'язку. Яку задачу задали, таку й вирішено\dots

Сформульовані правила\nolinebreak[3] --- ще\nolinebreak[2] не\nolinebreak[3] зовсім алгоритм.\linebreak[1] Є\nolinebreak[3] мінімум два способи подальшого їх уточнення (\emph{як\nolinebreak[3] с\'{а}ме \textsl{<<вибирати (ще\nolinebreak[3] не\nolinebreak[3] вибраний) вагон з мінімальною кількістю коробок>>}?}).

Можна застосувати сортування (воно~ж упорядкування), після нього це будуть просто елементи  по\nolinebreak[3] порядку. Особливо зручно, якщо писати мовою, де\nolinebreak[2] є готове бібліотечне сортування (наприклад, у\nolinebreak[2] 
\verb"ideone.com/sElRrj"


{\color{green}\begin{small}

\renewcommand{\baselinestretch}{0.875}

(Повний вміст даного посилання \verb"ideone.com/sElRrj" такий:
\verbatiminput{sElRrj.cpp}
--- кінець цитати посилання \verb"ideone.com/sElRrj")

\end{small}}


 використано функцію \verb"sort" бібліотеки \verb"algorithm" мови\nolinebreak[3] C++). Та й якщо писати сортування самому, все ж є деяка зручність у тому, щоб окремо написати та ретельно вивірити правильність сортування, окремо решту дій.

Можна багатократно проходити по усьому масиву, вибираючи мінімальний елемент, і\nolinebreak[3] після кожного такого проходу враховувати знайдений елемент та заміняти його на якесь велике значення, щоб не~знаходити повторно. Втім, особливих переваг цей спосіб не~має. Зокрема, заявка <<він швидший, бо не~сортує усі елементи, а вибирає лише стільки, скільки треба>> не~витримує критики, бо його складність ${\Theta(N\cdot{}P)}$, тобто, враховуючи\nolinebreak[3] $P{\<}N$, $O(N^2)$. А~складність \emph{ефективних} сортувань $O(N\log{}N)$, що набагато менше.


\begin{problemAllDefault}{Коло і точки}

Є одне коло та $N$\nolinebreak[3] точок. 

\Task	Напишіть програму, яка знаходитиме, скільки з цих $N$\nolinebreak[3] точок потрапили всер\'{е}\-дину цього к\'{о}ла, скільки на\nolinebreak[3] сам\'{е} коло і скільки ззовні к\'{о}ла.


\InputFile  Перші два рядки вхідних даних задають коло. Можуть бути два різні формати його задання:
\begin{enumerate}
\item
Якщо \mbox{1-ий} рядок містить єдине число~1, то\nolinebreak[3] \mbox{2-ий} рядок містить рівно три цілі числ\'{а} $x_C$,\nolinebreak[3] $y_C$,\nolinebreak[2] $R_C$\nolinebreak[3] --- координати центра кола та його радіус.
\item
Якщо \mbox{1-ий} рядок містить єдине число~2, то\nolinebreak[3] \mbox{2-ий} рядок містить рівно шість цілих чисел $x_A$,~$y_A$, $x_B$,~$y_B$, $x_C$,~$y_C$. Їх\nolinebreak[2] слід трактувати як координати трьох точок $A$,\nolinebreak[3] $B$,\nolinebreak[3] $C$, через які проведене коло, котре треба дослідити. Ці\nolinebreak[2] три точки гарантовано всі різні і гарантовано не~лежать на одній прямій. Гарантовано також, що ніяка з цих трьох точок не~збігається ні з одною з точок подальшого переліку з\nolinebreak[3] $N$\nolinebreak[3] точок.
\end{enumerate}

Третій рядок вхідних даних завжди містить єдине ціле число\nolinebreak[3] $N$\nolinebreak[3] --- кількість точок. Подальші $N$ рядків містять по\nolinebreak[2] два цілі числа кожен\nolinebreak[3] --- $x$\nolinebreak[3] та\nolinebreak[1] $y$\nolinebreak[2] координати самих точок.

Абсолютно всі задані у вхідних даних числа є цілими і не\nolinebreak[3] перевищують за абсолютною величиною (модулем)\nolinebreak[3] 1000. При цьому кількість точок і радіус гарантовано додатні, а координати можуть бути довільного знаку.

Скрізь, де в одному й тому ж рядку записано по кілька чисел, вони відділені одне від одного пропусками (пробілами).


\OutputFile Програма повинна вивести три цілі числа\nolinebreak[3] --- спочатку кількість точок всер\'{е}\-дині\nolinebreak[2] к\'{о}ла, потім кількість точок на самому к\'{о}лі, потім кількість точок ззовні к\'{о}ла.

Сума цих трьох чисел повинна дорівнювати~$N$. Зокрема, якщо коло задане \mbox{2-им} способом, то ті три точки, якими воно задане, треба не вважати точками, належними колу.



\Examples
\begin{exampleSimple}{7em}{3em}%
\exmp{1
-1 2 5
4
0 0
-3 -3
-6 2
6 -2}{1 1 2}%
\end{exampleSimple}
\begin{exampleSimple}{7em}{3em}%
\exmp{2
-1 -3 2 6 3 5
4
0 0
-3 -3
-6 2
6 -2}{1 1 2}%
\end{exampleSimple}

\Notes
В обох наведених прикладах задане (різними способами) одне й те само коло, тому що коло, проведене через точки $(-1; -3)$, $(2; 6)$ та $(3; 5)$ якраз і має радіус~5 та центр у\nolinebreak[3] точці\nolinebreak[3] $(-1; 2)$.

Перша одиничка відповіді виражає, що лише одна точка з переліку потрапила всер\'{е}\-дину кола (і\nolinebreak[3] це точка\nolinebreak[3] $(0; 0)$, але цього не~питають). Друга одиничка відповіді виражає, що лише одна точка з переліку потрапила на\nolinebreak[3] сам\'{е} коло (і\nolinebreak[3] це точка\nolinebreak[3] $(-6; 2)$, але цього не~питають). Число~2 у~відповіді позначає, що решта дві точки переліку (це\nolinebreak[3] точки $(-3; -3)$ та\nolinebreak[3] $(6; -2)$, але цього не~питають) потрапили ззовні кола.

Можна здавати програму, яка враховує лише подання кола через координати центра і радіус. На\nolinebreak[3] тести, в\nolinebreak[3] яких коло подається \mbox{1-им}\nolinebreak[3] способом, припадатиме майже половина балів, і така програма може їх отримати. Але навіть така програма повинна враховувати, що в цих тестах все одно буде \mbox{1-ий}\nolinebreak[3] рядок з єдиним числом~1.

Разом з тим, якщо враховувати обидва випадки, це все одно повинна бути одна програма.

\end{problemAllDefault}
	

\Tutorial	Коло --- множина точок, рівновіддалених від центру, тож досліджувана точка потрапляє всер\'{е}дину к\'{о}ла, коли відстань між нею і центром кола менша за радіус, на сам\'{е} коло --- коли рівна, і\nolinebreak[3] назовні, коли більша. Ця відстань рівна $\sqrt{(x_i-x_C)^2+(y_i-y_C)^2}$ (де\nolinebreak[3] $(x_i; y_i)$\nolinebreak[3] --- координати досліджуваної точки, $(x_C; y_C)$\nolinebreak[3] --- центру к\'{о}ла). Тож (для програми, що працює \emph{лише для \mbox{1-го}} способу подання к\'{о}ла) лишається тільки написати цикл з\nolinebreak[3] вкладеними розгалуженнями на три випадки. При бажанні, можна позбутися похибок (див.\nolinebreak[3] стор.~\pageref{sec:floating-point}--\nolinebreak[3]\pageref{text:floating-point-end}), прибравши корені, тобто порівнювати ${(x_i-x_C)^2}\dib{{+}}{(y_i-y_C)^2}$ з~$R^2$. Остаточна реалізація\nolinebreak[3] --- 
\verb"ideone.com/k9iLan"


{\color{green}\begin{small}

\renewcommand{\baselinestretch}{0.875}

(Повний вміст даного посилання \verb"ideone.com/k9iLan" такий:
\verbatiminput{k9iLan.pas}
--- кінець цитати посилання \verb"ideone.com/k9iLan")

\end{small}}




Розібратися, що робити з \mbox{2-им} способом подання к\'{о}ла\nolinebreak[3] --- \emph{значно} складніше, можливо навіть складніше усієї решти 
${2\lefteqn{{}^{1}}{}^{\,}\lefteqn{/}{}_{\,\,\,2}}$\nolinebreak[3] задач даного туру. Можна звести \mbox{2-ий} випадок до \mbox{1-го}, тобто перейти від трьох точок до центру й радіусу проведеного через ці три точки к\'{о}ла, та використати вже розглянутий розв'язок.

Один зі\nolinebreak[3] способів\nolinebreak[3] --- будувати перетин серединних перпендикулярів двох сторін $\triangle{}ABC$, тобто ті~ж дії, що й на\nolinebreak[3] уроці геометрії, але виконані замість циркуля і лінійки засобами \emph{обчислювальної геометрії} (\emph{вычислительная геометрия}, \emph{computational geometry}). Вступ до обч.~геометрії можна знайти у\nolinebreak[3] багатьох місцях, зокрема \verb"https://goo.gl/6yppjy"\hspace{0.5em plus 1em} Програма, що розв'язує цим способом\nolinebreak[3] --- 
\verb"ideone.com/k1aFcF"


{\color{green}\begin{small}

\renewcommand{\baselinestretch}{0.875}

(Повний вміст даного посилання \verb"ideone.com/k1aFcF" такий:
\verbatiminput{k1aFcF.cpp}
--- кінець цитати посилання \verb"ideone.com/k1aFcF")

\end{small}}


 (але звідти свідомо прибрані допоміжні функції, пояснені за попереднім посиланням).

Інший спосіб\nolinebreak[3] --- вивести на\nolinebreak[3] папері прямі формули, розв'язавши систему
$\left\{
\begin{array}{c}
(x{-}x_A)^2+(y{-}y_A)^2 = (x{-}x_B)^2+(y{-}y_B)^2,\\
(x{-}x_A)^2+(y{-}y_A)^2 = (x{-}x_C)^2+(y{-}y_C)^2,
\end{array}
\right.$
де $x_A$,~$y_A$, $x_B$,~$y_B$, $x_C$,~$y_C$\nolinebreak[3] --- коор\-ди\-нати заданих точок (до\nolinebreak[3] них треба ставитися як до\nolinebreak[3] відомих значень, а\nolinebreak[3] не\nolinebreak[3] змінних), а\nolinebreak[3] $x$\nolinebreak[1] та\nolinebreak[3] $y$\nolinebreak[3] --- координати центра к\'{о}ла,\linebreak[1] їх-то\nolinebreak[1] й шукаємо. Розв'язати цю систему легше, ніж може здатися, бо після перетворень, аналогічних ${(x{-}x_A)^2}\dib{{=}}x^2\dib{{-}}2x_A{\cdot}x\dib{{+}}{x_A}^2$, можна позводити $x^2$ та~$y^2$, і\nolinebreak[3] рівняння стають лінійними відносно $x$ та~$y$ (що логічно, бо це серединні перпендикуляри).

\myflfigaw{$\left|\begin{array}{cccc}
x_A	& y_A	& x_A^2+y_A^2	&	1	\\
x_B	& y_B	& x_B^2+y_B^2	&	1	\\
x_C	& y_C	& x_C^2+y_C^2	&	1	\\
x_i	& y_i	& x_i^2+y_i^2	&	1	\\
\end{array}\right|$}
Можна й не виражати \mbox{2-ий} випадок через \mbox{1-ий}. Виявляється, відповідь на задачу можна взнавати за знаком наведеного праворуч детермінанта. (\emph{Детермінант}, він\nolinebreak[3] же \emph{визначник}\nolinebreak[3] --- стандартний термін теорії матриць. Як\nolinebreak[3] взагалі обчислювати детермінант та чому даний детермінант має таку властивість, бажаючі можуть знайти в\nolinebreak[3] Інтернеті або літературі самостійно.) Так\nolinebreak[3] от: 0\nolinebreak[3] означає, що ${(x_i;y_i)}$ лежить на к\'{о}лі, проведеному через ${(x_A;y_A)}$, ${(x_B;y_B)}$, ${(x_C;y_C)}$; додатне значення детермінанта\nolinebreak[3] --- що всер\'{е}дині; від'ємне\nolinebreak[3] --- ззовні. Тільки це якщо обхід $\triangle{}ABC$ (с\'{а}ме у\nolinebreak[3] порядку $A$, $B$,~$C$) відбувається у\nolinebreak[3] додатному напрямку (проти годинникової стрілки), а\nolinebreak[3] при зміні напрямку обходу $\triangle{}ABC$ слід обміняти місцями смисл додатного і від'ємного знаків детермінанту. Факт зовсім не очевидний, але ж це \emph{лише один із}\nolinebreak[3] способів розв'язання задачі\dots






\addtocontents{toc}{\protect\pagebreak\par}

\contest{ІІ (районний/міський) етап 2014/15 навч. року}{Черкаська обл.}{23.11.2014}
\renewenvironment{problemAllDefault}[1]{\vspace{10mm}\par\begin{problem}{#1}{\stdinOrInputTxt}{\stdoutOrOutputTxt}{1 сек}{64 мегабайти}}{\end{problem}}

\subsection{ІІ (районний/міський) етап 2014/15 н.~р.}

Задачі доступні для дорішування (\verb"ejudge.ckipo.edu.ua", змагання $\No$46).

В\nolinebreak[3] усіх задачах даного змагання, програма може читати вхідні дані хоч з клавіатури, хоч зі вхідного файлу \verb"input.txt" (але\nolinebreak[2] лише з чогось одного, а\nolinebreak[3] не\nolinebreak[2] поперемінно). Аналогічно, програма може виводити результати хоч на\nolinebreak[3] екран, хоч у вихідний текстовий файл\nolinebreak[2] \verb"output.txt" (теж лише на/у щось одне).


\vspace{-0.5\baselineskip minus 1cm}
\begin{problemAllDefault}{Цифра}

В заданому додатному числі потрібно закреслити одну цифру так, щоб число, яке залишиться в результаті, було найбільшим.

Напишіть програму, яка читає одне ціле значення $n$ ($10{\<}n{\<}99999$), і виводить число без однієї цифри (це число має бути найбільшим серед усіх можливих варіантів закреслень цифри).

\Examples
\begin{exampleSimple}{3em}{3em}%
\exmp{321}{32}%
\exmp{129}{29}%
\end{exampleSimple}

\end{problemAllDefault}
	

\Tutorial	{
\hyphenpenalty=400
Діяти за принципом \textsl{<<Викреслювати мінімальну цифру>>}\nolinebreak[3] --- \emph{неправильно} (всупереч підступним пр\'{и}\-кла\-дам з~умови, які провокують таку хибну думку.) Наприклад, із\nolinebreak[2] числ\'{а}\nolinebreak[3] 9891 треба викреслити~8 і отримати~991, а\nolinebreak[3] викреслення мінімальної цифри~1 дасть не~максимальне~989.

}

Оскільки розміри малі (кількість цифр~$\<5$, видаляється одна), найпростіший правильний розв’язок\nolinebreak[3] --- перебрати всі варіанти викреслення однієї цифри (усе число без\nolinebreak[3] \mbox{1-ої}, усе без\nolinebreak[3] \mbox{2-ої}, тощо), і~вибрати з~них максимальний. Зручно (хоча й не~обов'язково) перевести число у\nolinebreak[3] рядок (\verb"string"), і~займатися вилученням символів у\nolinebreak[3] рядковому поданні. Реалізацію див. 
\verb"ideone.com/jFBIM6"


{\color{green}\begin{small}

\renewcommand{\baselinestretch}{0.875}

(Повний вміст даного посилання \verb"ideone.com/jFBIM6" такий:
\verbatiminput{jFBIM6.pas}
--- кінець цитати посилання \verb"ideone.com/jFBIM6")

\end{small}}


\hspace{0.5em plus 1em}
При бажанні, її можна спростити, роблячи взагалі все виключно рядками. (Взагалі буває проблема <<у~числах ${7{<}10}$, а\nolinebreak[3] у\nolinebreak[3] рядках \verb|"7"|$\dib{{>}}$\verb|"10"|>>, але \emph{тут} вона не~проявиться, бо кількості цифр усіх потрібних чисел однакові.)

Ще є правильний розв’язок \textsl{<<Знайти найлівіше місце, де зразу після меншої цифри йде більша, і викреслити меншу с\'{а}ме з\nolinebreak[2] цих двох; якщо жодного такого місця нема (наприклад, у\nolinebreak[3] числі\nolinebreak[2] 97752) --- викреслити останню цифру>>}.

Якщо мати лише мету розв'язати дану задачу при даних обмеженнях\nolinebreak[3] --- краще обмежитися першим правильним способом і не\nolinebreak[3] читати далі. А\nolinebreak[3] якщо мати бажання ще\nolinebreak[2] раз розглянути, як можна доводити правильність алгоритма (див.\nolinebreak[3] також стор.~\pageref{text:need-or-no-need-to-prove})\nolinebreak[3] --- тоді подальший текст важливий. 

\label{text:proof-max-num-by-strike-out-one-digit}
Занумеруємо цифри початкового числ\'{а} зліва направо $\overline{a_1a_2\dots{}a_n}$.
Розглянемо спочатку випадок <<нема жодного місця, щоб після меншої цифри йшла більша>>, тобто $a_1\dib{{\>}}a_2\dib{{\>}}\dots\dib{{\>}}a_n$. Згідно алгоритму, треба викреслити~$a_n$, лишивши $\overline{a_1a_2\dots{}a_{n-1}}$. Якщо всупереч алгоритму викреслити деяку~$a_j$ ($1{\<}j{<}n$), вийде $\overline{a_1a_2\dots{}a_{j-1}a_{j+1}\dots{}a_{n}}$, тобто початок $\overline{a_1a_2\dots{}a_{j-1}}$ (при $j{=}1$ порожній, але це несуттєво) спільний, а\nolinebreak[3] далі:\linebreak[1]
$a_{j+1}$\nolinebreak[1] замість\nolinebreak[3] $a_j$;\linebreak[1] 
$a_{j+2}$\nolinebreak[1] замість\nolinebreak[3] $a_{j+1}$;
\dots;\linebreak[1]
$a_{n}$\nolinebreak[1] замість\nolinebreak[3] $a_{n-1}$.
Розглядаємо ситуацію $a_1\dib{{\>}}a_2\dib{{\>}}\dots\dib{{\>}}a_n$, тож або $a_j\dib{{>}}a_{j+1}$, або $a_j\dib{{=}}a_{j+1}$. При $a_j\dib{{>}}a_{j+1}$, число, отримане всупереч алгоритму, строго менше отриманого згідно алгоритму, бо початок $\overline{a_1a_2\dots{}a_{j-1}}$ спільний, далі $a_{j+1}\dib{{<}}a_j$. Якщо ж $a_j\dib{{=}}a_{j+1}$, то можна говорити про спільний початок $\overline{a_1a_2\dots{}a_{j-1}a_j}$ і повторити \emph{всі} міркування для <<$a_{j+2}$\nolinebreak[1] замість\nolinebreak[3] $a_{j+1}$>>. І\nolinebreak[3] так\nolinebreak[2] далі. Кінець кінцем, або десь отримаємо, що <<число всупереч алгоритму>> менше (гірше) за <<число згідно алгоритму>>, або дійдемо до $a_j\dib{{=}}a_{j+1}\dib{{=}}\dots\dib{{=}}a_n$, тобто викреслення~$a_j$ призводить до \emph{того~ж} результату, що викреслення~$a_n$.

Лишилося розглянути випадок, коли місце, де\nolinebreak[3] $a_i{<}a_{i+1}$, існує. Нехай $i^{\star}$\nolinebreak[3] --- найлівіша з таких позицій, тобто $a_1\dib{{\>}}a_2\dib{{\>}}\dots\dib{{\>}}a_{i^{\star}}$ і $(a_i^{\star}{<}a_{i^{\star}+1})$. Невигідність видаляти замість~$a_{i^{\star}}$ деяку $a_j$ при $1{\<}j{<}i^{\star}$ доводиться аналогічно міркуванням попереднього абзацу. Лишилося довести невигідність видаляти $a_j$ при $i^{\star}{<}j{\<}n$, а це зовсім легко: згідно алгоритму отримуємо $\overline{a_1a_2\dots{}a_{i^{\star}-1}a_{i^{\star}+1}\dots{}a_{n}}$, всупереч\nolinebreak[3] --- $\overline{a_1a_2\dots{}a_{i^{\star}-1}a_{i^{\star}}\dots{}a_{j-1}a_{j+1}\dots{}a_{n}}$, тобто початок $\overline{a_1a_2\dots{}a_{i^{\star}-1}}$ спільний, потім ${a_{i^{\star}+1} > a_i^{\star}}$. Розглянуті випадки покрили всі можливі ситуації, доведення успішно завершене.

\myhrulefill

Чи має другий алгоритм переваги над першим? При заданих обмеженнях ${n{\<}99999}$\nolinebreak[3] --- ні. Але \emph{якби} числа могли бути значно більшими (наприклад, до мільйона цифр; не~<<$n{=}1000000$>>, це число з 7~цифр, а якби \emph{кількість цифр} могла сягати мільйона)\nolinebreak[3] --- тоді виявилося\nolinebreak[3] б, що перший алгоритм хоча теоретично правильний, але неадекватно повільний, а др\'{у}гий вкладається у розумні обмеження. Асимптотичні оцінки: $\Theta(L^2)$ для першого, $\Theta(L)$ для др\'{у}гого, де $L$\nolinebreak[3] --- кількість цифр.



\begin{problemAllDefault}{Піраміда}

Гіллу Бейтсу захотілося увічнити пам'ять про свою корпорацію MegaHard. Він обрав перевірений часом метод --- побудувати піраміду.

Піраміда має висоту $n$ Стандартних Будівельних Блоків, і кожен її рівень\nolinebreak[3] --- квадрат $k{\*}k$ блоків, де\nolinebreak[3] $k$\nolinebreak[3] --- номер рівня, рахуючи згори. З'ясувалося, що фірма, що виготовляє Стандартні Будівельні Блоки, продає їх лише партіями по~$m$~штук.

{\hyphenpenalty=400

Потрібно написати програму, що визначатиме, скільки блоків залишиться не\nolinebreak[3] використаними після побудови піраміди (Гілл Бейтс забезпечить закупівлю мінімально необхідної для побудови піраміди кількості партій).

Напишіть програму, яка читає в один рядок через пропуск (пробіл) спочатку кількість бажаних рівнів піраміди $n$ ($1{\<}n{\<}10^9$, тобто мільярд), потім розмір партії Стандартних Будівельних Блоків $m$ ($1{\<}m{\<}10^6$, тобто мільйон), і виводить єдине ціле число --- кількість Блоків, що\nolinebreak[3] залишаться не\nolinebreak[3] використаними, якщо купити найменшу можливу кількість цілих партій.

}

\Example
\begin{exampleSimple}{4em}{4em}%
\exmp{7 16}{4}%
\end{exampleSimple}

\Note
Піраміда з 7 рівнів міститиме % $1^2\dib{{+}}2^2\dib{{+}}3^2\dib{{+}}4^2\dib{{+}}5^2\dib{{+}}6^2\dib{{+}}7^2\dib{{=}}140$ 
$1^2{+}2^2{+}3^2{+}4^2{+}5^2{+}6^2{+}7^2\dib{{=}}140$
блоків, і\nolinebreak[3] якщо купити 8~партій по\nolinebreak[3] 16~блоків, то цих 128~блоків не~вистачить; тому треба купити 9~партій по\nolinebreak[3] 16~блоків, тоді з\nolinebreak[3] цих 144~блоків 4 залишаться зайвими.


\end{problemAllDefault}
	

\Tutorial
Ця задача проста, щоб набрати \emph{частину} балів, але набрати повний бал чи значну частину балів не~так~просто. Розв'язок 
\verb"ideone.com/w8Yu4L"


{\color{green}\begin{small}

\renewcommand{\baselinestretch}{0.875}

(Повний вміст даного посилання \verb"ideone.com/w8Yu4L" такий:
\verbatiminput{w8Yu4L.pas}
--- кінець цитати посилання \verb"ideone.com/w8Yu4L")

\end{small}}


 набирає половину балів. 
І~тут є\nolinebreak[2] де помил\'{и}тися й отримати ще\nolinebreak[3] менше\nolinebreak[3] (важливо і\nolinebreak[3] правильно врахувати смисл~$m$, і\nolinebreak[3] взяти тип \texttt{int64}).

При $n$, починаючи з${}\approx3{\cdot}10^6$, сума $1^2\dib{{+}}2^2\dib{{+}}\dots\dib{{+}}n^2$ виходить навіть за межі 64-\nolinebreak[1]бітового типу. З~цим можна боротися, застосовуючи найпростіший прийом \emph{модульної арифметики}: робити додавання\nolinebreak[3] $i^2$ не~як\nolinebreak[3] \verb"s:=s+sqr(int64(i))", а\nolinebreak[2] як\nolinebreak[3] \verb"s:=(s+sqr(int64(i)))mod m". 
Реалізація з вчасними <<\texttt{\dots~mod~m}>>, набирає 150 балів (з~250). 
Тепер критичним стає те, що $\approx{}10^9$ ітерацій циклу (ще\nolinebreak[3] й з\nolinebreak[2] громіздкою операцією \texttt{mod}) не~поміщаються в обмеження часу (1~сек).

\MyParagraph{100\%-ий спосіб $\No\,$1} 
Якщо знати (або вивести під час туру) формулу $1^2\dib{{+}}2^2\dib{{+}}\dots\dib{{+}}n^2\dib{{=}}\frac{n(n+1)(2n+1)}{6}$, можна поєднати її з засобами модульної арифметики й отримати зовсім інший розв'язок 
\verb"ideone.com/g6nSKa"


{\color{green}\begin{small}

\renewcommand{\baselinestretch}{0.875}

(Повний вміст даного посилання \verb"ideone.com/g6nSKa" такий:
\verbatiminput{g6nSKa.pas}
--- кінець цитати посилання \verb"ideone.com/g6nSKa")

\end{small}}


\hspace{0.5em plus 1em} Він взагалі не~містить циклів (складність $\Theta(1)$), тож працює миттєво.

Щоб написати цей розв'язок, треба знати деякі математичні факти та властивості, і це може не~всім подобатися. Але, по-перше, задача має альтернативний розв'язок; по-друге, навіть якби цей розв'язок був єдиним, це не~суперечило~б традиціям Всеукраїнської олімпіади з~інформатики.

У~цьому розв'язку треба писати с\'{а}ме ``\texttt{\dots\nolinebreak[3] mod\nolinebreak[3] \mbox{(6*m)}}'' (а\nolinebreak[2] не\nolinebreak[3] ``\texttt{\dots\nolinebreak[3] mod~m}''), бо такі властивості модульної арифметики: хоча ${(a+b)\bmod p} \dib{{=}} {\bigl((a\bmod p)}\dib{{+}}{(b\bmod p)\bigr)\bmod p}$ --- правильна для всіх $a$, $b$, $p$ тотожність, і так само для множення, але для ділення виявляється не~так. Детальніші відомості про модульну арифметику просимо знайти в Інтернеті або літературі самостійно.

Щодо того, як можна вивести формулу $1^2\dib{{+}}2^2\dib{{+}}\dots\dib{{+}}n^2\dib{{=}}\frac{n(n+1)(2n+1)}{6}$ самому під час туру --- див., наприклад, \verb"http://dxdy.ru/topic22151.html"\hspace{0.5em plus 1em} Звісно, доцільність витрачання часу туру на подібні виведення формул істотно залежить від умінь конкретного учасника, та від того, чи\nolinebreak[3] має місце ситуація, коли учасник знає, що така формула в~принципі існує, але не~пам'ятає її точно.


\MyParagraph{100\%-ий спосіб $\No\,$2}
Навіть не~знаючи ні\nolinebreak[2] формули зі способу\nolinebreak[3] $\No\,1$, ні\nolinebreak[2] модульної арифметики, можна побудувати інший повнобальний розв'язок, користуючись лише базовими, в~межах загальнообов'язкового мінімуму, знаннями математики, а~також спостережливістю та кмітливістю.

Якщо $n < 2{\cdot}10^6$, можна порахувати відповідь <<в~лоб>>, як на початку розбору.

Інакше (враховуючи, що ${m\<10^6}$, $n \> 2{\cdot}10^6$) вийде, що проміжок від~1 до~$n$ складається з кількох (як\nolinebreak[3] мінімум, двох, як\nolinebreak[3] максимум ---  сотень мільйонів) проміжків від\nolinebreak[2] 1\nolinebreak[2] до~$m$, від\nolinebreak[2] ${m{+}1}$\nolinebreak[2] до~$2m$, від\nolinebreak[2] ${2m{+}1}$\nolinebreak[2] до~$3m$, і~т.~д.

\vspace{0.375\baselineskip}

% % % \mytextandpicture{Розглянемо (праворуч) послідовність очевидних 
% % % тотожностей для проміжків від\nolinebreak[2] 1\nolinebreak[2] до~$m$ та від
% % % \nolinebreak[2] ${m{+}1}$\nolinebreak[2] до~$2m$. У~виразі ${m^2{+}2m{+}1}$
 % % % частина ${m^2{+}2m}$ кратна~$m$ і тому не~впливає на\nolinebreak[3] остат
% % % \'{о}чну відповідь задачі.}{\begin{tabular}{r@{}c@{}l|rcl}
% % % $1^2$ & $=$ & 1	& $(m{+}1)^2$ & $=$ & $m^2+2m+1$ \\
% % % $2^2$ & $=$ & 4	& $(m{+}2)^2$ & $=$ & $m^2+4m+4$ \\
% % % $3^2$ & $=$ & 9	& $(m{+}3)^2$ & $=$ & $m^2+6m+9$ \\
 % % % & $\vdots$ & & & $\vdots$\\
% % % $m^2$ &$=$&$m^2$& $(m{+}m)^2$ & $=$ & $m^2+2m^2+m^2$ 
% % % \end{tabular}}

\myflfigaw{\begin{tabular}{r@{}c@{}l|rcl}
$1^2$ & $=$ & 1	& $(m{+}1)^2$ & $=$ & $m^2+2m+1$ \\
$2^2$ & $=$ & 4	& $(m{+}2)^2$ & $=$ & $m^2+4m+4$ \\
$3^2$ & $=$ & 9	& $(m{+}3)^2$ & $=$ & $m^2+6m+9$ \\
 & $\vdots$ & & & $\vdots$\\
$m^2$ &$=$&$m^2$& $(m{+}m)^2$ & $=$ & $m^2+2m^2+m^2$ 
\end{tabular}}
Розглянемо (праворуч) очевидні тотожності, на проміжках від\nolinebreak[2] 1\nolinebreak[2] до~$m$ та від\nolinebreak[2] ${m{+}1}$\nolinebreak[2] до~$2m$. Помітимо, що сума ${m^2{+}2m}$ кратна~$m$ і тому не~впливає на\nolinebreak[3] остат\'{о}чну відповідь задачі.
Аналогічно не~впливають  ${m^2{+}4m}$,  ${m^2{+}6m}$, і~т.~д. Тобто, 
${(m{+}1)^2\bmod m}\dib{{=}}{1^2\bmod m}$,
${(m{+}2)^2\bmod m}\dib{{=}}{2^2\bmod m}$,
${(m{+}3)^2\bmod m}\dib{{=}}{3^2\bmod m}$,\nolinebreak[3] \dots, 
а\nolinebreak[2] звідси\nolinebreak[3] --- сума усього др\'{у}гого проміжку $(m{+}1)^2\dib{{+}}(m{+}2)^2\dib{{+}}\dots\dib{{+}}(m{+}m)^2$ має той самий залишок від ділення на~$m$, що й сума усього першого $1^2\dib{{+}}2^2\dib{{+}}\dots\dib{{+}}m^2$.

З~аналогічних причин, такий самий залишок % від ділення на~$m$ 
мають і сума усього третього проміжку $(2m{+}1)^2\dib{{+}}(2m{+}2)^2\dib{{+}}\dots\dib{{+}}(2m{+}m)^2$, і сума будь-якого подальшого. Тому досить цей однаковий для всіх проміжків залишок домножити на ${n\bdiv m}$, а\nolinebreak[3] потім, якщо % $n\bmod m\neq0$, 
$n$\nolinebreak[2] не\nolinebreak[3] кратне\nolinebreak[3] $m$, окремо порахувати й додати шматочок від ${(n\bdiv m){\cdot}m}\dib{{+}}1$ до~$n$ (або від\nolinebreak[2] 1\nolinebreak[2] до~$n\bmod m$). 

Отже, сумарна кількість ітерацій усіх циклів не\nolinebreak[3] перевищить $m\dib{{+}}(n\bmod m)\dib{{<}}2m\dib{{\<}}{2{\cdot}10^6}$. Це\nolinebreak[3] довше, ніж $\Theta(1)$ зі <<способу\nolinebreak[3] $\No\,1$>>, але теж вкладається у\nolinebreak[2] 1~сек. Щоправда, якби обмеження було не\nolinebreak[3] ${m{\<}10^6}$, а\nolinebreak[2] ${m{\<}10^9}$, цей розв'язок став~би неможливим (а~<<спосіб\nolinebreak[3] $\No\,1$>> лишився~б можливим).



\begin{problemAllDefault}{Ко-анаграмічно-прості}

Число називається \emph{простим}, якщо воно має рівно два різні дільники\nolinebreak[3] --- себе і одиницю. Наприклад: 23\nolinebreak[3] --- просте число, а\nolinebreak[3] 35 не~просте, бо $5{\*}7\dib{{=}}35$. Число~1 теж не~просте (лише один дільник).

Якщо у числі змінити порядок цифр, властивість простоти може змінитися: наприклад, 35 --- не~просте число, а\nolinebreak[3] 53\nolinebreak[3] --- просте.

Будемо називати число \emph{ко-анаграмічно-простим}, коли при хоча\nolinebreak[3] б одному можливому порядку цифр утворюється просте число. Наприклад, 35 є ко-анаграмічно-простим (бо\nolinebreak[3] 53\nolinebreak[3] просте), а\nolinebreak[2] 225\nolinebreak[3] --- не~є, бо жодне з чисел 225, 252 та 522 не~є~простим.

Напишіть програму, яка читає одне ціле додатне значення $n$ ($10{\<}n{\<}9999$) і виводить у першому рядку мінімальне можливе ко-анаграмічно-просте число, більше-рівне за~$n$, а~у~др\'{у}гому рядку --- ту перестановку цифр, яка робить його простим. Якщо при перестановці з’являються нулі спереду числа --- слід вважати, що вони не~впливають на значення числа (05 дорівнює~5), але виводити слід обов’язково із цими нулями (якщо правильно~05, то вивести 5 неправильно). Разом з тим, перше число відповіді починати з нуля не~можна.

Якщо можливі різні правильні відповіді --- виводьте будь-яку одну з них.

\Examples
\begin{exampleSimple}{4em}{4em}%
\exmp{35}{35
53}%
\exmp{49}{50
05}%
\exmp{225}{227
227}%
\end{exampleSimple}

\end{problemAllDefault}
	

\Tutorial	У цій задачі треба акуратно писати відносно велику, як для II етапу, програму, поєднуючи застосування різних стандартних алгоритмів. Але, не~зважаючи на страшну назву <<ко-ана\-гра\-мічно>> та інші громіздкості, тут\nolinebreak[2] не\nolinebreak[3] дуже-то й треба самому придумувати щось математичне. Якщо, звісно:

\begin{itemize}[leftmargin=*,itemsep=0pt,partopsep=0pt,topsep=0pt,parsep=0pt]

\item
знати стандартний алгоритм перевірки простоти числ\'{а};

\item
вміти \emph{або перевіряти, чи}\nolinebreak[2] ч\'{и}сла складаються з одних і тих с\'{а}мих цифр, \emph{або генерувати перестановки} послідовності\nolinebreak[3] цифр.

\end{itemize}

Cтандартний алгоритм перевірки простоти числ\'{а}~$n$ (при\nolinebreak[2] $n\>2$)\nolinebreak[3] --- пробувати ділити його на\nolinebreak[3] 2,\nolinebreak[2] 3,\nolinebreak[3] \dots, \verb"round"$(\sqrt{n})$, і\nolinebreak[3] якщо хоча~б раз поділилося без остачі\nolinebreak[3] --- число скл\'{а}дене, якщо не\nolinebreak[3] поділилося ні~разу\nolinebreak[3] --- просте. Важливо перевіряти до\nolinebreak[2] кореня (а\nolinebreak[3] не\nolinebreak[2] до\nolinebreak[3] $n$ чи\nolinebreak[2] $n/2$), бо це набагато менше (див.\nolinebreak[2] також стор.~\pageref{text:about-sqrt-n-in-divisors-list}).

Перевіряти, чи ч\'{и}сла складаються з одних і тих самих цифр у різному порядку, можна по-різному. Один з простих і зручних підходів\nolinebreak[3] --- відсортувати (наприклад, за\nolinebreak[3] неспаданням) цифри окремо одного з~них, окремо іншого, й порівняти отримані відсортовані послідовності (вони рівні тоді й тільки тоді, коли ч\'{и}сла складаються з одних і тих самих цифр). Оскільки кількість цифр дуже маленька, нема смислу використовувати quickSort чи подібні ефективні сортування, доречніші вставки або навіть простесенька бульбашка.

Таким чином, алгоритм може бути приблизно таким. 
Функція (підпрограма) <<перевірити, чи~є число ко-анаграмічно-простим>> має вигляд:

\begin{enumerate}
\item
створимо копію цього числа у рядковому (\texttt{string}-овому) вигляді;
\item
відсортуємо цифри (символи рядка) за неспаданням;
\item
переберемо усі числа з відповідною кількістю цифр, від 0\dots01 до 9\dots99, і для кожного з них:
\begin{enumerate}
\item
перетворимо у рядок (знову як копію, щоб не псувати оригінал);
\item
теж відсортуємо цифри числ\'{а} за неспаданням;
\item \label{item:201415-2-d-both-tests}
якщо відсортовані послідовності виявилися різними --- значить, поточне число не є перестановкою цифр досліджуваного і його слід пропустити, а якщо однаковими --- запустити перевірку поточного числа на простоту.
\end{enumerate}
Якщо перевірка у п.~\ref{item:201415-2-d-both-tests} хоча~б один раз виявила, що число просте\nolinebreak[3] --- функція в цілому має повернути результат <<число є ко-ана\-гра\-мічно-простим>>. Якщо жодного разу не~виявила\nolinebreak[3] --- результат <<не~є>>.
\end{enumerate}

Тепер лишається тільки перевіряти, чи\nolinebreak[3] є ко-ана\-гра\-мічно-простим сам\'{е} введене число~$n$, потім $n{+}1$, $n{+}2$,~\dots{} Приклад реалізації\nolinebreak[3] --- 
\verb"ideone.com/mGI9hm"


{\color{green}\begin{small}

\renewcommand{\baselinestretch}{0.875}

(Повний вміст даного посилання \verb"ideone.com/mGI9hm" такий:
\verbatiminput{mGI9hm.pas}
--- кінець цитати посилання \verb"ideone.com/mGI9hm")

\end{small}}




Для цієї реалізації дуже складно і\nolinebreak[3] вивести асимптотичну оцінку часу роботи, і\nolinebreak[3] використати цю асимптотику для оцінювання конкретного часу роботи в\nolinebreak[3] мілісекундах. Наприклад, зовсім не\nolinebreak[3] ясно, як оцінити кількість ітерацій самого зовнішнього циклу (скільки чисел $n$, $n{+}1$,~\dots{} треба перебрати, щоб гарантовано знайти ко-ана\-гра\-мічно-просте). У\nolinebreak[3] перевірці простот\'{и}, хоч і видно верхню межу циклу \verb"round(sqrt(n))", але ж розумна реалізація обриває цикл після першого знайденого дільника, і середня кількість ітерацій виявляється меншою (а\nolinebreak[3] наскільки\nolinebreak[3] --- не\nolinebreak[3] ясно); і так далі.

Програма може працювати швидше, якщо, замість перебору всіх чисел з відповідною кількістю цифр (від 0\dots01 до 9\dots99), відразу генерувати лише ті, що складаються з потрібних цифр, і перевіряти на простоту лише\nolinebreak[3] їх. При обмеженні $n\<9999$ це насправді неважливо, тож утримаємося від опису, як робити це вручну; бажаючі можуть знайти за назвою \emph{генерація перестановок} (\emph{generate permutations}). У\nolinebreak[3] мові\nolinebreak[2] C++, така генерація є готова (функція \verb"next_permutation" бібліотеки \verb"algorithm").



\vspace{10mm}\par
\begin{problem}{Хмарочоси}{\stdinOrInputTxt}{\stdoutOrOutputTxt}{2 сек}{64 мегабайти}

Як~відомо, місто Прямий\nolinebreak[2] Ріг являє собою одну пряму вулицю, уздовж якої прокладена координатна вісь~$Ox$. Останнім часом у~місті розгорнувся будівельний бум, внаслідок якого ПрямМіськБуд звів $N$\nolinebreak[3] хмарочосів. Кожен хмарочос можна охарактеризувати висотою $h_i$ та координатою $x_i$ (усі $x_i$ різні, усі $h_i$ строго додатні).

За задумами мерії Прямого\nolinebreak[2] Рогу, настав час обладнати на дахах деяких із хмарочосів оглядові майданчики. Прибутковість такого майданчику залежить від того, скільки з даху даного хмарочосу видно інших хмарочосів. Тому Вас попросили написати програму, яка підготує відповідну статистику. Дані про хмарочоси зберігаються у\nolinebreak[3] мерії в\nolinebreak[3] порядку зростання~$x_i$, тож саме в\nolinebreak[3] такому порядку вони і вводитимуться у Вашу програму. Якщо дахи трьох або більше хмарочосів виявляються розміщеними на\nolinebreak[2] одній прямій, ближчі затуляють дальші, і\nolinebreak[3] дальших не~видно.

\InputFile
Перший рядок містить кількість хмарочосів~$N$, наступні\nolinebreak[2] $N$\nolinebreak[3] рядків містять по два цілі числа кожен --- координату\nolinebreak[3] $x_i$ та висоту~$h_i$. Гарантовано, що ${1{\<}N{\<}4321}$, $0\dib{{\<}}x_1\dib{{<}}x_2\dib{{<}}\dots\dib{{<}}x_N\dib{{\<}}10^6$\nolinebreak[3] (мільйон),\linebreak[2] ${1{\<}h_i{\<}10^5}$\nolinebreak[2] (сто\nolinebreak[3] тисяч). 

\OutputFile
Програма має вивести $N$\nolinebreak[3] рядків, $i$-ий рядок має містити одне ціле число --- кількість інших хмарочосів, які видно з даху хмарочосу $\No\,i$.

\begin{minipage}{\textwidth}

\Example

\vspace{-\baselineskip}

\begin{exampleSimpleThree}{4em}{4em}{15em}{}%
\exmp{11
0 4
3 5
5 3
6 4
7 5
8 8
10 5
12 4
14 3
17 1
19 7}{2
5
3
4
3
10
3
4
4
3
5}{\raisebox{-72pt}{\begin{mfpic}[9.6]{0}{19}{0}{8}
\lines{( 0,0),(19,0)}
\lines{( 0,1),(19,1)}
\lines{( 0,2),(19,2)}
\lines{( 0,3),(19,3)}
\lines{( 0,4),(19,4)}
\lines{( 0,5),(19,5)}
\lines{( 0,6),(19,6)}
\lines{( 0,7),(19,7)}
\lines{( 0,8),(19,8)}
\lines{( 0,0),( 0,8)}
\lines{( 1,0),( 1,8)}
\lines{( 2,0),( 2,8)}
\lines{( 3,0),( 3,8)}
\lines{( 4,0),( 4,8)}
\lines{( 5,0),( 5,8)}
\lines{( 6,0),( 6,8)}
\lines{( 7,0),( 7,8)}
\lines{( 8,0),( 8,8)}
\lines{( 9,0),( 9,8)}
\lines{(10,0),(10,8)}
\lines{(11,0),(11,8)}
\lines{(12,0),(12,8)}
\lines{(13,0),(13,8)}
\lines{(14,0),(14,8)}
\lines{(15,0),(15,8)}
\lines{(16,0),(16,8)}
\lines{(17,0),(17,8)}
\lines{(18,0),(18,8)}
\lines{(19,0),(19,8)}
\pen{1mm}
\lines{(0,0),(19,0)}
\lines{(0,0),(0,4)}
\lines{(3,0),(3,5)}
\lines{(5,0),(5,3)}
\lines{(6,0),(6,4)}
\lines{(7,0),(7,5)}
\lines{(8,0),(8,8)}
\lines{(10,0),(10,5)}
\lines{(12,0),(12,4)}
\lines{(14,0),(14,3)}
\lines{(17,0),(17,1)}
\lines{(19,0),(19,7)}
\end{mfpic}}}%
\end{exampleSimpleThree}

\end{minipage}

\end{problem}
	

\Tutorial	Намагання розв'язати задачу через три вкладені цикли (два\nolinebreak[3] перебирають поточну пару хмарочосів , всер\'{е}дині них третій перебирає усі проміжні, дивлячись, чи\nolinebreak[2] не\nolinebreak[3] затуляє він видимість поточної пари) --- погана ідея. Такий розв’язок набирає 150--\nolinebreak[3]190 балів з~250. Конкретне значення у~проміжку 150--\nolinebreak[3]190 залежить головним чином від того, чи\nolinebreak[3] обривається третій цикл негайно, як тільки встановлений результат. Асимптотична складність: якщо \mbox{3-ій} цикл обривається, то $O(N^3)$, якщо ні\nolinebreak[3] --- $\Theta(N^3)$. 

\myflfigaw{\mbox{\raisebox{-30pt}[60pt][0pt]{\begin{mfpic}[12]{0}{19}{0}{8}
\dotted\lines{( 0,0),( 8,0)}
\dotted\lines{( 0,1),( 8,1)}
\dotted\lines{( 0,2),( 8,2)}
\dotted\lines{( 0,3),( 8,3)}
\dotted\lines{( 0,4),( 8,4)}
\dotted\lines{( 0,5),( 8,5)}
\dotted\lines{( 0,6),( 8,6)}
\dotted\lines{( 0,7),( 8,7)}
\dotted\lines{( 0,8),( 8,8)}
\dotted\lines{( 0,0),( 0,8)}
\dotted\lines{( 1,0),( 1,8)}
\dotted\lines{( 2,0),( 2,8)}
\dotted\lines{( 3,0),( 3,8)}
\dotted\lines{( 4,0),( 4,8)}
\dotted\lines{( 5,0),( 5,8)}
\dotted\lines{( 6,0),( 6,8)}
\dotted\lines{( 7,0),( 7,8)}
\dotted\lines{( 8,0),( 8,8)}
%
\lines{(0,4),(3,5)}
\lines{(0,4),(5,3)}
\lines{(0,4),(6,4)}
\lines{(0,4),(7,5)}
\lines{(0,4),(8,8)}
\pen{1mm}
\lines{(0,0),(8,0)}
\lines{(0,0),(0,4)}
\lines{(3,0),(3,5)}
\lines{(5,0),(5,3)}
\lines{(6,0),(6,4)}
\lines{(7,0),(7,5)}
\lines{(8,0),(8,8)}
\end{mfpic}}}}
Для ефективнішого розв'язку, введемо поняття \emph{нахил з\nolinebreak[3] \mbox{$j$-го} хмарочосу на \mbox{$k$-й}} (на\nolinebreak[2] рис.\ зображені нахили з \mbox{1-го} хмарочоса на інші). Нахили можна подавати у програмі або кутовими коефіціентами
$\displaystyle\frac{y_k-y_j}{x_k-x_j}$,
або векторами $({x_k{-}x_j}; {y_k{-}y_j})$.
(Про переваги використання таких векторів у багатьох інших задачах
див.\nolinebreak[1] \verb"https://goo.gl/6yppjy" зокрема і за назвою <<\emph{обчислювальна геометрія}>> взагалі; але у цій задачі достатньо й кутових коефіціентів, якщо подавати їх у якнайточнішому типі \verb"extended" (\texttt{long\nolinebreak[3] double}).)

Розглянемо, як порахувати кількість хмарочосів, видимих з\nolinebreak[3] \mbox{1-го}.\linebreak[2] \mbox{2-й}\nolinebreak[3] хмарочос (якщо він взагалі існує, тобто ${N{>}1}$) гарантовано видимий з\nolinebreak[3] \mbox{1-го}. Запам’ятаємо нахил з\nolinebreak[3] \mbox{1-го} хмарочоса на\nolinebreak[3] \mbox{2-й} і оголосимо його \emph{поточним нахилом затулення горизонту}. Потім бігтимемо по решті хмарочосів зліва направо, і\nolinebreak[3] нахил зі все того~ж \mbox{1-го} на кожен наступний виявлятиметься або нижчим-або-рівним, чим нахил поточного затулення горизонту (за\nolinebreak[3] годинниковою стрілкою), або вищим (проти годинникової стрілки). У\nolinebreak[3] першому випадку, поточного хмарочосу не\nolinebreak[3] видно й нічого робити не~треба. У\nolinebreak[3] другому\nolinebreak[3] --- треба додати одиничку на позначення того, що поточний хмарочос видно з\nolinebreak[3] \mbox{1-го}, і оновити нахил поточного затулення горизонту.

Для інших хмарочосів, є ще хмарочоси зліва, які теж треба врахувати. Ускладнення не~принципове, але \emph{як краще} це врахувати?

Писати ще\nolinebreak[3] один цикл, який біжить від поточної позиції наліво\nolinebreak[3] --- спосіб можливий, але \underline{\emph{не}}~найкращий. Зокрема, тому, що с\'{а}ме в таких дублюваннях схожих фрагментів часто з'являються помилки (особливо, якщо з~першого разу написати неправильно, і~вносити правки).

Досить зручний спосіб, який і\nolinebreak[3] дозволяє не~писати зайвого, і\nolinebreak[3] працює дещо швидше за\nolinebreak[2] інші\nolinebreak[3] --- врахувати симетричність видимості (\mbox{$k$-й}\nolinebreak[3] видно з~\mbox{$j$-го} тоді й тільки тоді, коли \mbox{$j$-й}\nolinebreak[3] видно з~\mbox{$k$-го}). Завдяки цьому, коли при розгляді сусідів \mbox{$j$-го} хмарочоса з'ясовано, що з~нього видно\nolinebreak[2] \mbox{$k$-й} (${k{>}j}$), можна додати по\nolinebreak[3] одиничці і~до\nolinebreak[2] кількості видимих з~\mbox{$j$-го}, і~до\nolinebreak[2] кількості видимих з~\mbox{$k$-го}.
Втім, дане пришвидшення (удвічі) не~принципове. Асимптотика однакова\nolinebreak[3] --- $\Theta(N^2)$.






\contest{ІІІ (обласний) етап 2014/15 навч. року}{Черкаська обл.}{20.01.2015}
\renewenvironment{problemAllDefault}[1]{\vspace{10mm}\par\begin{problem}{#1}{\stdinOrInputTxt}{\stdoutOrOutputTxt}{1 сек}{64 мегабайти}}{\end{problem}}

\subsection{ІІІ (обласний) етап 2014/15 н.~р.}

Задачі доступні для дорішування (\verb"ejudge.ckipo.edu.ua", змагання $\No$48).

В усіх задачах даного змагання, програма може читати вхідні дані хоч з клавіатури, хоч зі вхідного файлу \verb"input.txt" (але\nolinebreak[2] лише з чогось одного, а\nolinebreak[3] не\nolinebreak[2] поперемінно). Аналогічно, програма може виводити результати хоч на\nolinebreak[3] екран, хоч у вихідний текстовий файл\nolinebreak[2] \verb"output.txt" (теж лише на/у щось одне).


\vspace{-0.5\baselineskip minus 1cm}
\begin{problemAllDefault}{Гірлянда --- garland}

\hyphenpenalty=500

На Новорічні свята Василь разом з батьком вирішили зробити електричну гірлянду із лампочок. При створенні гірлянди лапочки включаються в коло послідовно та деякі паралельно так, що в паралельному з’єднанні може знаходитись лише дві лампочки. Для з’ясування можливості підключення гірлянди до джерела живлення, Василю треба визначити загальний опір створеної гірлянди. З~фізики йому відомо, що при послідовному з’єднанні загальний опір кола розраховується за формулою: $R_1\dib{{+}}R_2\dib{{+}}\cdots\dib{{+}}R_n$, а при паралельному: $\frac{1}{R} \dib{{=}} \frac{1}{R_1} \dib{{+}} \frac{1}{R_2} \dib{{+}} \cdots \dib{{+}} \frac{1}{R_n}$.

%%%\Task 
Напишіть програму \texttt{garland}, яка б обчислювала загальний опір гірлянди.

\InputFile У першому рядку задано загальну кількість лампочок~$N$, в~другому\nolinebreak[3] --- через пробіл опір кожної з лампочок (значення опору є цілим числом і знаходиться в межах від 1 до~1000). В~третьому рядку знаходиться ціле число~$K$\nolinebreak[3] --- кількість пар лампочок ($0\dib{{\<}}K\dib{{\<}}{N/2}$), які включені в\nolinebreak[3] коло паралельно. Кожен наступний рядок містить по\nolinebreak[2] два порядкових номери лампочок, що включені паралельно.

\OutputFile Загальний опір гірлянди (як дійсне число без заокруглень).

\Example

\vspace{-\baselineskip}

\begin{exampleSimpleThree}{6em}{3em}{14.5em}{Схема прикладу}
\exmp{6
2 4 6 7 3 1
2
2 3
5 6}{12.15}{\mbox{\def\resistor#1#2#3#4{ %% x y dy caption
\gclear\rect{(#1-0.8,#2-0.2),(#1+0.8,#2+0.2)}
\rect{(#1-0.8,#2-0.2),(#1+0.8,#2+0.2)}
\ifnum #3 < 0
\tlabel[tc](#1,#2-0.25){#4}
\else
\tlabel[bc](#1,#2+0.25){#4}
\fi}
\raisebox{-36pt}{\begin{mfpic}[21]{-0.125}{8.25}{0.25}{3}
\lines{(-0.125,2),(8.25,2)}
\lines{(2,2),(2,1.25),(4,1.25),(4,2)}
\point{(2,2)}
\point{(4,2)}
\lines{(6,2),(6,1.25),(8,1.25),(8,2)}
\point{(6,2)}
\point{(8,2)}
\resistor{1}{2}{+1}{$R_1{=}2$}
\resistor{3}{2}{+1}{$R_2{=}4$}
\resistor{3}{1.25}{-1}{$R_3{=}6$}
\resistor{5}{2}{+1}{$R_4{=}7$}
\resistor{7}{2}{+1}{$R_5{=}3$}
\resistor{7}{1.25}{-1}{$R_6{=}1$}
\gclear\circle{(-0.125,2),0.0625}
\circle{(-0.125,2),0.0625}
\gclear\circle{(8.25,2),0.0625}
\circle{(8.25,2),0.0625}
\end{mfpic}}}}%
\end{exampleSimpleThree}


\Note %Відповідь 
Можна виводити також і у форматі \texttt{1.2150000000000E+01}.

\end{problemAllDefault}
	

\Tutorial	Задача в~основному на реалізацію, тобто головне --- уважно прочитати й акуратно реалізувати.
Єдиний неочевидний момент --- як рахувати суму всіх \emph{тих \'{о}порів, які \underline{не}~були задіяні} у~паралельних підключеннях.

Один з можливих способів такий: cпочатку порахувати суму абсолютно всіх опорів; читаючи чергову пару номерів опорів, з’єднаних паралельно, не лише обчислювати опір їхнього паралельного з’єднання $1/\bigl(1/R[i]+1/R[j]\bigr)$ і додавати його до результату, але також і віднімати з того ж результату $R[i]+R[j]$, бо ці \'{о}пори раніше додали, а виявилося, що даремно.

Ще один можливий спосіб --- почати з розгляду паралельних пар, і щоразу, додавши до загальної суми $1/\bigl(1/R[i]+1/R[j]\bigr)$, \emph{заміняти $R[i]$ та $R[j]$ на нулі}. Завершивши розгляд усіх паралельних пар, пододавати всі $R[i]$ (уже використані будуть нулями й не~вплинуть на результат).

Приклади програм-розв’язків: 
\verb"ideone.com/QwkKWN"


{\color{green}\begin{small}

\renewcommand{\baselinestretch}{0.875}

(Повний вміст даного посилання \verb"ideone.com/QwkKWN" такий:
\verbatiminput{QwkKWN.pas}
--- кінець цитати посилання \verb"ideone.com/QwkKWN")

\end{small}}


 (першим способом), 
\verb"ideone.com/QNgTua"


{\color{green}\begin{small}

\renewcommand{\baselinestretch}{0.875}

(Повний вміст даного посилання \verb"ideone.com/QNgTua" такий:
\verbatiminput{QNgTua.pas}
--- кінець цитати посилання \verb"ideone.com/QNgTua")

\end{small}}


 (др\'{у}гим). Асимптотика однакова\nolinebreak[3] --- $\Theta(N)$.


\begin{problemAllDefault}{Прямокутники --- rectangles}

Дані два прямокутники, сторони яких паралельні вісям координат.

\Task Напишіть програму \texttt{rectangles}, яка б визначала площу їхнього об’єднання, тобто усієї частини площини, що покрита хоча б одним з прямокутників. Площу спільної частини обох прямокутників (якщо така є) слід враховувати один раз.

\InputFile містять два рядки, кожен з яких описує один з прямокутників, у форматі $x_{\min}$ $x_{\max}$ $y_{\min}$ $y_{\max}$. Усі координати є цілими числами, що не перевищують по модулю~1000.

\OutputFile Ваша програма має вивести єдине ціле число --- знайдену площу об’єднання.

% % % \Examples
% % % \vspace*{-\baselineskip}
% % % \begin{exampleSimpleThree}{6em}{4em}{6em}{}%
% % % \exmp{0 10 0 10
% % % 20 30 20 30}{200}{}%
% % % \exmp{0 20 0 30
% % % 10 12 17 23}{600}{}%
% % % \exmp{0 4 0 3
% % % -2 1 2 4}{17}{\raisebox{-32pt}{\begin{mfpic}[9]{-2.3}{4.9}{-0.3}{4.9}
% % % \axes
% % % \dotted\lines{(-1,-0.1),(-1,4.1)}
% % % \dotted\lines{(-2,-0.1),(-2,4.1)}
% % % \dotted\lines{( 1,-0.1),( 1,4.1)}
% % % \dotted\lines{( 2,-0.1),( 2,4.1)}
% % % \dotted\lines{( 3,-0.1),( 3,4.1)}
% % % \dotted\lines{( 4,-0.1),( 4,4.1)}
% % % \dotted\lines{(-2.1, 1),(4.1, 1)}
% % % \dotted\lines{(-2.1, 2),(4.1, 2)}
% % % \dotted\lines{(-2.1, 3),(4.1, 3)}
% % % \dotted\lines{(-2.1, 4),(4.1, 4)}
% % % \rhatch\polygon{(0,0),(4,0),(4,3),(1,3),(1,4),(-2,4),(-2,2),(0,2)}
% % % \pen{2pt}
% % % \rect{(0,0),(4,3)}
% % % \rect{(-2,2),(1,4)}
% % % \end{mfpic}}}%
% % % \end{exampleSimpleThree}


\Examples

\begin{exampleSimple}{6em}{4em}%
\exmp{0 10 0 10
20 30 20 30}{200}%
\exmp{0 20 0 30
10 12 17 23}{600}%
\end{exampleSimple}
\begin{exampleSimple}{6em}{4em}%
\exmp{0 4 0 3
-2 1 2 4}{17}%
\end{exampleSimple}
{\raisebox{-18pt}{\begin{mfpic}[9]{-2.3}{4.9}{-0.3}{4.9}
\axes
\dotted\lines{(-1,-0.1),(-1,4.1)}
\dotted\lines{(-2,-0.1),(-2,4.1)}
\dotted\lines{( 1,-0.1),( 1,4.1)}
\dotted\lines{( 2,-0.1),( 2,4.1)}
\dotted\lines{( 3,-0.1),( 3,4.1)}
\dotted\lines{( 4,-0.1),( 4,4.1)}
\dotted\lines{(-2.1, 1),(4.1, 1)}
\dotted\lines{(-2.1, 2),(4.1, 2)}
\dotted\lines{(-2.1, 3),(4.1, 3)}
\dotted\lines{(-2.1, 4),(4.1, 4)}
\rhatch\polygon{(0,0),(4,0),(4,3),(1,3),(1,4),(-2,4),(-2,2),(0,2)}
\pen{2pt}
\rect{(0,0),(4,3)}
\rect{(-2,2),(1,4)}
\end{mfpic}}}%



\end{problemAllDefault}
	

\Tutorial	{
Цю задачу важко вирішити на повні бали шляхом аналізу випадків.
Просто тому, що їх більше, ніж може здатися. Навіть якщо не~розглядати випадки рівності деяких із координат (як-то <<не~розглядати окремо ситуацію \verb"xmin1==xmax2", а об'єднати з ситуацією \verb"xmin1>xmax2", написавши \verb"xmin1>=xmax2">>), все одно лишаються такі потенційно різні випадки:
\def\LLL#1#2{\rhatch\rect{#1,#2}
\rect{#1,#2}}%
\def\RRR#1#2{\lhatch\rect{#1,#2}
\rect{#1,#2}}%
\def\wholeCase#1#2#3#4#5#6#7#8{%
\begin{mfpic}[8.5]{-0.125}{3.125}{-0.125}{3.125}
\rect{(-0.125,-0.125),(3.125,3.125)}
\pen{2pt}
\LLL{(#1,#5)}{(#2,#6)}
\RRR{(#3,#7)}{(#4,#8)}
\end{mfpic}}
\begin{longtable}{cccccccccccc}%
\wholeCase{0}{1}{2}{3}{0}{1}{2}{3}      &
\wholeCase{0}{1}{2}{3}{0}{2}{1}{3}      &
\wholeCase{0}{1}{2}{3}{0}{3}{1}{2}      &
\wholeCase{0}{1}{2}{3}{1}{2}{0}{3}      &
\wholeCase{0}{1}{2}{3}{1}{3}{0}{2}      &
\wholeCase{0}{1}{2}{3}{2}{3}{0}{1}
& %\\
\wholeCase{0}{2}{1}{3}{0}{1}{2}{3}      &
\wholeCase{0}{2}{1}{3}{0}{2}{1}{3}      &
\wholeCase{0}{2}{1}{3}{0}{3}{1}{2}      &
\wholeCase{0}{2}{1}{3}{1}{2}{0}{3}      &
\wholeCase{0}{2}{1}{3}{1}{3}{0}{2}      &
\wholeCase{0}{2}{1}{3}{2}{3}{0}{1}
\\
\wholeCase{0}{3}{1}{2}{0}{1}{2}{3}      &
\wholeCase{0}{3}{1}{2}{0}{2}{1}{3}      &
\wholeCase{0}{3}{1}{2}{0}{3}{1}{2}      &
\wholeCase{0}{3}{1}{2}{1}{2}{0}{3}      &
\wholeCase{0}{3}{1}{2}{1}{3}{0}{2}      &
\wholeCase{0}{3}{1}{2}{2}{3}{0}{1}
& %\\
\wholeCase{1}{2}{0}{3}{0}{1}{2}{3}      &
\wholeCase{1}{2}{0}{3}{0}{2}{1}{3}      &
\wholeCase{1}{2}{0}{3}{0}{3}{1}{2}      &
\wholeCase{1}{2}{0}{3}{1}{2}{0}{3}      &
\wholeCase{1}{2}{0}{3}{1}{3}{0}{2}      &
\wholeCase{1}{2}{0}{3}{2}{3}{0}{1}
\\
\wholeCase{1}{3}{0}{2}{0}{1}{2}{3}      &
\wholeCase{1}{3}{0}{2}{0}{2}{1}{3}      &
\wholeCase{1}{3}{0}{2}{0}{3}{1}{2}      &
\wholeCase{1}{3}{0}{2}{1}{2}{0}{3}      &
\wholeCase{1}{3}{0}{2}{1}{3}{0}{2}      &
\wholeCase{1}{3}{0}{2}{2}{3}{0}{1}
& %\\
\wholeCase{2}{3}{0}{1}{0}{1}{2}{3}      &
\wholeCase{2}{3}{0}{1}{0}{2}{1}{3}      &
\wholeCase{2}{3}{0}{1}{0}{3}{1}{2}      &
\wholeCase{2}{3}{0}{1}{1}{2}{0}{3}      &
\wholeCase{2}{3}{0}{1}{1}{3}{0}{2}      &
\wholeCase{2}{3}{0}{1}{2}{3}{0}{1}
\end{longtable}
\vspace{-0.5\baselineskip}

Ситуації, коли прямокутники повністю обміняні місцями, наведено як різні, бо якщо виводити для кожного випадку свою формулу залежності результату від вхідних даних, вони можуть бути різними.
Звісно, деякі з цих випадків все одно можна об'єднати.
Але не~так просто зробити це правильно, ніде не~помил\'{и}тися.
Тому пропонується розв'язати задачу інакше.

}

\MyParagraph{1-й спосіб, придатний для довільних координат}
Площа % шуканого 
об’єднання дорівнює сумі площ окремо взятих 
прямокутників 
% фігур 
мінус міра перетину (спільної частини); якщо спільної частини нема, площею перетину вважається~0.
% (До речі, це 
(Це\nolinebreak[3] міркування є част\-ко\-вим випадком \emph{принципу включень та виключень}).
%%% \verb"https://uk.wikipedia.org/wiki/Формула_включень-виключень").

Щоб знайти перетин, можна (окремо для~$x$, окремо для~$y$) узяти максимін (максимум із мінімумів) і мінімакс (мінімум із максимумів). Наприклад:

\begin{tabular}{@{}c@{}c@{}}
\raisebox{-28pt}{\begin{mfpic}[12]{-2.3}{4.9}{-0.3}{4.9}
\axes
\dotted\lines{(-1,-0.1),(-1,4.1)}
\dotted\lines{(-2,-0.1),(-2,4.1)}
\dotted\lines{( 1,-0.1),( 1,4.1)}
\dotted\lines{( 2,-0.1),( 2,4.1)}
\dotted\lines{( 3,-0.1),( 3,4.1)}
\dotted\lines{( 4,-0.1),( 4,4.1)}
\dotted\lines{(-2.1, 1),(4.1, 1)}
\dotted\lines{(-2.1, 2),(4.1, 2)}
\dotted\lines{(-2.1, 3),(4.1, 3)}
\dotted\lines{(-2.1, 4),(4.1, 4)}
\rhatch\polygon{(0,0),(4,0),(4,3),(1,3),(1,4),(-2,4),(-2,2),(0,2)}
\arrow\lines{(-2.25,1),(0,2)}
\arrow\lines{(-2.25,3.5),(0,3)}
\arrow\lines{(-2,5),(0,3)}
\arrow\lines{(2,5.5),(1,3)}
\tlabel[tr](-2.25,1){$\max(y_{\min1}, y_{\min2})$} %%%максимiн iгрекiв\\
\tlabel[cr](-2.25,3.5){$\min(y_{\max1}, y_{\max2})$} %%%мiнiмакс iгрекiв\\
\tlabel[br](-2,5){$\max(x_{\min1}, x_{\min2})$} %%%максимiн iксiв\\
\tlabel[bc](2.25,5.5){$\min(x_{\max1}, x_{\max2})$} %%%мiнiмакс iксiв\\
\pen{2pt}
\rect{(0,0),(4,3)}
\rect{(-2,2),(1,4)}
\end{mfpic}}
&
$
\begin{array}{@{}r@{\,=\,}c@{\,=\,}r@{,\,}l@{\,=\,}l}
\textnormal{максимін~}x & \max(x_{\min1}, x_{\min2}) & \max(0 & -2) & 0;\\
\textnormal{мінімакс~}x & \min(x_{\max1}, x_{\max2}) & \min(4 &  1) & 1;\\
\textnormal{максимін~}y & \max(y_{\min1}, y_{\min2}) & \max(0 &  2) & 2;\\
\textnormal{мінімакс~}y & \min(y_{\max1}, y_{\max2}) & \min(3 &  4) & 3.
\end{array}
$
\end{tabular}

\underline{\emph{Якщо}} \emph{в~обох випадках} ($x$~та~$y$) максимін строго менший мінімакса, то площа перетину ненульова і її справді треба відняти. 

Асимптотична оцінка --- $\Theta(1)$. Реалізація --- 
\verb"ideone.com/naDNCA"


{\color{green}\begin{small}

\renewcommand{\baselinestretch}{0.875}

(Повний вміст даного посилання \verb"ideone.com/naDNCA" такий:
\verbatiminput{naDNCA.pas}
--- кінець цитати посилання \verb"ideone.com/naDNCA")

\end{small}}





\MyParagraph{2-й спосіб, менш універсальний, але конкретно тут теж правильний}
В~умові задано досить невеликі (як для комп’ютера) обмеження на значення координат. Це дає можливість тупо перебрати всі <<клітинки>> і для кожної з них перевірити, чи~належить вона \mbox{1-му} прямокутнику та чи належить \mbox{2-му}. Важливо, що завдяки використанню операції \texttt{or} (\mbox{С-подіб}\-ними мовами~\verb"||") можна не~розбиратися з~випадками, бо абсолютно\nolinebreak[2] не\nolinebreak[3] важливо, чи~мають прямокутники непорожній перетин, чи~не~мають.
Ідея частково повторює згадану на\nolinebreak[3] стор.~\pageref{text:drawing-by-coords-in-graphics-password-problem} (задача <<Графічний пароль>>), але тут не\nolinebreak[3] треба нічого (крім вхідних даних) запам'ятовувати.

Реалізація цього способу: 
\verb"ideone.com/BHOtpE"


{\color{green}\begin{small}

\renewcommand{\baselinestretch}{0.875}

(Повний вміст даного посилання \verb"ideone.com/BHOtpE" такий:
\verbatiminput{BHOtpE.pas}
--- кінець цитати посилання \verb"ideone.com/BHOtpE")

\end{small}}


\hspace{0.5em plus 1em}
Код навіть коротший і простіший, ніж для першого способу. Але: якби дозволялися дробові значення координат, цей спосіб був~би принципово неможливим; при цілих координатах, його асимптотична оцінка\nolinebreak[3] --- $O(X\cdot{}Y)$ (де\nolinebreak[2] $X$ та\nolinebreak[3] $Y$\nolinebreak[3] --- розміри діапазонів можливих значень координат), що немало.


\begin{problemAllDefault}{Генератор паролів --- password}

У генераторі паролів закладена схема, яка за певними правилами утворює паролі із комбінацій цифр та великих літер англійського алфавіту. Цифри та літери в паролі можуть розташовуватись лише за зростанням (для літер зростання визначається алфавітом). Паролі містять, як мінімум, один символ (літеру або цифру). Якщо пароль містить і цифри, і літери, то цифри завжди йдуть після літер. Повторення символів не~допускається.

Наприклад: \texttt{CH15} --- коректний пароль, а \texttt{OLYMPIAD} --- некоректний пароль (оскільки літери розташовані не~в~алфавітному порядку).

Усі паролі генеруються послідовно у вигляді впорядкованого списку. Якщо два паролі містять різну кількість символів, то першим іде пароль з меншою кількістю. Якщо декілька паролів мають однакову кількість символів, то вони генеруються в алфавітному порядку (при цьому літери вважаються меншими за цифри).

Початок впорядкованого списку паролів має наступний вигляд: \texttt{A},~\texttt{B},~\dots, \texttt{Z}, \texttt{0}, \texttt{1}, \texttt{2},~\dots, \texttt{9}, \texttt{AB}, \texttt{AC},~\dots, \texttt{A9},~\texttt{BC},~\dots 

\Task Напишіть програму \texttt{password}, яка визначатиме $n$-ий пароль у списку паролів, який утворить генератор.

\InputFile Число $n$ ($1\<n\<10^{10}$).

\OutputFile Ваша програма має вивести $n$-ий пароль.

\Examples
\begin{exampleSimple}{2em}{2em}%
\exmp{1}{A}%
\exmp{37}{AB}%
\end{exampleSimple}

\Scoring Приблизно 50\% балів припадає на тести, в яких $n\<50000$. Ще приблизно 25\% --- на тести, в яких $n\<10^7$. Решта (приблизно 25\%) --- на тести, в яких $10^9 \< n \< 10^{10}$.


\Note Англійський алфавіт має вигляд A~B~C D E F G H I J K L M N O P Q R S T U V W X~Y~Z. Літери алфавіту у таблиці ASCII йдуть поспіль, під номерами від 65~(``A'') до\nolinebreak[3] 90~(``Z''). Зростаюча послідовність цифр 0~1~2 3 4 5 6 7~8~9 також неперервна у таблиці ASCII (але\nolinebreak[3] не\nolinebreak[2] поспіль з\nolinebreak[3] літерами). Цифри йдуть під номерами від 48~(``0'') до\nolinebreak[3] 57~(``9'').


\end{problemAllDefault}
	

\Tutorial	Легенда задачі відірвана від життя, ці правила не~мають нічого спільного з реальною генерацією паролів. Тим\nolinebreak[2] не\nolinebreak[3] менш, будемо користуватися термінами <<пароль>> і <<номер паролю>>, раз вони введені в умові.

\MyParagraph{Позбудемось окремих статусів літер і цифр, перейшовши до єдиного алфавіту}
Правила про порядок можна спростити до таких:
\begin{enumerate}
\item
будемо вважати алфавітом \texttt{A},~\texttt{B}, \texttt{C}, \texttt{D}, \texttt{E}, \texttt{F}, \texttt{G}, \texttt{H}, \texttt{I}, \texttt{J}, \texttt{K}, \texttt{L}, \texttt{M}, \texttt{N}, \texttt{O}, \texttt{P}, \texttt{Q}, \texttt{R}, \texttt{S}, \texttt{T}, \texttt{U}, \texttt{V}, \texttt{W}, \texttt{X}, \texttt{Y}, \texttt{Z}, \texttt{0}, \texttt{1}, \texttt{2}, \texttt{3}, \texttt{4}, \texttt{5}, \texttt{6}, \texttt{7},~\texttt{8},~\texttt{9} (с\'{а}ме в такому порядку);
\item
всер\'{е}дині кожного пароля (крім 1-символьних), кожен наступний символ мусить бути строго більшим за попередній (згідно алфавіту п.~1).
\end{enumerate}
Переформульовувати правила порівняння різних паролів нема потреби.

\MyParagraph{Частковий розв’язок на 76 балів (зі~100)}
Оскільки в умові сказано, що досить багато балів припадає на не дуже великі значення~$n$, можна писати перебір, тобто дійсно генерувати послідовно \mbox{1-й}, \mbox{2-й},\nolinebreak[3] \dots{} паролі аж до $n$-го. Виявляється, при цьому не\nolinebreak[3] дуже важко добитися, щоб генерувалися відразу лише допустимі (згідно з умовою задачі) паролі.

{

\def\tabbb{\hspace*{1em}}

Розглянемо простіший випадок. Нехай потрібно вивести послідовно пари (1,2), (1,3), (1,4), (1,5), (2,3), (2,4), (2,5), (3,4), (3,5), (4,5), тобто пари з чисел від 1 до~5, щоб \mbox{2-й} елемент пари завжди був строго більшим за\nolinebreak[2] \mbox{1-й}. Це\nolinebreak[3] можна зробити за допомогою циклів та \texttt{if}-а, як у лівому стовпчику рис.~\ref{fig:check-or-gen-only-needed}. А~можна, як у правому, замінити \emph{перевірку} ${i{<}j}$ на \emph{задання лише потрібного} діапазону.

\begin{figure}[b]
\begin{center}
\hrulefill\par
\begin{tabular}{l|l}
\begin{minipage}{13em}\begin{small}\renewcommand{\baselinestretch}{0.875}\begin{alltt}for i:=1 to 5 do
\tabbb{}for j:=1 to 5 do
\tabbb\tabbb{}if i < j then
\tabbb\tabbb\tabbb{}writeln(i, ', ', j);\end{alltt}\end{small}\end{minipage}
&
\begin{minipage}{13em}\begin{small}\renewcommand{\baselinestretch}{0.875}\begin{alltt}for i:=1 to 4 do
\tabbb{}for j:=i+1 to 5 do
\tabbb\tabbb{}writeln(i, ', ', j);\end{alltt}\end{small}\end{minipage}
\end{tabular}
\end{center}
\caption{Два способи генерації однієї послідовності пар}\label{fig:check-or-gen-only-needed}
\end{figure}

}

Для \mbox{2-х} вкладених циклів це відносно дрібна оптимізація ($\approx$ удвічі). Але якщо застосувати ту саму ідею до циклів більшої вкладеності, пришвидшення істотне: для п'яти вкладених циклів\nolinebreak[3] $\approx$сотні разів, для десяти\nolinebreak[3] --- $\approx$мільйони. (Доведення потреб\'{у}є знань комбінаторики; але\nolinebreak[1] не\nolinebreak[3] дуже глибоких, тож пропонується як вправа. До\nolinebreak[3] того\nolinebreak[3] ж, писати програму можна й без доведення\dots)

Приклад такого розв’язку --- 
\verb"ideone.com/Xg6sKT"


{\color{green}\begin{small}

\renewcommand{\baselinestretch}{0.875}

(Повний вміст даного посилання \verb"ideone.com/Xg6sKT" такий:
\verbatiminput{Xg6sKT.pas}
--- кінець цитати посилання \verb"ideone.com/Xg6sKT")

\end{small}}


\hspace{0.5em plus 1em}%
Зовсім\nolinebreak[2] не\nolinebreak[3] взірець красоти й лаконічності. У~ньому легко допустити і важко шукати технічні помилки. Але він все ж набирає чимало балів.

\MyParagraph{Повний (100\%) розв’язок}
Перш за все, загальна кількість $k$-сим\-воль\-них паролів рівна $C(36, k)$, де $C(n,k)$, воно~ж $C_n^k$ --- кількість \emph{сполучень} (рос. \emph{сочетания}, англ. \emph{combinations}) з~$n$ по~$k$. Це~так, бо з~36\nolinebreak[3] символів вибираються $k$ різних, і одні й ті самі вибрані символи не~можна переставляти місцями, бо дозволений лише порядок за зростанням (у~алфавіті \texttt{A},~\texttt{B},~\dots,~\texttt{Z}, \texttt{0},~\texttt{1},~\dots,~\texttt{9}).

Так що почнемо розв’язок з того, що взн\'{а}ємо довжину (кількість символів) шуканого пароля і його номер \emph{серед паролів цієї довжини}.

\begin{small}
\begin{itemize}[leftmargin=*,itemsep=0pt,partopsep=0pt,topsep=0pt,parsep=0pt]
\item[] Наприклад, прочитали у вхідних даних 2015.

\item Кіль-ть 1-символьних паролів ${C(36,1){=}36}$,\hspace{0.5em plus 1em} ${36{<}2015}$\nolinebreak[3] --- отже, у паролі більше одного символу, й номер серед (більш-ніж-1)-символьних ${2015-36=1979}$.

\item Кіль-ть 2-символьних паролів ${C(36,2){=}630}$,\hspace{0.5em plus 1em} ${630{<}1979}$\nolinebreak[3] --- отже, у паролі більше двох символів, і номер серед (більш-ніж-2)-символьних ${1979-630=1349}$.

\item Кіль-ть 3-символьних паролів ${C(36,3){=}7140}$,\hspace{0.5em plus 1em} ${7140{\>}1349}$\nolinebreak[3] --- отже, пароль 3-символьний, і\nolinebreak[3] його номер серед 3-символьних рівний~1349.

\end{itemize}
\end{small}

Узнавши довжину пароля та його номер серед паролів 
відповідної довжини, починаємо взнавати цей пароль символ за символом, зліва направо --- на тій підставі, що для кожного можливого початку можна взнавати (засобами комбінаторики) 
% (комбінаторно)
кількість паролів з таким початком і знову приймати рішення, чи\nolinebreak[3] цей початок треба пропустити (всі паролі з таким початком мають менші номери), чи\nolinebreak[3] використати (потрібний номер якраз потрапляє у діапазон).

\begin{small}
\begin{itemize}[leftmargin=*,itemsep=0pt,partopsep=0pt,topsep=0pt,parsep=0pt]
\item[] Продовжимо аналіз того самого прикладу (вхідний номер 2015, раніше з’ясовано, що його номер серед 3-символьних рівний 1349).

\item Кіль-ть 3-символьних паролів, що починаються з~\texttt{A}, рівна ${C(35,2) = 595}$, бо продовження % паролю 
2-символьне з 35 символів (від~\texttt{B} до~\texttt{9}). ${1349>595}$\nolinebreak[3] --- отже, початок паролю не~\texttt{A}, а якийсь подальший символ, і номер % паролю 
серед тих подальших ${1349-595=754}$.

\item Кіль-ть 3-символьних паролів, що починаються з~\texttt{B}, рівна ${C(34,2) = 561}$, бо продовження % паролю 
2-символьне з 34 символів (від~\texttt{C} до~\texttt{9}). ${754>561}$\nolinebreak[3] --- отже, початок паролю не~\texttt{B}, а якийсь подальший символ, і номер % паролю 
серед тих подальших ${754-561=193}$.

\item Кіль-ть 3-символьних паролів, що починаються з~\texttt{C}, рівна ${C(33,2) = 528}$, бо продовження % паролю 
2-символьне з 33 символів (від~\texttt{D} до~\texttt{9}). ${193\<528}$\nolinebreak[3] --- отже, початок паролю якраз-таки~\texttt{C}, і його номер серед 3-символьних, що\nolinebreak[3] починаються з~\texttt{C} --- теж~193.

\begin{itemize}[leftmargin=*,itemsep=0pt,partopsep=0pt,topsep=0pt,parsep=0pt]
\item[] Далі відбувається аналогічний підбір наступного символу:

\item[\textopenbullet] Кіль-ть 3-символьних паролів, що починаються з~``\texttt{CD}'', рівна ${C(32,1)=32}$, бо лишається дописати один символ, від~\texttt{E} до~\texttt{9}. ${193>32}$\nolinebreak[3] --- отже, 2-га літера не~\texttt{D}, а\nolinebreak[3] якийсь подальший символ, і номер % паролю 
серед тих подальших ${193-32=161}$.

\item[$\isdiv$] І так далі.

\item[\textopenbullet] Продовживши аналогічні міркування, отримаємо, що шуканий пароль 16-й серед тих, що починаються з~``\texttt{CJ}'', а оскільки після~\texttt{J} можуть іти лише символи, починаючи з~\texttt{K}, то цим 16-м буде~\texttt{Z}.
\end{itemize}

\item[!] Остат\'{о}чно, 2015-й пароль має вигляд ``\texttt{CJZ}''.
\end{itemize}
\end{small}

Дані пояснення займають багато місця, але це тому, що наведено приклад. Правильна реалізація даного комбінаторного алгоритму працює дуже швидко, вкладаючись у секунду з величезним запасом. Адже всього-то треба:

\begin{enumerate}

\item
Познаходити $C(n,k)$, наприклад, усі зразу із проміжку $0\dib{{\<}}k\dib{{\<}}n\dib{{\<}}36$ за допомогою трикутника Паскаля.

\item
Знайти кількість символів у паролі --- віднімати циклом $C(36,1)$, $C(36,2)$,~\dots; якби дійшли до $C(36,36))$, а\nolinebreak[3] номер після усіх віднімань все ще лишався надто великим --- це означало~б, що пароля вказаних вигляду і номера взагалі\nolinebreak[2] не~існує. Але такого не~буде, бо паролів ($2^{36}-1$) все-таки більше, чим $n{\<}10^{10}$. Значить --- тут % взагалі 
не~більш як 36 порівнянь та віднімань.

\item
Для кожної позиції (1-й\nolinebreak[3] символ, 2-й,~\dots) запустити цикл, щоб знайти конкретне значення відповідного символу\nolinebreak[3] --- теж\nolinebreak[3] не~багато, бо і\nolinebreak[3] позицій, і\nolinebreak[3] значень символів не~більше~36.

\end{enumerate}

Від вираження асимптотичної оцінки складності алгоритму типовим чином (через $n$ зі вхідних даних) утримаємось, бо надто багато залежить від розміру алфавіту, а залежність часу роботи від значення~$n$ заплутана.
\emph{Якби} розмір алфавіту був змінним (і при цьому не~з'являлася <<довга>> арифметика), можна було~б говорити про час роботи $O(A^2)$, де\nolinebreak[3] $A$\nolinebreak[3] --- розмір алфавіту. 
% % % При $A{=}36$, це \emph{дуже} швидко\dots


\begin{problem}{З\'{а}мок --- castle}{\stdinOrInputTxt}{\stdoutOrOutputTxt}{D1 --- 1 с, D2 --- 3 с}{128 мегабайтів}


Стародавній з\'{а}мок має прямокутну форму. Замок містить щонайменше дві кімнати. Підлогу замка можна умовно поділити на $M\*N$ клітин. Кожна така клітинка містить <<0>> або <<1>>, які задають порожні ділянки та стіни замку відповідно.

\Task Напишіть програму \texttt{castle}, яка б знаходила кількість кімнат у зам\-ку, площу найбільшої кімнати (яка вимірюється кількістю клітинок) та площу найбільшої кімнати, яку можна утворити шляхом видалення стіни або її частини, тобто, замінивши лише одну <<1>> на <<0>>. Видаляти зовнішні стіни заборонено.

\InputFile План замку задається у вигляді послідовності чисел, по одному числу, яке характеризує кожну клітинку. Перший рядок містить два цілих числа $M$ та\nolinebreak[2] $N$\nolinebreak[3] --- кількість рядків та кількість стовпчиків (${3{\<}M{\<}1000},\hspace{0.5em plus 1em}{3{\<}N{\<}1000}$). $M$~наступних рядків містить по\nolinebreak[3] $N$\nolinebreak[3] нулів або одиниць, що\nolinebreak[3] йдуть поспіль (без\nolinebreak[2] пробілів). Перший та останній рядок, а\nolinebreak[3] також перший та останній стовпчик формують зовнішні стіни замку і складаються лише з одиниць.

\OutputFile Дана задача розділена в системі ejudge на дві підзадачі. У~підзадачі\nolinebreak[3] \texttt{D1} треба здати програму, що знаходить кількість кімнат та площу найбільшої кімнати замку (по\nolinebreak[3] одному числу в\nolinebreak[3] рядку), у~підзадачі\nolinebreak[2] \texttt{D2}\nolinebreak[3] --- площу найбільшої кімнати, яка утвориться в\nolinebreak[3] разі видалення внутрішньої стіни.

\Examples\vspace*{-\baselineskip}

\begin{exampleSimpleThreeWithSpecNameColTwo}{7em}{3em}{3em}{Результати (D1)}{Результати (D2)}%
\exmp{6 8
11111111
10011001
10011001
11111001
10101001
11111111}{4
8}{10}%
\exmp{9 12
111111111111
101001000001
111001011111
100101000001
100011111101
100001000101
111111010101
100000010001
111111111111}{4
28}{38}%
\end{exampleSimpleThreeWithSpecNameColTwo}

\Scoring Значна частина тестів буде містити план замку з кімнатами лише прямокутної форми. Не~менше половини тестів такі, що ${3{\<}M{\<}20},\hspace{0.5em plus 1em}{3{\<}N{\<}50}$.

\end{problem}
	

\Tutorial	\MyParagraph{Як досить легко набрати частину балів}
Для самої лише підзадачі~D1 і часткового випадку <<всі кімнати мають прямокутну форму>> можна написати програму 
\verb"ideone.com/HHr9a3"


{\color{green}\begin{small}

\renewcommand{\baselinestretch}{0.875}

(Повний вміст даного посилання \verb"ideone.com/HHr9a3" такий:
\verbatiminput{HHr9a3.pas}
--- кінець цитати посилання \verb"ideone.com/HHr9a3")

\end{small}}


\hspace{0.5em plus 1em}
Вона спирається на те, що у випадку прямокутності кімнат кожна кімната однозначно задається лівим верхнім кутом, а~перевіряти, чи~справді клітинка є таким кутом, можна умовою \texttt{\mbox{(data[i][j]='0')} \mbox{and} \mbox{(data[i-1][j]='1')} \mbox{and} \mbox{(data[i][j-1]='1')}}, тобто сама клітинка вільна, а ліворуч і згори стіни.

Очевидно (в~т.~ч. з\nolinebreak[3] \mbox{2-го}\nolinebreak[3] тесту з\nolinebreak[3] умови), що для <<закручених>> кімнат це може й не\nolinebreak[3] бути правдою. Але\nolinebreak[2] в\nolinebreak[3] умові обіцяно значну частину тестів з кімнатами прямокутної форми, тож при відсутності кращих ідей можна написати хоча~б такий розв’язок. Він набирає 26~балів (з~50 за усю~D1, зі~100 за усю~D).



\MyParagraph{Повний розв'язок підзадачі D1}
Для відстеження (як завгодно <<закручених>>) кімнат можна реалізувати будь-який з алгоритмів:

\begin{enumerate}

\item	
\emph{пошук ушир} (він же \emph{пошук у~ширину}); рос. \emph{поиск в ширину}, англ. \emph{breadth first search} (\emph{BFS});

\item
\emph{пошук углиб} (він же \emph{пошук у~глибину}); рос. \emph{поиск в глубину}, англ. \emph{depth first search} (\emph{DFS});

\item
різноманітні алгоритми графічної \emph{заливки} (\emph{flood fill}).

\end{enumerate}

Усі ці алгоритми неважко знайти в Інтернеті або в літературі самостійно, й усі вони надто громіздкі, щоб поянювати їх тут. І\nolinebreak[3] кожним із них можна реалізувати задачу зі складністю $\Theta(NM)$. Тільки для цього треба:
\begin{enumerate}
\item
Просто перебирати усі клітинки з\'{а}мку, і щоразу, знайшовши~0, запускати BFS/DFS/заливку, щоб повністю виділити відповідну кімнату, позамінявши її нулі на інші значення, та обчислити її розмір.
\item
Забезпечити, щоб кожен такий виклик BFS/DFS/заливки, котрому вказується, починаючи звідки дослідити кімнату, працював за час, пропорційний розміру цієї кімнати, а не усього замку.
\end{enumerate}

\myhrulefill

Часто вважають, що в такій ситуації найпростішою є рекурсивна реалізація пошуку вглиб. Частково це правда, але рекурсивний пошук углиб має потенційний недолік: пам'яті, потрібної для зберігання рекурсії у програмному стекові, може бути набагато менше, ніж пам'яті взагалі. Як~наслідок, рекурсивна реалізація DFS може завершуватися аварійно по причині \mbox{нестачі} пам'яті --- навіть при фактичних витратах пам'яті, менших, ніж у пошуку вшир або заливці. Стекова пам'ять може бути значно <<дефіцитнішою>>, й коли \emph{вона} закінчилася, наявність іншої пам'яті рекурсії не~допомагає.

С\'{а}ме \emph{може} бути. А~може бути й інакше. І~залежить це від налаштувань компілятора (керування якими доступне програмісту під час <<нормальної>> роботи, але як~правило не~доступне учаснику олімпіади). Конкретно на цій обласній олімпіаді було забезпечено досить великий розмір програмного стеку, тому можна було писати рекурсивний DFS і не~мати проблем; але біда в тому, що при інших налаштуваннях компілятора проблеми цілком можливі.







\MyParagraph{Підзадача D2}
Частину балів (орієнтовно до~20 з~50) можна отримати, розв’язуючи підзадачу~D1 багатократно (для абсолютно кожної <<1>> у внутрішній стіні, замінимо її на <<0>> і заново розв’яжемо~D1; серед усіх таких розв’язків виберемо максимальний). Але це має складність $O(M^2N^2)$, тож ні\'{я}к\nolinebreak[2] не\nolinebreak[3] може бути ефективним розв’язком для $M{\approx}N{\approx}1000$.

Перепишемо підзадачу~D1 так, щоб при підрахунку кількостей та розмірів кімнати не~просто виділялися, а \emph{різні кімнати} виділялися \emph{різними значеннями} (а~клітинки однієї кімнати\nolinebreak[3] --- однаковими). Наприклад, якщо це робити прямо у\nolinebreak[3] масиві з позначками <<0\nolinebreak[3] --- прохід, 1\nolinebreak[3] --- стіна>>, може вийти так:

\noindent\begin{minipage}{\textwidth}
\begin{exampleSimpleThreeWithSpecNameColTwo}{6em}{12em}{13em}{Виділені кімнати}{Масив з розмірами кімнат}%
\exmp{9 12
111111111111
101001000001
111001011111
100101000001
100011111101
100001000101
111111010101
100000010001
111111111111}{~
1 1 1 1 1 1 1 1 1 1 1 1
1 2 1 3 3 1 4 4 4 4 4 1
1 1 1 3 3 1 4 1 1 1 1 1
1 5 5 1 3 1 4 4 4 4 4 1
1 5 5 5 1 1 1 1 1 1 4 1
1 5 5 5 5 1 4 4 4 1 4 1
1 1 1 1 1 1 4 1 4 1 4 1
1 4 4 4 4 4 4 1 4 4 4 1
1 1 1 1 1 1 1 1 1 1 1 1}{\raisebox{-12pt}{\begin{rmfamily}\begin{tabular}{@{}r|ccccc}індекс & \dots &2&3&4&5\\\hline{}значення & \dots&1&5&28&9\end{tabular}\end{rmfamily}}}%
\end{exampleSimpleThreeWithSpecNameColTwo}
\end{minipage}

Якщо при цьому ще й зберігати розміри кімнат у масиві (так, щоб індексами масиву були ті самі ч\'{и}сла, якими позначено кімнати), то для визначення, яка вийде площа кімнати після руйнування деякої стіни, можна просто додати до одинички (площі самої зруйнованої стіни) площі кімнат-сусідів. Так що перебір усіх можливих <<1>> (у не-зовнішніх стінах) можна залишити, бо тепер для кожної такої <<1>> треба робити значно менше дій.

Здається <<логічним>> (і~приклади з умови це <<підтверджують>>), ніби максимальна кімната буде утворена за рахунок об’єднання двох кімнат. Але насправді % подібним <<висновкам>> місце на~смітнику, бо 
це лише поширений випадок, а\nolinebreak[3] не\nolinebreak[3] обов’язкова властивість: замість \mbox{2-х} може бути будь-яке число від~1 до~4 (див.\nolinebreak[2] приклади). Тому  краще, не~роблячи необґрунтованих припущень, акуратно реалізувати для кожної не~зовнішньої\nolinebreak[3] <<1>> перегляд усіх сусідів-кімнат, додаючи площі усіх різних.

\vspace{0.375\baselineskip}

\mytextandpicture{Тест №9. Більшість внутрішніх стін <<товсті>>, тож вилучення \emph{однієї} <<1>> зазвичай не\nolinebreak[3] призводить до з'єднання кімнат. А\nolinebreak[3] в\nolinebreak[3] тому єдиному місці, де призводить (\mbox{2-й}\nolinebreak[3] знизу рядок)\nolinebreak[3] --- утворюється кімната площею $2\dib{{+}}1\dib{{+}}1\dib{{=}}4$.
Набагато більшу площу $44\dib{{+}}1\dib{{=}}45$ можна отримати, зруйнувавши будь-яку (не~зовнішню) стіну кімнати площі~44, утворивши <<нішу>> замість <<проходу>>.}{\begin{minipage}{9.5em}\begin{footnotesize}\renewcommand{\baselinestretch}{0.875}\begin{alltt}13 25
1111111111111111111111111
1000000110000110000110001
1000000110000110000110001
1000000110000110000110001
1000000110000110000110001
1000000110000111111110001
1000000110000111111110001
1111111110000110000110001
1111111110000110000110001
1000000110000111111110001
1000000110000111111110001
1000000110000110010110001
1111111111111111111111111\end{alltt}\end{footnotesize}\end{minipage}}

\vspace{0.375\baselineskip}

\mytextandpicture{Тест №16 (лівіший з двох прикладів). Руйнування однієї <<1>> по центру призводить до з’єднання \emph{відразу чотирьох} кімнат. Переконавшись у можливості такої ситуації, легко уявити і вхідні дані правішого з двох прикладів, де різні сусіди центральної одинички до того ж ще й з'єднані в одну кімнату, але десь далеко.}{\fbox{\begin{minipage}{4.25em}\begin{footnotesize}\renewcommand{\baselinestretch}{0.875}\begin{alltt}9 11
11111111111
10011011001
11001010011
11101010111
10100100101
11101010111
11001010011
10011011001
11111111111\end{alltt}\end{footnotesize}\end{minipage}}\fbox{\begin{minipage}{4.25em}\begin{footnotesize}\renewcommand{\baselinestretch}{0.875}\begin{alltt}9 11
11111111111
10011011001
11000010011
11101010111
10100100101
11101010111
11001010011
10011011001
11111111111\end{alltt}\end{footnotesize}\end{minipage}}}

Отже --- \emph{акуратно} реалізувати для кожної не~зовнішньої <<1>> перегляд \emph{усіх} сусідів-кімнат, додаючи площі \emph{усіх різних}.

Складність цього алгоритму теж $\Theta(NM)$. Але отой константний множник, яким нехтують у асимптотичних позначеннях, значно більший.





% % % \clearpage

\renewcommand{\thecontestname}{Олімпіади з інформатики (програмування)}
\renewcommand{\thecontestlocation}{Черкаська обл.}
\renewcommand{\thecontestdate}{2013--2015 роки}

% % % \renewcommand{\baselinestretch}{0.875}

% % % \end{sffamily}

\end{document}
