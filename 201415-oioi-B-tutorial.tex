\Tutorial	Ця задача, хоч і нескладна, потребує і~з'ясувати правило, за яким слід вибирати вагони, і~написати не~зовсім елементарну програму. 

{

\hyphenpenalty=400

% На олімпіадах з~інформатики (програмування) перевіряють лише, 
% чи~виводить програма, написана учасником, правильні відповіді 
% для конкретних тестових прикладів, не~вимагаючи від учасника 
% математичні доведення правильності цієї програми. Тому 
% придумати алгоритм важливіше, ніж побудувати доведення. Але, 
% не~вміючи доводити, важко оцінювати правильність ідей, 
% вирішувати, чи~реалізувати ідею, що вже спала на думку, чи~
% краще придумати щось інше. Особливо на тих олімпіадах, де не~
% можна багатократно відсилати розв’язки й швидко отримувати 
% вердикти перевіряючої системи. І~навіть якщо можна, але 
% отримано вердикт <<Неправильна відповідь>>\nolinebreak[3] --- 
% треба прийняти рішення, чи\nolinebreak[3] шукати технічну 
% помилку, чи\nolinebreak[3] повністю відкинути дану ідею й 
% шукати іншу. Тому приділимо увагу власне процесу доведення. 

}

Тож правило\nolinebreak[3] --- \textsl{<<Щоразу вибирати (ще\nolinebreak[3] не\nolinebreak[3] вибраний) вагон з мінімальною кількістю коробок, доки\nolinebreak[3] не\nolinebreak[3] вичерпається вантажопідйомність корабля або не будуть задіяні всі вагони>>}.

\emph{Доведемо}, що це дійсно дасть максимальну кількість вагонів. (Чи~займатися взагалі такими доведеннями\nolinebreak[3] --- залежить від багатьох обставин. З~одного боку, вони не~вимагаються та не~оцінюються. З~іншого\nolinebreak[3] --- не~вміючи доводити, важко оцінювати правильність ідей, а\nolinebreak[3] написання програми на основі неправильної ідеї може забрати час і принести дуже мало балів.) 

Довести можна за такою (типовою, тобто її аналоги придатні у багатьох ситуаціях) схемою: \textsl{<<Припустимо, ніби замість вагона з мінімальною кількістю коробок взяли вагон з деякою більшою кількістю. Це\nolinebreak[3] збільшило кількість розвантажених вагонів так\nolinebreak[3] с\'{а}мо\nolinebreak[1] на~1, якби взяли вагон з мінімальною кількістю, а\nolinebreak[3] залишок вантажопідйомності корабля зменшило сильніше. Отже, ніякого виграшу від того, щоб брати вагон з немімінальною кількістю коробок,\nolinebreak[1] \mbox{нема}>>.} 

% Ні\nolinebreak[3] ці\nolinebreak[2] правила, ні\nolinebreak[3] це
% \nolinebreak[2] доведення не\nolinebreak[2] враховують природне 
% бажання відправити кораблем якомога більше коробок; але це питання 
% більше до умови задачі, чим\nolinebreak[1] до\nolinebreak[2] р\'
% озв'язку. Яку задачу задали, таку й вирішено\dots

Сформульовані правила\nolinebreak[3] --- ще\nolinebreak[2] не\nolinebreak[3] зовсім алгоритм.\linebreak[1] Є\nolinebreak[3] мінімум два способи подальшого їх уточнення (\emph{як\nolinebreak[3] с\'{а}ме \textsl{<<вибирати (ще\nolinebreak[3] не\nolinebreak[3] вибраний) вагон з мінімальною кількістю коробок>>}?}).

Можна застосувати сортування (воно~ж упорядкування), після нього це будуть просто елементи масива по\nolinebreak[3] порядку. Особливо зручно, якщо писати мовою програмування, де\nolinebreak[2] існує готове бібліотечне сортування (наприклад, у\nolinebreak[3] реалізації \verb"ideone.com/sElRrj" використано функцію \verb"sort" бібліотеки \verb"algorithm" мови\nolinebreak[3] C++). Та й якщо писати сортування самому, все одно є деяка зручність у тому, щоб окремо написати та ретельно вивірити правильність стандартної задачі сортування, окремо решту дій.

Можна багатократно проходити по усьому масиву, вибираючи мінімальний елемент, і\nolinebreak[3] після кожного такого проходу враховувати знайдений елемент та заміняти його на якесь велике значення, щоб не~знаходити повторно. Втім, особливих переваг цей спосіб не~має. Зокрема, заявка <<він швидший, бо не~сортує усі елементи, а вибирає лише стільки, скільки треба>> не~витримує критики, бо за умови ефективного алгоритму сортування перший спосіб у~середньому значно швидший.
