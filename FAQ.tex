\section{Огляд особливостей <<олімпіадного>> та <<алгоритмічного>> програмування}
\label{sec:FAQ}

\MyParagraph{Який формат задач?}
На олімпіаді з~інформатики (не~інформаційних технологій, а~інформатики; пишуть також <<інформатики (програмування)>>) учасник отримує текстові задачі, розв'язком кожної з яких повинна бути програма мовою програмування, що читає вхідні дані (з\nolinebreak[3] клавіатури чи текстового файлу), обробляє їх згідно умови задачі та виводить результат (на\nolinebreak[3] екран чи у\nolinebreak[3] текстовий файл). В\nolinebreak[3] принципі існують деякі інші формати, але реально вони рідко трапляються. <<Міркування на\nolinebreak[3] тему>>, виражені словесно, не\nolinebreak[3] приймаються і не\nolinebreak[3] перевіряються ще з\nolinebreak[3] кінця \mbox{1990-х}~рр.

\MyParagraph{Звідки беруться оцінки, проміжні між 0 і максимумом за задачу?}
Як\nolinebreak[3] правило, кожна задача перевіряється за\nolinebreak[3] допомогою \emph{тестів}. Це\nolinebreak[2] розроблена (автором або журі) сукупність прикладів, кожен з\nolinebreak[1] яких\nolinebreak[3] --- вхідні дані й відповідна їм правильна відповідь. Кожен розв'язок кожного учасника запускається на усіх цих прикладах, і за ті з них, де програма вивела правильний результат, уклавшись у обмеження часу та пам'яті, нараховуються бали. 

Бувають програми, які дають іноді правильні відповіді, іноді неправильні. Бувають правильні, але неефективні програми, які частину тестів проходять (отримуючи бали), а\nolinebreak[2] на\nolinebreak[2] решті отримують замість балів вердикт <<Перевищено час роботи>>. І~так далі. Звідси й різні бали. 

У~цього способу оцінювання є недоліки. Наприклад, описані на\nolinebreak[2] стор.~\pageref{text:log-cube-how-to-get-part-of-points-easily} засоби набрати частину балів за задачу <<Логічний куб>> можна сприймати як нечесні. Але коли учасники розуміють систему оцінювання, а\nolinebreak[3] розробник тестів дбає, щоб відсоток балів за надто прості неповні розв'язки був не\nolinebreak[3] таким великим\nolinebreak[3] --- ці\nolinebreak[3] недоліки нівелюються. Крім того, поки\nolinebreak[3] що нема кращого способу проводити \emph{автоматичну} перевірку. Яка все-таки і\nolinebreak[3] швидка, і\nolinebreak[3] вільна від недоліків, подібних до <<член журі неправильно прочитав почерк учасника>>.

У\nolinebreak[3] деяких задачах можливі різні правильні відповіді. Скажімо, у\nolinebreak[3] тому~ж <<Логічному кубі>> слід виводити мінімальний шлях, і\nolinebreak[3] різні шляхи (послідовності вершин) можуть мати однакову мінімальну довжину. На\nolinebreak[3] якісно підготовленій олімпіаді для таких задач пишуть т.~зв.\nolinebreak[1] \emph{чекери} (\emph{checkers}), які перевіряють відповідь програми учасника по\nolinebreak[3] смислу. Чекери пишуть автори задач або члени журі, а\nolinebreak[3] не\nolinebreak[3] учасники, тож кому цікаво\nolinebreak[3] --- шукайте деталі самостійно (зокрема, на\nolinebreak[1] \verb"codeforces.com"), кому ні\nolinebreak[3] --- можна обмежитися правилом, що у\nolinebreak[3] таких ситуаціях треба виводити будь-яку одну правильну відповідь.

\MyParagraph{Чи можна здавати багато розв'язків однієї задачі?} Наразі на Всеукраїнській олімпіаді з~інформатики учасники можуть багатократно здавати свої розв'язки у перевіряючу систему, взнавати результати (тривалість перевірки\nolinebreak[3] --- від кількох секунд до кількох хвилин), і\nolinebreak[2] з\nolinebreak[3] усіх спроб автоматично вибирається найкращий результат. Обмеження на\nolinebreak[3] кількість спроб здачі існують, але лояльні (як-то <<до~60 на\nolinebreak[3] учасника сумарно по всім задачам>>). 

Інша справа, що правила не\nolinebreak[3] завжди були такими (на\nolinebreak[2] IV\nolinebreak[3] (фінальному) етапі вони такі з\nolinebreak[3] 2012~р., на\nolinebreak[2] III\nolinebreak[3] (обласному)\nolinebreak[3] --- з\nolinebreak[3] 2013~р.), й невідомо, як\nolinebreak[3] довго вони будуть такими. Існує точка зору, що <<такі правила спонукають клацати замість думати>>, тож на деяких інших змаганнях з~інформатики (програмування) залишили <<старий, але правильніший>> формат, коли перевірка на\nolinebreak[2] \emph{повному} наборі тестів відбувається \emph{після} туру, а\nolinebreak[3] під час туру учасник взна\'{є} лише, чи\nolinebreak[3] проходить його програма всього кілька тестів. Є\nolinebreak[3] й\nolinebreak[3] системи оцінювання, коли зайві спроби здачі можливі, але якось <<штрафуються>>. Краще уточнювати такі моменти перед туром.

\MyParagraph{Які допустимі мови програмування?}
Згідно Правил Всеукраїнської олімпіади з~інформатики --- C++, C, Pascal. Сервер Черкаського\nolinebreak[2] ОІПОПП \verb"ejudge.ckipo.edu.ua" їх підтримує (С++\nolinebreak[2] --- як\nolinebreak[3] \verb"g++", C\nolinebreak[3] ---\nolinebreak[2] \verb"gcc", Pascal\nolinebreak[3] --- \texttt{Free\nolinebreak[1] Pascal}). Фактично на \verb"ejudge.ckipo.edu.ua" наявні також Python, Java, Perl, mono~C\#, Free\nolinebreak[1] Basic, і\nolinebreak[3] на більшості олімпіад, що\nolinebreak[3] відбуваються на\nolinebreak[3] даному сервері, якщо учасник хоче\nolinebreak[3] --- може здавати на\nolinebreak[3] них, отримані бали враховуються, але адміністрація серверу та журі туру \emph{не}~несуть відповідальності та \emph{не}~приймають претензій, якщо виявиться, що деякі задачі деякими з не~рекомендованих мов не~можуть бути розв'язані на повні бали, бо, наприклад, навіть найкращий алгоритм не\nolinebreak[3] на\nolinebreak[3] всіх тестах вкладається у\nolinebreak[3] обмеження часу чи пам'яті. (Для C++, C, Pascal така відповідальність~є.)

Коли у тексті даного збірника згадується, що якусь частину задачі на Паскалі треба писати самому, а\nolinebreak[3] на\nolinebreak[3] C++ можна використати готову бібліотечну функцію\nolinebreak[3] --- часто (але\nolinebreak[3] не\nolinebreak[3] завжди) подібна функція є також і в мовах Python та Java. Так\nolinebreak[3] що знання цих мов (якщо, звісно, вони доступні на конкретному потрібному турі) все~ж може розширити можливості учасника.

\MyParagraph{Чому нема Delphi?}\label{text:notes-about-delphi-mode} Зі <<справжнім>> Delphi є і\nolinebreak[3] проблема ліцензійної чистоти, і\nolinebreak[3] складнощі взаємодії  перевіряючої системи ejudge, що\nolinebreak[1] працює під OS\nolinebreak[3] Linux, з Windows-програмами.
Як\nolinebreak[3] компроміс, у\nolinebreak[3] переліку мов \verb"ejudge."\linebreak[0]\verb"ckipo."\linebreak[1]\verb"edu.ua" є варіант <<Free\nolinebreak[1] Pascal\nolinebreak[3] --- Delphi\nolinebreak[1] mode>>. Він підключає деякі (не~всі) <<дельфійські>> особливості (\verb"integer" 32-бітовий; \verb"string" дозволяє рядки, довші~255; функції містять спеціальну змінну\nolinebreak[2] \verb"Result";~\dots). До\nolinebreak[3] речі, цей режим % часткової сумісності 
можна увімкнути і зсер\'{е}\-дини своєї програми: написати \verb"{$mode delphi}" (замість \verb"{$APPTYPE CONSOLE}") і здати під\nolinebreak[1] Free\nolinebreak[1] Pascal.


\MyParagraph{Чи потрібно доводити правильність алгоритмів?}
\label{text:need-or-no-need-to-prove}
Залежить від обставин. З~одного боку, доведення не~вимагаються та не~оцінюються. З~іншого\nolinebreak[3] --- не~вміючи доводити, важко оцінювати правильність ідей. Якщо програма видає неправильну відповідь, треба якось приймати рішення, чи\nolinebreak[3] шукати й виправляти технічну помилку, чи\nolinebreak[3] повністю відкинути дану ідею й шукати іншу. У\nolinebreak[3] цьому смислі доведення бувають  корисні, навіть якщо робити їх виключно для себе. Приклади доведень можна бачити на~стор.~\pageref{text:proof-example-parket-1},~\pageref{text:proof-example-train-to-ship},~\pageref{text:proof-max-num-by-strike-out-one-digit}.



\renewcommand{\floatpagefraction}{0.625}

\MyParagraph{Що означають записи, подібні до <<$O(N^2)$>>?} Деталі можна знайти в\nolinebreak[3] Інтернеті чи літературі за\nolinebreak[1] назвою \emph{асимптотичні позначення $O$, $o$, $\Omega$, $\omega$,~$\Theta$}; <<$O$>>\nolinebreak[2] та\nolinebreak[2] <<$o$>> нерідко читають <<o>> (одним звуком), але правильніше <<омікрон>>; <<$\Omega$>>\nolinebreak[2] та\nolinebreak[2] <<$\omega$>>\nolinebreak[3] --- <<омега>> (велика й маленька); <<$\Theta$>>\nolinebreak[3] ---\nolinebreak[2] <<тета>>. Формальні означення складнуваті, наприклад один з\nolinebreak[3] варіантів означення~$O$ такий: $f(n)$ являє собою $O(g(n))$, коли існує \mbox{деяка}\nolinebreak[3] $f_1(n)$, така, що виконуються обидва твердження <<для\nolinebreak[1] всіх~$n$, $f(n)\<f_1(n)$>> та <<$\displaystyle\lim_{n\to\infty}\frac{f_1(n)}{g(n)}=c$, де\nolinebreak[2] $c$\nolinebreak[3] --- скінч\'{е}нне число>> (можна велике, але конкретне, щоб воно \emph{не}\nolinebreak[3] зростало при ${n\to\infty}$).

Простіше (не\nolinebreak[2] зовсім точне) пояснення: нехай нас цікавить, наскільки стрімко зростає функція $2n^2\dib{{+}}17n\dib{{+}}12\sqrt{n}\dib{{+}}500$ при $n{\to}\infty$. При дуже великих~$n$, доданок $2n^2$ значно перевищує всі інші разом узяті, тож можна приблизно оцінювати всю суму самим лише~$2n^2$. Підемо ще\nolinebreak[2] далі й скажемо, що нас не\nolinebreak[3] цікавить, 
чи\nolinebreak[3] $2n^2$,
чи\nolinebreak[3] $7n^2$,
чи\nolinebreak[3] $\frac{1}{6}n^2$\nolinebreak[3] --- головне, що коефіціент при~$n^2$ є скінч\'{е}нним строго додатним числом. Оце й показує, що як $2n^2\dib{{+}}17n\dib{{+}}12\sqrt{n}\dib{{+}}500$,\linebreak[1]
так\nolinebreak[2] і\nolinebreak[1] $7n^2$,
так\nolinebreak[2] і\nolinebreak[1] $\frac{1}{6}n^2\dib{{+}}100n\sqrt{n}\dib{{+}}12345$
являють собою $O(n^2)$ та~$\Theta(n^2)$.
Відмінність між $O$ і~$\Theta$ у\nolinebreak[3] т\'{о}му, що $O(g(n))$ дозволяє, щоб досліджувана функція була хоч <<дуже\nolinebreak[2] приблизно рівною>>~$g(n)$ (у\nolinebreak[3] щойно описаному смислі), хоч значно меншою,\linebreak[1] а\nolinebreak[1] $\Theta(g(n))$\nolinebreak[3] --- \emph{лише} <<дуже приблизно рівна>>. Наприклад, $2n\sqrt{n}\dib{{+}}17n$ можна вважати хоч\nolinebreak[2] ${O(n\sqrt{n})}$, хоч\nolinebreak[2] ${O(n^2)}$, хоч\nolinebreak[2] ${\Theta(n\sqrt{n})}$, але\nolinebreak[2] не\nolinebreak[2] ${\Theta(n^2)}$.

\begin{figure}[!b]
\begin{center}
\begin{minipage}{0.99\textwidth}
\vspace*{-0.5\baselineskip}
\hrulefill
\vspace*{-0.75\baselineskip}

\renewcommand{\baselinestretch}{1}
\begin{small}
\begin{alltt}
  for i:=2 to N do begin
    curr := A[i];
    j := i-1;
    while (j>0) and (A[j]>curr) do begin
      A[j+1] := A[j];                   \raisebox{0pt}[0pt][0pt]{\begin{math}\left.\vphantom{\begin{array}{c}a\\a\\a\\a\\a\end{array}}\right\}\end{math}} {\begin{math}O\end{math}(i), а також \begin{math}O\end{math}(n)}
      dec(j);         \raisebox{0.5\baselineskip}[0pt][0pt]{\begin{math}\left.\vphantom{\begin{array}{c}a\\a\end{array}}\right\}\end{math}} \raisebox{0.5\baselineskip}[0pt][0pt]{\begin{math}\Theta\end{math}(1)}
    end;
    A[j+1] := curr;
  end;
\end{alltt}
\vspace*{-\baselineskip}
\end{small}

\begin{small}
Сумарно буде $\Theta(n)$ разів по $O(n)$, тобто $O(n^2)$.
До\nolinebreak[3] речі, це $O(n^2)$ неможливо перетворити у $\Theta$ від чого б не було: при деяких вхідних даних (наприклад, уж\'{е} відсортованих) маємо $\Theta(n)$ разів по $\Theta(1)$, тобто $\Theta(n)$; при деяких інших --- $\Theta(n)$ разів по $\Theta(i)$, які, враховуючи $1\dib{{+}}2\dib{{+}}\dots\dib{{+}}n\dib{{=}}\frac{n(n+1)}{2}$, кінець кінцем перетворюються у~$\Theta(n^2)$.

\end{small}
\end{minipage}
\end{center}
\caption{Приклад проведення асимптотичного аналізу фрагменту програми}
\label{fig:example-of-asympthotic analysis}
\end{figure}

Навіщо все це програмісту? Бо саме так зручно оцінювати залежність часу роб\'{о}ти програми від розміру вхідних даних. Кількість тактів CPU, потрібних для обчислення деякого виразу, залежить від моделі CPU та від того, чи\nolinebreak[3] поміщаються дані у\nolinebreak[3] кеші, й\nolinebreak[3] усе це аналізувати дуже складно. Але\nolinebreak[3] можна ігнорувати ці складнощі, заявляючи, що будь-який фрагмент програми, який не\nolinebreak[3] містить циклів чи\nolinebreak[3] викликів підпрограм, працює\nolinebreak[1] за~$\Theta(1)$.
Приклад такого аналізу (для алгоритму сортування вставками) наведено на\nolinebreak[3] рис.~\ref{fig:example-of-asympthotic analysis}.

Як потім використати отримані асимптотичні оцінки? Порівнювати ефективність алгоритмів (для чого не\nolinebreak[3] завжди треба реалізовувати\nolinebreak[3] їх, часто досить уявити структуру циклів). А\nolinebreak[3] також оцінювати шанси алгоритму поміститись у такі-то обмеження часу при обробці вхідних даних таких-то розмірів.

Тактова частота сучасних комп'ютерів\nolinebreak[3] --- кілька гігагерц (мільярдів тактів за секунду). Враховуючи неточності у\nolinebreak[3] питанні <<скільки тактів займають які дії>> та ігнорування констант у сам\'{и}х означеннях $O$ чи~$\Theta$, ці <<кілька мільярдів>> треба ще поділити (причому не~ясно, на\nolinebreak[3] скільки), й\nolinebreak[1] у\nolinebreak[3] висновку виходить щось дуже приблизне <<за\nolinebreak[3] секунду встигається десь $10^7$--$10^9$ дій>>. Але навіть настільки приблизні оцінки можуть бути корисні. 
\label{text:first-example-how-to-see-algo-will-not-fit-in-time-limit}
Наприклад: $N{=}10^8$, складність алгоритму\nolinebreak[3] $\Theta(N^2)$. $(10^8)^2\dib{{=}}10^{16}$, час роботи від\nolinebreak[2] $10^{16}/10^9\dib{{=}}10^7$~сек\nolinebreak[2] ($\approx$4~місяці)\linebreak[1] до\nolinebreak[1] $10^{16}/10^7\dib{{=}}10^9$~сек\nolinebreak[2] ($\approx$30~років)\nolinebreak[3] --- безнадійно далеко від того, щоб укластись у пару секунд. Або:\nolinebreak[3] при\nolinebreak[2] $N{=}10^5$ алгоритм складністю\nolinebreak[3] $O(N\sqrt{N})$ $({10^5{\cdot}\sqrt{10^5}}\dib{{\approx}}{3{,}2{\cdot}10^7})$ має шанси вкластися у\nolinebreak[3] секунду, але впритирку, можуть бути важливі всілякі оптимізації у\nolinebreak[3] дрібницях.

Звісно, можна вимірювати час і по-простому в мілісекундах. Автоматичні перевіряючі системи (включаючи ejudge) с\'{а}ме по-простому в мілісекундах і міряють. Ці\nolinebreak[3] способи не~заважають один \'{о}дному, а~доповнюють.



\MyParagraph{Що таке діапазон (цілочисельного) типу? Переповнення типу?}

\myflfigaw{\raisebox{-9pt}[0pt][0pt]{\begin{tabular}{|c|c|}\hline\raisebox{-9pt}[9pt][9pt]{\begin{mfpic}[12]{0.75}{5}{0}{2}
\tlabel[cc](1,1){0}
\tlabel[cc](2,1){2}
\tlabel[bc](3,1.1){3}
\tlabel[tc](3,0.9){4}
\tlabel[bc](4,1.1){9}
\tlabel[tc](4,0.9){0}
\gclear\rect{(0.75,1.625),(4.75,2)}
\gclear\rect{(0.75,0.375),(4.75,0)}
\arrow\lines{(4.75,0.5),(4.75,1.5)}
\pen{1mm}
\arrow[l5]\lines{(4.75,0.5),(4.75,1.5)}
\end{mfpic}}
&
\raisebox{-9pt}[9pt][9pt]{\begin{mfpic}[12]{0.75}{5}{0}{2}
\tlabel[bc](1,1.1){9}
\tlabel[tc](1,0.9){0}
\tlabel[bc](2,1.1){9}
\tlabel[tc](2,0.9){0}
\tlabel[bc](3,1.1){9}
\tlabel[tc](3,0.9){0}
\tlabel[bc](4,1.1){9}
\tlabel[tc](4,0.9){0}
\gclear\rect{(0.75,1.625),(4.75,2)}
\gclear\rect{(0.75,0.375),(4.75,0)}
\pen{1mm}
\arrow[l5]\lines{(4.75,0.5),(4.75,1.5)}
\end{mfpic}}\\\hline\end{tabular}}}

Уявіть лічильник електроенергії (чи\nolinebreak[3] води, чи\nolinebreak[2] кілометрів\nolinebreak[3] --- байдуже). Кожен десятковий розряд відобра\-жа\-ється окремим барабаном, при завершенні значень одного відбувається збільшення наступного\dots{} й\nolinebreak[3] у\nolinebreak[3] деякий момент не\nolinebreak[3] вистачає розрядів, і\nolinebreak[3] після великого числ\'{а} настає~0. Це\nolinebreak[1] і\nolinebreak[1] є \emph{переповнення} (\emph{overflow}).
У\nolinebreak[3] комп'ютері не\nolinebreak[3] барабани (і\nolinebreak[3] не\nolinebreak[3] буває зображених на\nolinebreak[3] рисунку проміжних станів), але\nolinebreak[2] теж скінч\'{е}нна кількість розрядів. Тільки розряди двійкові, а\nolinebreak[3] не\nolinebreak[3] десяткові, тому переповнення настає не\nolinebreak[3] після\nolinebreak[1] 9999 чи\nolinebreak[1] 999999, а\nolinebreak[3] після чисел вигляду $2^k{-}1$ (де\nolinebreak[3] $k$\nolinebreak[3] --- кількість бітів), тобто, у\nolinebreak[3] двійковому поданні, $\underbrace{11\dots1}_{k\textnormal{ штук}}$. Звідси, діапазон беззнакових типів\nolinebreak[3] --- від\nolinebreak[2] 0 до\nolinebreak[2] ${2^k{-}1}$ (тут і далі обидві межі включно). Знакові типи мають діапазон від $-2^{k{-}1}$ до\nolinebreak[2] ${2^{k{-}1}{-}1}$ (кому цікаво, звідки така несиметричність, див.\nolinebreak[1] \verb"uk.wikipedia."\linebreak[0]\verb"org/"\linebreak[0]\verb"wiki/"\linebreak[0]\verb"Доповняльний_код"). 

\label{text:overflow-example}
Наприклад, при спробі обчислити у\nolinebreak[3] 16\nolinebreak[3] бітах $1000_{Dec}{\*}100_{Dec}\dib{{=}}100000_{Dec}\dib{{=}}11000011010100000_{Bin}$ (<<$_{Dec}$>> означає десяткову систему, <<$_{Bin}$>>\nolinebreak[3] --- двійкову) фактично буде отримано лише 16 останніх бітів $1000011010100000_{Bin}$, котрі у\nolinebreak[3] беззнаковому типі задають число $34464_{Dec}$, а\nolinebreak[2] у\nolinebreak[2] знаковому\nolinebreak[3] --- $({-}31072_{Dec})$. 

Окремо відзначимо вирази, подібні до \texttt{c:=a*b}, де\nolinebreak[3] \texttt{a} та\nolinebreak[3] \texttt{b} мають вужчий тип, \texttt{c}\nolinebreak[3] --- ширший, і\nolinebreak[3] результат поміщається у\nolinebreak[2] ширший тип, але\nolinebreak[3] не\nolinebreak[2] у\nolinebreak[3] вужчий. Чи\nolinebreak[3] результат буде обчислений правильно у\nolinebreak[3] ширшому типі, чи\nolinebreak[2] з\nolinebreak[3] переповненням у\nolinebreak[3] вужчому\nolinebreak[3] --- залежить від багатьох обставин. Можна вивч\'{а}ти ті обставини, й такі знання бувають корисними. Можна в\nolinebreak[3] усіх сумнівних ситуаціях робити \emph{приведення типів} (\emph{type\-casting}), наприклад \texttt{c:=int64(a)*int64(b)}.

Можна знайти таблички з точними діапазонами (напр., \verb"www.freepascal."\linebreak[0]\verb"org/"\linebreak[1]\verb"docs-html/"\linebreak[0]\verb"ref/"\linebreak[0]\verb"refsu5.html"). Але до них слід ставитися обережно, бо ці діапазони можуть залежати від архітектури <<заліза>>, операційної системи та компілятора. Скажімо, у\nolinebreak[1] \verb"en.cppreference."\linebreak[0]\verb"com/"\linebreak[1]\verb"w/cpp/"\linebreak[0]\verb"language/"\linebreak[0]\verb"types" часто говориться <<at~least>>, тобто може бути й більше.

Найсумніше, коли типи з\nolinebreak[3] однаковими назвами мають різну розрядність на локальному комп'ютері, де пише учасник, і на сервері, де відбувається перевірка. Зокрема (але\nolinebreak[1] не\nolinebreak[1] тільки), така проблема виникає, коли учасник локально пише під Delphi чи PascalABC, а\nolinebreak[1] здає під Free\nolinebreak[1] Pascal, який наразі при відсут\-ності додаткових вказівок вважає \texttt{integer} 16-\nolinebreak[1]бітовим (директива \verb"{$mode delphi}" робить \texttt{integer} 32-\nolinebreak[1]бітовим; див.\nolinebreak[2] також стор.~\pageref{text:notes-about-delphi-mode}).


% % % У\nolinebreak[3] більшості випадків варто просто бр\'{а}ти тип <<дещо з~запасом
% % % >>. Якщо так чинити не\nolinebreak[3] вдається, можна взнавати розмір типу 
% % % через функцію \texttt{sizeof} (яка вертає значення у\nolinebreak[3] байтах, а
% % % \nolinebreak[3] не\nolinebreak[3] бітах, тому $2^k$ чи $2^{k{-}1}$ міняється на 
% % % $2^{8{\cdot}\texttt{sizeof}}$ чи $2^{(8{\cdot}\texttt{sizeof})-1}$ відповідно). 
% % % Тільки тут  легко взнати, що вертає \texttt{sizeof} локально (на\nolinebreak[3] 
% % % тому комп'єютері, де\nolinebreak[3] пишемо); \emph{нема} гарантій, чи так
% % % \nolinebreak[2] с\'{а}мо буде й на сервері, де відбувається перевірка. Як
% % % \nolinebreak[3] крайні (насправді рідко потрібні) засоби\nolinebreak[3] --- (а)~
% % % пробувати питати прямим тектом у\nolinebreak[3] журі; (б)~витратити кілька 
% % % спроб здачі виключно на те, щоб з'ясувати\nolinebreak[3] це. (Як? Творчо 
% % % розвиваючи такий помірно брудний прийом: коли вже є програма, яка проходить хоч 
% % % якісь тести, поміняємо її виведення на \texttt{if \mbox{sizeof(integer)<4} then 
% % % writeln(\dots<щось геть не те>\dots) else writeln(\dots<те що набирало хоч 
% % % якісь бали>\dots)}; якщо результат роботи програми змінився\nolinebreak[3] --- 
% % % значить,\nolinebreak[3] \texttt{\mbox{sizeof(integer)<4}}. Цей прийом буває 
% % % корисним і в\nolinebreak[3] інших ситуаціях, але не\nolinebreak[3] варто ним 
% % % зловживати: можна вичерпати усі спроби здачі, а\nolinebreak[3] якщо журі 
% % % вирішить, що ці спроби дестабілізують роботу перевіряючої системи, можна 
% % % отримати дискваліфікацію.)



\MyParagraph{Формат з плаваючою комою (floating point) та похибка}\label{sec:floating-point}
Є експоненційний формат виведення дробових чисел: наприклад, \texttt{1.234e2} означає ${1{,}234{\cdot}10^2}\dib{{=}}123{,}4$; частина після~<<\texttt{E}>> називається \emph{порядок}; власне цифри до~<<\texttt{E}>>\nolinebreak[3] --- \emph{мантиса}. У~пам'яті зберігається теж експоненційний формат, але двійковий. Розрядні сітки як у порядку, так і в мантиси обмежені.

Обмеженість порядку критична для дуже великих чи дуже близьких до~0 чисел. Наприклад,  \texttt{double}, реалізований згідно IEEE~754, не\nolinebreak[3] може містити значення, модуль яких більший $10^{307}$ або менший $10^{-324}$ (нуль можливий; немож\-ливі значення між\nolinebreak[3] 0\nolinebreak[1] і~$10^{-324}$).
Обмеженість же мантиси призводить до \emph{втрати точності} або \emph{похибки}\nolinebreak[3] --- наприклад, неможливості розрізнити у\nolinebreak[2] типі \texttt{double} $1{,}0000000000000001_{Dec}$ від~1 (або $1{,}0000000000000001{\cdot}10^{-9}$ від\nolinebreak[2] $10^{-9}$, або $1{,}0000000000000001{\cdot}10^{98}$ від\nolinebreak[2] $10^{98}$\nolinebreak[3] --- важливий не\nolinebreak[3] порядок, 
а\nolinebreak[3] те, що цифри, якими ч\'{и}сла відрізняються, не~поміщаються у\nolinebreak[3] мантису.
% а\nolinebreak[3] факт, що цифри не~поміщаються у\nolinebreak[3] розрядність мантиси).

В\nolinebreak[3] інших типах конкретні діапазони можуть бути іншими; але суть двох обмежень однакова в усіх типах з плаваючою комою. 
Як\nolinebreak[3] правило (крім ситуацій, коли треба жорстко економити пам'ять) найкращим є тип \texttt{extended} (Pascal), він\nolinebreak[3] же \texttt{long\nolinebreak[2] double}, бо для більшості поєднань <<заліза>>, OS та компілятора він і\nolinebreak[3] забезпечує найкращу точність, і\nolinebreak[3] швидко працює. 

Проблема похибок загострюється тим, що у\nolinebreak[3] тексті програми та вхідних даних ч\'{и}сла пишуть у десятковій системі, а\nolinebreak[2] фактичне внутрішнє подання двійкове. 
Наприклад, програма \verb"ideone.com/rnGPEl" показує, що 10-\nolinebreak[2]кратне додавання \texttt{0.3} до\nolinebreak[2] (\texttt{-3}) \emph{не}~дає рівно~0. Адже $0{,}3_{Dec}$ стає нескін\-ч\'{е}н\-ним періодичним двійковим дробом $0{,}0(1001)_{Bin}$, обмеженість мантиси призводить до його заокруглення, і похибка з'являється у самій константі.\label{text:floating-point-error-in-0.3}

Дії над числами теж можуть призводити до утворення чи зростання похибки. Cильно роздувають похибку тригонометричні та інші складн\'{і} функції (але \verb"sqrt"\nolinebreak[1] якщо й збільшує, то не\nolinebreak[3] сильно; щодо цього \verb"sqrt(x)" набагато краща за \verb"power(x,0.5)"). А\nolinebreak[3] ще можуть сильно роздути похибку віднімання \verb"a-b" при\nolinebreak[2] ${a{\approx}b}$ та додавання \verb"a+b" при\nolinebreak[3] ${a{\approx}{-}b}$. Наприклад, для вагів, якими можна зважити людину, похибка $\pm$10~г дрібна; але якщо спробувати взнати масу аркуша паперу шляхом того, що хтось зважиться один раз, тримаючи цей аркуш у руках, потім ще\nolinebreak[3] раз без цього аркуша, й обчислить різницю вимірювань\nolinebreak[3] --- результат безнадійно втоне у похибці.
Приклад програми, де демонструється аналогічна втрата результату\nolinebreak[3] --- \verb"ideone.com/bKXT0z"\hspace{0.5em plus 1em}
Тому буває важливо провести аналітичні перетворення, щоб отримати математично еквівалентну формулу з меншим впливом похибок. 

\myflfigaw{\begin{tabular}{c|l}
$a=b$	&	\texttt{abs(a-b) < EPS} \\\hline
$a<b$	&	\texttt{a + EPS < b} \\\hline
$a\<b$	&	\texttt{a < b + EPS} \\\hline
$\vdots$&	$\qquad\vdots$
\end{tabular}}
Інший поширений прийом, який намагається нівелювати похибки\nolinebreak[3] --- не\nolinebreak[2] порівнювати ч\'{и}сла з плаваючою точкою <<по-простому>>, а\nolinebreak[3] лише з <<допуском на похибку>>, як у табличці праворуч.

<<\texttt{EPS}>> означає <<якесь маленьке число>>, його треба задати самому (наприклад, \texttt{const \mbox{EPS=1e-6}}). Як\nolinebreak[3] правильно вибирати \texttt{EPS}\nolinebreak[3] --- питання складн\'{е}. Буває легше йти не від того, якої величини можуть сягати похибки, а від того, наскільки близькими можуть бути значення, які треба розрізняти, й бр\'{а}ти \texttt{EPS} у кілька разів меншим\dots{} Іноді варто переписувати умови так, щоб враховувати не\nolinebreak[3] абсолютну, а\nolinebreak[3] відносну похибки\dots

Детальніше про floating point та похибки можна прочитати у багатьох місцях, зокрема \verb"habrahabr.ru/post/112953"\label{text:floating-point-end}

\MyParagraph{Щодо cin/cout та scanf/printf мовою\nolinebreak[3] C++}\label{text:io-streams-versus-scanf-printf}
Є такий сумний факт, що введення/\nolinebreak[2]виведення засобами \texttt{istream}/\nolinebreak[2]\texttt{ostream} (зокрема, \texttt{cin}/\nolinebreak[2]\texttt{cout}) працює повільно. Настільки повільно, що, наприклад, на\nolinebreak[2] ІІ~етапі 2013/14\nolinebreak[3] н.~р. у\nolinebreak[2] найбільшому тесті задачі <<Всюдисущі ч\'{и}сла>> (стор.~\mbox{\pageref{sec:omnipresent-numbers}--\pageref{text:omnipresent-numbers-end}}) саме лише читання\nolinebreak[1] \mbox{\verb"cin"-ом} вхідних даних, взагалі без обробки по~суті, вже перевищувало обмеження часу. Вихід\nolinebreak[3] --- читати функцією \texttt{scanf}, яка з незвички може здаватися незруч\-ною, зате швидко працює. Ще один спосіб зменшення проблеми (лише часткового зменшення, тобто його не~завжди достатньо)\nolinebreak[3] --- виклик \verb"cin.sync_with_stdio(false)", який трохи пришвидшує читання \verb"cin"-ом за рахунок вимикання синхронізації, тобто після цього не\nolinebreak[3] можна читати поперемінно то засобами \verb"cin", то засобами \verb"scanf".

А\nolinebreak[3] взагалі, є дуже вже багато моментів, коли C++ виграє у Паскаля; тож окремі ситуації, коли неграмотне використання~С++ призводить до результатів гірших, ніж Паскаль, можна вважати проявом справедливості\dots

Ще гострішою проблема швидкості читання є у мові Java, але то вже за\nolinebreak[3] межами даного посібника. Шукайте самостійно.\label{text:FAQ-end}


