\Tutorial	\MyParagraph{Як досить легко набрати частину балів}
Для самої лише підзадачі~D1 і часткового випадку <<всі кімнати мають прямокутну форму>> можна написати програму \verb"ideone.com/HHr9a3"\hspace{0.5em plus 1em}
Вона спирається на те, що у випадку прямокутності кімнат кожна кімната однозначно задається лівим верхнім кутом, а~перевіряти, чи~справді клітинка є таким кутом, можна умовою \texttt{\mbox{(data[i][j]='0')} \mbox{and} \mbox{(data[i-1][j]='1')} \mbox{and} \mbox{(data[i][j-1]='1')}}, тобто сама клітинка вільна, а ліворуч і згори стіни.

Очевидно (в~т.~ч. з\nolinebreak[3] \mbox{2-го}\nolinebreak[3] тесту з\nolinebreak[3] умови), що для <<закручених>> кімнат це може й не\nolinebreak[3] бути правдою. Але\nolinebreak[2] в\nolinebreak[3] умові обіцяно значну частину тестів з кімнатами прямокутної форми, тож при відсутності кращих ідей можна написати хоча~б такий розв’язок. Він набирає 26~балів (з~50 за усю~D1, зі~100 за усю~D).



\MyParagraph{Повний розв'язок підзадачі D1}
Для відстеження (як завгодно <<закручених>>) кімнат можна реалізувати будь-який з алгоритмів:

\begin{enumerate}

\item	
\emph{пошук ушир} (він же \emph{пошук у~ширину}); рос. \emph{поиск в ширину}, англ. \emph{breadth first search} (\emph{BFS});

\item
\emph{пошук углиб} (він же \emph{пошук у~глибину}); рос. \emph{поиск в глубину}, англ. \emph{depth first search} (\emph{DFS});

\item
різноманітні алгоритми графічної \emph{заливки} (\emph{flood fill}).

\end{enumerate}

Усі ці алгоритми неважко знайти в Інтернеті або в літературі самостійно, й усі вони надто громіздкі, щоб поянювати їх тут. І\nolinebreak[3] кожним із них можна реалізувати задачу зі складністю $\Theta(NM)$. Тільки для цього треба:
\begin{enumerate}
\item
Просто перебирати усі клітинки з\'{а}мку, і щоразу, знайшовши~0, запускати BFS/DFS/заливку, щоб повністю виділити відповідну кімнату, позамінявши її нулі на інші значення, та обчислити її розмір.
\item
Забезпечити, щоб кожен такий виклик BFS/DFS/заливки, котрому вказується, починаючи звідки дослідити кімнату, працював за час, пропорційний розміру цієї кімнати, а не усього замку.
\end{enumerate}

\myhrulefill

Часто вважають, що в такій ситуації найпростішою є рекурсивна реалізація пошуку вглиб. Частково це правда, але рекурсивний пошук углиб має потенційний недолік: пам'яті, потрібної для зберігання рекурсії у програмному стекові, може бути набагато менше, ніж пам'яті взагалі. Як~наслідок, рекурсивна реалізація DFS може завершуватися аварійно по причині \mbox{нестачі} пам'яті --- навіть при фактичних витратах пам'яті, менших, ніж у пошуку вшир або заливці. Стекова пам'ять може бути значно <<дефіцитнішою>>, й коли \emph{вона} закінчилася, наявність іншої пам'яті рекурсії не~допомагає.

С\'{а}ме \emph{може} бути. А~може бути й інакше. І~залежить це від налаштувань компілятора (керування якими доступне програмісту під час <<нормальної>> роботи, але як~правило не~доступне учаснику олімпіади). Конкретно на цій обласній олімпіаді було забезпечено досить великий розмір програмного стеку, тому можна було писати рекурсивний DFS і не~мати проблем; але біда в тому, що при інших налаштуваннях компілятора проблеми цілком можливі.







\MyParagraph{Підзадача D2}
Частину балів (орієнтовно до~20 з~50) можна отримати, розв’язуючи підзадачу~D1 багатократно (для абсолютно кожної <<1>> у внутрішній стіні, замінимо її на <<0>> і заново розв’яжемо~D1; серед усіх таких розв’язків виберемо максимальний). Але це має складність $O(M^2N^2)$, тож ні\'{я}к\nolinebreak[2] не\nolinebreak[3] може бути ефективним розв’язком для $M{\approx}N{\approx}1000$.

Перепишемо підзадачу~D1 так, щоб при підрахунку кількостей та розмірів кімнати не~просто виділялися, а \emph{різні кімнати} виділялися \emph{різними значеннями} (а~клітинки однієї кімнати\nolinebreak[3] --- однаковими). Наприклад, якщо це робити прямо у\nolinebreak[3] масиві з позначками <<0\nolinebreak[3] --- прохід, 1\nolinebreak[3] --- стіна>>, може вийти так:

\noindent\begin{minipage}{\textwidth}
\begin{exampleSimpleThreeWithSpecNameColTwo}{6em}{12em}{13em}{Виділені кімнати}{Масив з розмірами кімнат}%
\exmp{9 12
111111111111
101001000001
111001011111
100101000001
100011111101
100001000101
111111010101
100000010001
111111111111}{~
1 1 1 1 1 1 1 1 1 1 1 1
1 2 1 3 3 1 4 4 4 4 4 1
1 1 1 3 3 1 4 1 1 1 1 1
1 5 5 1 3 1 4 4 4 4 4 1
1 5 5 5 1 1 1 1 1 1 4 1
1 5 5 5 5 1 4 4 4 1 4 1
1 1 1 1 1 1 4 1 4 1 4 1
1 4 4 4 4 4 4 1 4 4 4 1
1 1 1 1 1 1 1 1 1 1 1 1}{\raisebox{-12pt}{\begin{rmfamily}\begin{tabular}{@{}r|ccccc}індекс & \dots &2&3&4&5\\\hline{}значення & \dots&1&5&28&9\end{tabular}\end{rmfamily}}}%
\end{exampleSimpleThreeWithSpecNameColTwo}
\end{minipage}

Якщо при цьому ще й зберігати розміри кімнат у масиві (так, щоб індексами масиву були ті самі ч\'{и}сла, якими позначено кімнати), то для визначення, яка вийде площа кімнати після руйнування деякої стіни, можна просто додати до одинички (площі самої зруйнованої стіни) площі кімнат-сусідів. Так що перебір усіх можливих <<1>> (у не-зовнішніх стінах) можна залишити, бо тепер для кожної такої <<1>> треба робити значно менше дій.

Здається <<логічним>> (і~приклади з умови це <<підтверджують>>), ніби максимальна кімната буде утворена за рахунок об’єднання двох кімнат. Але насправді % подібним <<висновкам>> місце на~смітнику, бо 
це лише поширений випадок, а\nolinebreak[3] не\nolinebreak[3] обов’язкова властивість: замість \mbox{2-х} може бути будь-яке число від~1 до~4 (див.\nolinebreak[2] приклади). Тому  краще, не~роблячи необґрунтованих припущень, акуратно реалізувати для кожної не~зовнішньої\nolinebreak[3] <<1>> перегляд усіх сусідів-кімнат, додаючи площі усіх різних.

\vspace{0.375\baselineskip}

\mytextandpicture{Тест №9. Більшість внутрішніх стін <<товсті>>, тож вилучення \emph{однієї} <<1>> зазвичай не\nolinebreak[3] призводить до з'єднання кімнат. А\nolinebreak[3] в\nolinebreak[3] тому єдиному місці, де призводить (\mbox{2-й}\nolinebreak[3] знизу рядок)\nolinebreak[3] --- утворюється кімната площею $2\dib{{+}}1\dib{{+}}1\dib{{=}}4$.
Набагато більшу площу $44\dib{{+}}1\dib{{=}}45$ можна отримати, зруйнувавши будь-яку (не~зовнішню) стіну кімнати площі~44, утворивши <<нішу>> замість <<проходу>>.}{\begin{minipage}{9.5em}\begin{footnotesize}\renewcommand{\baselinestretch}{0.875}\begin{alltt}13 25
1111111111111111111111111
1000000110000110000110001
1000000110000110000110001
1000000110000110000110001
1000000110000110000110001
1000000110000111111110001
1000000110000111111110001
1111111110000110000110001
1111111110000110000110001
1000000110000111111110001
1000000110000111111110001
1000000110000110010110001
1111111111111111111111111\end{alltt}\end{footnotesize}\end{minipage}}

\vspace{0.375\baselineskip}

\mytextandpicture{Тест №16 (лівіший з двох прикладів). Руйнування однієї <<1>> по центру призводить до з’єднання \emph{відразу чотирьох} кімнат. Переконавшись у можливості такої ситуації, легко уявити і вхідні дані правішого з двох прикладів, де різні сусіди центральної одинички до того ж ще й з'єднані в одну кімнату, але десь далеко.}{\fbox{\begin{minipage}{4.25em}\begin{footnotesize}\renewcommand{\baselinestretch}{0.875}\begin{alltt}9 11
11111111111
10011011001
11001010011
11101010111
10100100101
11101010111
11001010011
10011011001
11111111111\end{alltt}\end{footnotesize}\end{minipage}}\fbox{\begin{minipage}{4.25em}\begin{footnotesize}\renewcommand{\baselinestretch}{0.875}\begin{alltt}9 11
11111111111
10011011001
11000010011
11101010111
10100100101
11101010111
11001010011
10011011001
11111111111\end{alltt}\end{footnotesize}\end{minipage}}}

Отже --- \emph{акуратно} реалізувати для кожної не~зовнішньої <<1>> перегляд \emph{усіх} сусідів-кімнат, додаючи площі \emph{усіх різних}.

Складність цього алгоритму теж $\Theta(NM)$. Але отой константний множник, яким нехтують у асимптотичних позначеннях, значно більший.