\Tutorial	% \paragraph{Як досить легко набрати частину балів}
Для самої лише підзадачі~D1 і часткового випадку <<всі кімнати мають прямокутну форму>> можна написати програму \verb"ideone.com/HHr9a3"\hspace{0.5em plus 1em}
Вона спирається на те, що у випадку прямокутності кімнат кожна кімната однозначно задається лівим верхнім кутом, а~перевіряти, чи~справді клітинка є таким кутом, можна умовою \texttt{\mbox{(data[i][j]='0')} \mbox{and} \mbox{(data[i-1][j]='1')} \mbox{and} \mbox{(data[i][j-1]='1')}}, тобто сама клітинка вільна, а ліворуч і згори стіни.

Очевидно (в~т.~ч. з\nolinebreak[3] \mbox{2-го}\nolinebreak[3] тесту з\nolinebreak[3] умови), що для ``закручених'' кімнат це може й не\nolinebreak[3] бути правдою. Але\nolinebreak[2] в\nolinebreak[3] умові обіцяно значну частину тестів з кімнатами прямокутної форми, тож при відсутності кращих ідей можна написати хоча~б такий розв’язок. Він набирає 26~балів (з~50 за усю~D1, зі~100 за усю~D).



\MyParagraph{Повний розв'язок підзадачі D1}
Для відстеження (як завгодно ``закручених'') кімнат можна реалізувати будь-який з алгоритмів:

\begin{enumerate}

\item	
пошук ушир (він же пошук у~ширину); рос. поиск в ширину, англ. breadth first search (BFS);

\item
пошук углиб (він же пошук у~глибину); рос. поиск в глубину, англ. depth first search (DFS);

\item
різноманітні алгоритми графічної ``заливки'' (укр., рос.\nolinebreak[3] --- заливка, англ.\nolinebreak[3] --- flood fill).

\end{enumerate}

Ці алгоритми неважко знайти в Інтернеті або в літературі самостійно, тож не~будемо наводити їх тут.

\myhrulefill

Часто вважають, що в такій ситуації найпростішою є рекурсивна реалізація пошуку вглиб. Частково це правда, але рекурсивний пошук углиб має потенційний недолік: пам'яті, потрібної для зберігання рекурсії у програмному стекові, може бути набагато менше, ніж пам'яті взагалі. Як~наслідок, рекурсивна реалізація DFS може завершуватися аварійно по причині \mbox{нестачі} пам'яті --- навіть при фактичних витратах пам'яті, менших, ніж у пошуку вшир або заливці. Стекова пам'ять може бути значно <<дефіцитнішою>>, й коли \emph{вона} закінчилася, наявність іншої пам'яті рекурсії не~допомагає.

С\'аме \emph{може} бути. А~може бути й інакше. І~залежить це від налаштувань компілятора (керування якими доступне програмісту під час <<нормальної>> роботи, але як~правило не~доступне учаснику олімпіади). Конкретно на цій обласній олімпіаді було забезпечено досить великий розмір програмного стеку, тому можна було писати рекурсивний DFS і не~мати проблем; але біда в тому, що при інших налаштуваннях компілятора проблеми цілком можливі.







\MyParagraph{Підзадача D2}
Певну частину балів (орієнтовно до~20 з~50) можна отримати, розв’язуючи підзадачу~D1 багатократно (для абсолютно кожної <<1>> у внутрішній стіні, замінимо її на <<0>> і заново розв’яжемо~D1; серед усіх таких розв’язків виберемо максимальний). Але це ніяк\nolinebreak[2] не\nolinebreak[3] може бути повноцінним ефективним розв’язком для розмірів порядка $1000\*1000$.

Перепишемо підзадачу~D1 так, щоб при підрахунку кількостей та розмірів кімнати не~просто виділялися, а \emph{різні кімнати} виділялися \emph{різними значеннями} (а~клітинки однієї кімнати\nolinebreak[3] --- однаковими). Наприклад, якщо це робити прямо у\nolinebreak[3] масиві з позначками <<0\nolinebreak[3] --- прохід, 1\nolinebreak[3] --- стіна>>, може вийти так:

\noindent\begin{minipage}{\textwidth}
\begin{exampleSimpleThreeWithSpecNameColTwo}{6em}{12em}{13em}{Виділені кімнати}{Масив з розмірами кімнат}%
\exmp{9 12
111111111111
101001000001
111001011111
100101000001
100011111101
100001000101
111111010101
100000010001
111111111111}{~
1 1 1 1 1 1 1 1 1 1 1 1
1 2 1 3 3 1 4 4 4 4 4 1
1 1 1 3 3 1 4 1 1 1 1 1
1 5 5 1 3 1 4 4 4 4 4 1
1 5 5 5 1 1 1 1 1 1 4 1
1 5 5 5 5 1 4 4 4 1 4 1
1 1 1 1 1 1 4 1 4 1 4 1
1 4 4 4 4 4 4 1 4 4 4 1
1 1 1 1 1 1 1 1 1 1 1 1}{\raisebox{-12pt}{\begin{rmfamily}\begin{tabular}{@{}r|ccccc}індекс & \dots &2&3&4&5\\\hline{}значення & \dots&1&5&28&9\end{tabular}\end{rmfamily}}}%
\end{exampleSimpleThreeWithSpecNameColTwo}
\end{minipage}

Якщо при цьому ще й зберігати розміри кімнат у масиві (так, щоб індексами масиву були ті самі ч\'исла, якими позначено кімнати), то для визначення, яка вийде площа кімнати після руйнування деякої стіни, можна просто додати до одинички (площі самої зруйнованої стіни) площі кімнат-сусідів. Так що перебір усіх можливих <<1>> (у не-зовнішніх стінах) можна залишити, бо тепер для кожної такої <<1>> треба робити значно менше дій.

Здається <<логічним>> (і~приклади з умови це <<підтверджують>>), ніби максимальна кімната буде утворена за рахунок об’єднання двох кімнат. Але насправді % подібним <<висновкам>> місце на~смітнику, бо 
це лише поширений випадок, а\nolinebreak[3] не\nolinebreak[3] обов’язкова властивість: замість \mbox{2-х} може бути будь-яке число від~1 до~4 (див.\nolinebreak[2] приклади). Тому  краще, не~роблячи необґрунтованих припущень, акуратно реалізувати для кожної не~зовнішньої\nolinebreak[3] <<1>> перегляд усіх сусідів-кімнат, додаючи площі усіх різних.

\vspace{0.375\baselineskip}

\mytextandpicture{Тест №9. Більшість внутрішніх стін <<товсті>>, тож вилучення \emph{однієї} <<1>> зазвичай не\nolinebreak[3] призводить до з'єднання кімнат. А\nolinebreak[3] в\nolinebreak[3] тому єдиному місці, де призводить (\mbox{2-й}\nolinebreak[3] знизу рядок)\nolinebreak[3] --- утворюється кімната площею $2\dib{{+}}1\dib{{+}}1\dib{{=}}4$.
Набагато більшу площу $44\dib{{+}}1\dib{{=}}45$ можна отримати, зруйнувавши будь-яку (не~зовнішню) стіну кімнати площі~44, утворивши <<нішу>> замість <<проходу>>.}{\begin{minipage}{9.5em}\begin{footnotesize}\renewcommand{\baselinestretch}{0.875}\begin{alltt}13 25
1111111111111111111111111
1000000110000110000110001
1000000110000110000110001
1000000110000110000110001
1000000110000110000110001
1000000110000111111110001
1000000110000111111110001
1111111110000110000110001
1111111110000110000110001
1000000110000111111110001
1000000110000111111110001
1000000110000110010110001
1111111111111111111111111\end{alltt}\end{footnotesize}\end{minipage}}

\vspace{0.375\baselineskip}

\mytextandpicture{Тест №16 (лівіший з двох прикладів). Руйнування однієї <<1>> по центру призводить до з’єднання \emph{відразу чотирьох} кімнат. Переконавшись у можливості такої ситуації, легко уявити і вхідні дані правішого з двох прикладів, де різні сусіди центральної одинички до того ж ще й з'єднані в одну кімнату, але десь далеко.}{\fbox{\begin{minipage}{4.25em}\begin{footnotesize}\renewcommand{\baselinestretch}{0.875}\begin{alltt}9 11
11111111111
10011011001
11001010011
11101010111
10100100101
11101010111
11001010011
10011011001
11111111111\end{alltt}\end{footnotesize}\end{minipage}}\fbox{\begin{minipage}{4.25em}\begin{footnotesize}\renewcommand{\baselinestretch}{0.875}\begin{alltt}9 11
11111111111
10011011001
11000010011
11101010111
10100100101
11101010111
11001010011
10011011001
11111111111\end{alltt}\end{footnotesize}\end{minipage}}}

Отже --- \emph{акуратно} реалізувати для кожної не~зовнішньої <<1>> перегляд \emph{усіх} сусідів-кімнат, додаючи площі \emph{усіх різних}.