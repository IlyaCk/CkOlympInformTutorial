\Tutorial	Розглянуті правила не~мають нічого спільного з реальними засобами генерації паролів, тобто легенда (``казочка'') даної задачі сильно відірвана від життя. Тим\nolinebreak[2] не\nolinebreak[3] менш, будемо користуватися термінами <<пароль>> і <<номер паролю>>, раз уже вони введені в умові задачі.

\MyParagraph{Позбудемось окремих статусів літер і цифр та перейдемо до єдиного алфавіту}
В умові досить багато і трохи заплутано розказано про порядок літер між собою, цифр між собою, літер та букв у рамках одного паролю. Взагалі-то всі ті правила можна істотно спростити до таких:
\begin{enumerate}
\item
будемо вважати алфавітом \texttt{A},~\texttt{B}, \texttt{C}, \texttt{D}, \texttt{E}, \texttt{F}, \texttt{G}, \texttt{H}, \texttt{I}, \texttt{J}, \texttt{K}, \texttt{L}, \texttt{M}, \texttt{N}, \texttt{O}, \texttt{P}, \texttt{Q}, \texttt{R}, \texttt{S}, \texttt{T}, \texttt{U}, \texttt{V}, \texttt{W}, \texttt{X}, \texttt{Y}, \texttt{Z}, \texttt{0}, \texttt{1}, \texttt{2}, \texttt{3}, \texttt{4}, \texttt{5}, \texttt{6}, \texttt{7},~\texttt{8},~\texttt{9} (с\'аме в такому порядку);
\item
всер\'едині кожного пароля (крім 1-символьних), кожен наступний символ мусить бути строго більшим за попередній (згідно алфавіту п.~1).
\end{enumerate}
Переформульовувати правила порівняння різних паролів нема потреби.

\MyParagraph{Частковий розв’язок на 76 балів (зі~100)}
Оскільки в умові сказано, що досить багато балів припадає на не дуже великі значення~$n$, можна писати перебір, тобто дійсно генерувати послідовно \mbox{1-й}, \mbox{2-й},\nolinebreak[3] \dots{} паролі аж до $n$-го. Виявляється, при цьому не\nolinebreak[3] дуже важко добитися, щоб генерувалися відразу лише допустимі (згідно з умовою задачі) паролі.

Розглянемо простіший випадок. Нехай потрібно вивести послідовно пари (1,2), (1,3), (1,4), (1,5), (2,3), (2,4), (2,5), (3,4), (3,5), (4,5), тобто пари з чисел від 1 до~5, щоб \mbox{2-й} елемент пари завжди був строго більшим за\nolinebreak[2] \mbox{1-й}. Це\nolinebreak[3] можна зробити за допомогою циклів
\begin{verbatim}for i:=1 to 5 do
  for j:=1 to 5 do
    if i < j then
      writeln(i, ', ', j);\end{verbatim}
А можна зробити інакше:
\begin{verbatim}for i:=1 to 4 do
  for j:=i+1 to 5 do
    writeln(i, ', ', j);\end{verbatim}
тобто замінити \emph{перевірку} ${i{<}j}$ на \emph{задання лише потрібного} діапазону. % \texttt{for \mbox{j:=i+1} to~\dots}
І~якщо для \mbox{2-х} вкладених циклів це дрібна оптимізація, то для, наприклад, \mbox{5-ти} вкладених циклів пришвидшення істотне ($\approx$~сотні разів).

Приклад такого розв’язку --- \verb"ideone.com/Xg6sKT"\hspace{1em plus 1em}%
Зовсім\nolinebreak[2] не\nolinebreak[3] взірець красоти й лаконічності. У~ньому легко допустити і важко шукати технічні помилки. Але він все ж набирає чимало балів.

\MyParagraph{Повний (100\%) розв’язок}
Перш за все, загальна кількість $k$-сим\-воль\-них паролів рівна $C(36, k)$, де $C(n,k)$, воно~ж $C_n^k$ --- кількість сполучень (рос. сочетания, англ. combinations) з~$n$ по~$k$. Це~так, бо з~36\nolinebreak[3] символів вибираються $k$ різних, і одні й ті самі вибрані символи не~можна переставляти місцями, бо дозволений лише порядок за зростанням (у~алфавіті \texttt{A},~\texttt{B},~\dots,~\texttt{Z}, \texttt{0},~\texttt{1},~\dots,~\texttt{9}).

Так що почнемо розв’язок з того, що взнаємо довжину (кількість символів) шуканого пароля і його номер \emph{серед паролів цієї довжини}.

\begin{small}
\begin{itemize}
\item[] Наприклад, прочитали у вхідних даних 2015.

\item Кіль-ть 1-символьних паролів ${C_{36}^1{=}36}$,\hspace{0.5em plus 1em} ${36{<}2015}$\nolinebreak[3] --- отже, у паролі більше одного символу, й номер серед (більш-ніж-1)-символьних ${2015-36=1979}$.

\item Кіль-ть 2-символьних паролів ${C_{36}^2{=}630}$,\hspace{0.5em plus 1em} ${630{<}1979}$\nolinebreak[3] --- отже, у паролі більше двох символів, і номер серед (більш-ніж-2)-символьних ${1979-630=1349}$.

\item Кіль-ть 3-символьних паролів ${C_{36}^3{=}7140}$,\hspace{0.5em plus 1em} ${7140{\>}1349}$\nolinebreak[3] --- отже, пароль 3-символьний, і\nolinebreak[3] його номер серед 3-символьних рівний~1349.

\end{itemize}
\end{small}

Узнавши довжину пароля та його номер серед паролів 
відповідної довжини, починаємо взнавати цей пароль символ за символом, зліва направо --- на тій підставі, що для кожного можливого початку можна взнавати (засобами комбінаторики) 
% (комбінаторно)
кількість паролів з таким початком і знову приймати рішення, чи\nolinebreak[3] цей початок треба пропустити (всі паролі з таким початком мають менші номери), чи\nolinebreak[3] використати (потрібний номер якраз потрапляє у діапазон).

\begin{small}
\begin{itemize}
\item[] Продовжимо аналіз того самого прикладу (вхідний номер 2015, раніше з’ясовано, що його номер серед 3-символьних рівний 1349).

\item Кіль-ть 3-символьних паролів, що починаються з~\texttt{A}, рівна ${C_{35}^2 = 595}$, бо продовження % паролю 
2-символьне з 35 символів (від~\texttt{B} до~\texttt{9}). ${1349>595}$\nolinebreak[3] --- отже, початок паролю не~\texttt{A}, а якийсь подальший символ, і номер % паролю 
серед тих подальших ${1349-595=754}$.

\item Кіль-ть 3-символьних паролів, що починаються з~\texttt{B}, рівна ${C_{34}^2 = 561}$, бо продовження % паролю 
2-символьне з 34 символів (від~\texttt{C} до~\texttt{9}). ${754>561}$\nolinebreak[3] --- отже, початок паролю не~\texttt{B}, а якийсь подальший символ, і номер % паролю 
серед тих подальших ${754-561=193}$.

\item Кіль-ть 3-символьних паролів, що починаються з~\texttt{C}, рівна ${C_{33}^2 = 528}$, бо продовження % паролю 
2-символьне з 33 символів (від~\texttt{D} до~\texttt{9}). ${193\<528}$\nolinebreak[3] --- отже, початок паролю якраз-таки~\texttt{C}, і його номер серед 3-символьних, що\nolinebreak[3] починаються з~\texttt{C} --- теж~193.

\begin{itemize}
\item[] Далі відбувається аналогічний підбір наступного символу:

\item[\textopenbullet] Кіль-ть 3-символьних паролів, що починаються з~``\texttt{CD}'', рівна ${C_{32}^1=32}$, бо лишається дописати один символ, від~\texttt{E} до~\texttt{9}. ${193>32}$\nolinebreak[3] --- отже, 2-га літера не~\texttt{D}, а\nolinebreak[3] якийсь подальший символ, і номер % паролю 
серед тих подальших ${193-32=161}$.

\item[$\isdiv$] І так далі.

\item[\textopenbullet] Продовживши аналогічні міркування, отримаємо, що шуканий пароль 16-й серед тих, що починаються з~``\texttt{CJ}'', а оскільки після~\texttt{J} можуть іти лише символи, починаючи з~\texttt{K}, то цим 16-м буде~\texttt{Z}.
\end{itemize}

\item[!] Остат\'очно, 2015-й пароль має вигляд ``\texttt{CJZ}''.
\end{itemize}
\end{small}

Дані пояснення займають багато місця, але виключно тому, що наведено приклад (а\nolinebreak[3] у\nolinebreak[3] першому алгоритмі ніякий приклад не\nolinebreak[3] наводився). Правильна реалізація даного комбінаторного алгоритму працює дуже швидко, вкладаючись у секунду з величезним запасом (у~тисячі разів). Адже всього-то треба:

\begin{enumerate}

\item
Познаходити $C(n,k)$, наприклад, усі зразу із проміжку $0\dib{{\<}}k\dib{{\<}}n\dib{{\<}}36$ за допомогою трикутника Паскаля.

\item
Знайти кількість символів у паролі --- віднімати циклом $C_{36}^1$, $C_{36}^2$,~\dots; якби дійшли до $C_{36}^{36})$, а\nolinebreak[3] номер після усіх віднімань все ще лишався надто великим --- це означало~б, що пароля вказаних вигляду і номера взагалі\nolinebreak[2] не~існує. Але такого не~буде, бо паролів ($2^{36}-1$) все-таки більше, чим $n{\<}10^{10}$. Значить --- тут % взагалі 
не~більш як 36 порівнянь та віднімань.

\item
Для кожної позиції (1-й\nolinebreak[3] символ, 2-й,~\dots) запустити цикл, щоб знайти конкретне значення відповідного символу\nolinebreak[3] --- теж\nolinebreak[3] не~багато, бо і\nolinebreak[3] позицій, і\nolinebreak[3] значень символів не~більше~36.

\end{enumerate}


\emph{Якби} розмір алфавіту був змінним (і при цьому не~з'являлася <<довга>> арифметика), можна було~б говорити про час роботи $O(A^2)$, де\nolinebreak[3] $A$\nolinebreak[3] --- розмір алфавіту. При $A{=}36$, це \emph{дуже} швидко\dots