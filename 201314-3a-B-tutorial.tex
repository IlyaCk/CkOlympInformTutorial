\Tutorial	Ніби нескладна задача\nolinebreak[3] --- перебрати, перевіряючи виконання двох умов\dots{} 
Але \verb"ideone.com/gLqsYd" набирає лише 50~балів зі~100.

Проблема у тому, що перевіряти аж два мільярди чисел\nolinebreak[3] --- все~ж забагато. Навіть якщо (абсолютно слушно) рахувати суму цифр лише для тих із них, які пройшли перевірку \verb"frac(sqrt(n))=0". (До\nolinebreak[3] речі, взагалі-то надійніше перевіряти <<чи~є точним квадратом>> як \verb"sqr(round(sqrt(n)))=n", адже функція \verb"sqrt" в\nolinebreak[3] принципі може повернути неточне значення, як-то \verb"4.999999999999" замість~\verb"5", а\nolinebreak[3] тоді й \verb"frac" поверне зовсім\nolinebreak[3] не~0. Спосіб \verb"sqr(round(sqrt(n)))=n" не~має такого  недоліку. Насправді у даній задачі й на даному сервері правильно працює і перший спосіб, але в\nolinebreak[3] принципі тут можлива проблема.)

Тобто, головна проблема\nolinebreak[3] --- як\nolinebreak[3] пришвидшити наведений розв'язок. Досить просто: можна \emph{генерувати} відразу \emph{лише} точні квадрати, а~не~перебирати геть усі ч\'{и}сла проміжку й <<у~кожного питати>>. Достатньо запускати не~цикл від~$a$ до~$b$, а від~${\approx}\sqrt{a}$ до~${\approx}\sqrt{b}$ й працювати з $i^2$. Правда, тут можна заплутатися з~тим, як~с\'{а}ме перетворити <<${\approx}\sqrt{a}$>> та <<${\approx}\sqrt{b}$>> у~точні цілі значення. Не~дуже красивий, зате безсумнівно правильний спосіб\nolinebreak[3] --- узяти м\'{е}жі з невеличким <<запасом>>, а~потім отримане~$i^2$ все-таки перевірити на належність проміжку~\mbox{$[a; b]$}. Такий розв'язок, навіть із цією зайвою перевіркою, безсумнівно вкладатиметься у 1~сек з великим запасом, бо тепер кількість ітерацій${}\<\sqrt{2{\cdot}10^9}\approx{45\textnormal{~тис}}$.
Див.\nolinebreak[2] \verb"ideone.com/EplT1L"

