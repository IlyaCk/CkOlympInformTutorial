\Tutorial	У цій задачі треба акуратно писати відносно велику, як для II етапу, програму, поєднуючи застосування різних стандартних алгоритмів. Але, не~зважаючи на страшну назву <<ко-ана\-гра\-мічно>> та інші громіздкості, тут\nolinebreak[2] не\nolinebreak[3] дуже-то й треба самому придумувати щось математичне. Якщо, звісно:

\begin{itemize} 

\item
знати стандартний алгоритм перевірки простоти числ\'а;

\item
вміти \emph{або перевіряти, чи}\nolinebreak[2] ч\'исла складаються з одних і тих с\'амих цифр, \emph{або генерувати перестановки} послідовності\nolinebreak[3] цифр.

\end{itemize}

Cтандартний алгоритм перевірки простоти числ\'а~$n$ (при\nolinebreak[2] $n\>2$)\nolinebreak[3] --- пробувати ділити його на\nolinebreak[3] 2,\nolinebreak[2] 3,\nolinebreak[3] \dots, \verb"round"$(\sqrt{n})$, і\nolinebreak[3] якщо хоча~б раз поділилося без остачі\nolinebreak[3] --- число скл\'адене (не~просте), якщо не\nolinebreak[3] поділилося ні~разу\nolinebreak[3] --- просте. Важливо перевіряти до\nolinebreak[2] кореня (а\nolinebreak[3] не\nolinebreak[2] до\nolinebreak[3] $n$ чи\nolinebreak[2] $n/2$), бо це набагато менше (отже, швидше). Перевіряти далі кореня нема потреби, бо якщо $n$ кратне деякому~$a$, то кратне також і\nolinebreak[2] $n/a$,\linebreak[1] а~серед чисел $a$ та $n/a$ хоча~б одне${}\<\sqrt{n}$. 

Перевіряти, чи ч\'исла складаються з одних і тих самих цифр у різному порядку, можна по-різному. Один з простих і зручних підходів\nolinebreak[3] --- відсортувати (наприклад, за\nolinebreak[3] неспаданням) цифри окремо одного з~них, окремо іншого, й порівняти отримані відсортовані послідовності (вони рівні тоді й тільки тоді, коли ч\'исла складаються з одних і тих самих цифр). Оскільки кількість цифр дуже маленька, нема смислу використовувати quickSort чи подібні ефективні сортування, доречніші вставки або навіть звичайнісінька бульбашка.

Таким чином, алгоритм може бути приблизно таким. 
Функція (підпрограма) <<перевірити, чи~є число ко-анаграмічно-простим>> має вигляд:

\begin{enumerate}
\item
створимо копію цього числа у рядковому (\texttt{string}-овому) вигляді;
\item
відсортуємо цифри (символи рядка) за неспаданням;
\item
переберемо усі числа з відповідною кількістю цифр, від 0\dots01 до 9\dots99, і для кожного з них:
\begin{enumerate}
\item
перетворимо у рядок (знову як копію, щоб не псувати оригінал);
\item
теж відсортуємо цифри числ\'а за неспаданням;
\item \label{item:201415-2-d-both-tests}
якщо відсортовані послідовності виявилися різними --- значить, поточне число не є перестановкою цифр досліджуваного і його слід пропустити, а якщо виявилися однаковими --- запустити перевірку поточного числа на простоту.
\end{enumerate}
Якщо перевірка у п.~\ref{item:201415-2-d-both-tests} хоча~б один раз виявила, що число просте\nolinebreak[3] --- функція в цілому має повернути результат <<число є ко-ана\-гра\-мічно-простим>>. Якщо жодного разу не~виявила\nolinebreak[3] --- результат <<не~є>>.
\end{enumerate}

Тепер у основній програмі лишається тільки перевіряти, чи\nolinebreak[3] є ко-ана\-гра\-мічно-простим сам\'е введене число~$n$, потім $n{+}1$, $n{+}2$,~\dots{} Приклад такої реалізації\nolinebreak[3] --- \verb"ideone.com/mGI9hm"

Програма може працювати помітно швидше, якщо замість перевірки усіх чисел з відповідною кількістю цифр (від 0\dots01 до 9\dots99) і перевірки кожного з них, чи~складається воно з тих самих цифр, відразу генерувати лише потрібні ч\'исла (що\nolinebreak[3] складаються з тих самих цифр) і перевіряти на простоту лише\nolinebreak[3] їх. При обмеженні $n\<9999$ це насправді неважливо, тож утримаємося від детального опису, як робити це вручну (бажаючі можуть пошукати за ключовими словами <<генерація перестановок>>, <<generate permutations>>). При використанні мови\nolinebreak[2] C++, можна скористатися готовою бібліотечною функцією перебору перестановок (функція \verb"next_permutation" з бібліотеки \verb"algorithm"); деталі щодо її використання знов-таки пропонується знайти самостійно.