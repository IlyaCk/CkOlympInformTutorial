\Tutorial	
Головне при розв'язуванні цієї задачі\nolinebreak[3] --- не\nolinebreak[3] перестаратися й не\nolinebreak[3] почати писати <<чесні>> перевірки перетинів. Такі перевірки могли\nolinebreak[3] б бути доречними при більших розмірах сітки та меншій кількості відрізків ламаної. А\nolinebreak[3] при заданій кількості, відомі автору даного розбору оптимізації перебору всіх можливих перетинів не\nolinebreak[3] вкладаються у\nolinebreak[3] обмеження\nolinebreak[2] часу.

У даній конкретній задачі краще помітити такі факти: 

\begin{enumerate}
\item
$5000{\*}5000\dib{{=}}25\textnormal{~млн}$\nolinebreak[3] --- дуже багато для людини, але для комп'ютера\nolinebreak[3] --- не\nolinebreak[3] так і багато. Не\nolinebreak[3] лише у\nolinebreak[3] розрізі <<виконати 25~млн\nolinebreak[2] дій>>, а\nolinebreak[3] також і у\nolinebreak[3] розрізі <<тримати в\nolinebreak[3] пам'яті 25~млн\nolinebreak[2] елементів>>.
\item
Хоча один окремо взятий відрізок (ланка ламаної) може мати довжину аж~5000, а\nolinebreak[3] кількість відрізків може сягати мільйона, сумарна довжина відрізків насправді обмежується не\nolinebreak[2] $5000\dib{{\*}}10^6\dib{{=}}{5{\cdot}10^9}$, а\nolinebreak[3] тим, що раз відрізки лише горизонтальні й вертикальні, а\nolinebreak[3] накладання заборонені, то кожна з $5000{\*}5000$ вершин сітки може бути задіяна щонайбільше двічі, тобто сума довжин усіх відрізків не\nolinebreak[3] перевищує\nolinebreak[3] 50~млн. 
\end{enumerate}

\label{text:drawing-by-coords-in-graphics-password-problem}
Завдяки цьому, виявляється допустимим такий простий підхід, як \textsl{<<завести масив $5000{\*}5000$, ініціалізувавши всі елементи нулями; ходити уздовж ліній, збільшуючи на~1 значення у комірках, відповідних пройденим вершинам сітки; відповіддю буде кількість комірок зі значенням~2>>}. Великий time\nolinebreak[2] limit 4~сек потрібен не\nolinebreak[3] для роб\'{о}ти алгоритму, а\nolinebreak[3] для читання величезних вхідних даних. Приклад реалізації такого алгоритма\nolinebreak[3] --- \verb"ideone.com/SlR8oV"


