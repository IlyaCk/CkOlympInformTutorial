\Tutorial	
Головне при розв'язуванні цієї задачі\nolinebreak[3] --- не\nolinebreak[3] перестаратися й не\nolinebreak[3] почати писати справжні <<чесні>> перевірки перетинів. Такі перевірки могли\nolinebreak[3] б бути доречними при більших розмірах сітки та меншій кількості відрізків ламаної. А\nolinebreak[3] при заданій кількості, відомі автору даного розбору оптимізації перебору всіх можливих перетинів не\nolinebreak[3] вкладаються у\nolinebreak[3] обмеження\nolinebreak[2] часу.

У даній конкретній задачі краще помітити такі факти: 

\begin{enumerate}
\item
$5000{\*}5000\dib{{=}}25\textnormal{~млн}$\nolinebreak[3] --- багато для людини, але для комп'ютера\nolinebreak[3] --- не\nolinebreak[3] так і багато. Не\nolinebreak[3] лише у\nolinebreak[3] розрізі <<виконати 25~млн\nolinebreak[2] дій>>, а\nolinebreak[3] також і у\nolinebreak[3] розрізі <<тримати в\nolinebreak[3] пам'яті 25~млн\nolinebreak[2] елементів>>.
\item
Хоча один окремо взятий відрізок (ланка ламаної) може мати довжину аж~5000, а\nolinebreak[3] кількість відрізків може сягати мільйона, сумарна довжина відрізків насправді обмежується не\nolinebreak[2] $5000\dib{{\*}}10^6\dib{{=}}{5{\cdot}10^9}$, а\nolinebreak[3] тим, що раз відрізки лише горизонтальні й вертикальні, а\nolinebreak[3] накладання заборонені, то кожна з $5000{\*}5000$ вершин сітки може бути задіяна щонайбільше двічі, тобто сума довжин усіх відрізків не\nolinebreak[3] перевищує\nolinebreak[3] 50~млн. 
\end{enumerate}

Завдяки всьому цьому, виявляється цілком допустимим такий простий підхід, як \textsl{<<завести масив $5000{\*}5000$, ініціалізувавши всі елементи нулями; ходити уздовж ліній, збільшуючи значення у комірках, відповідних пройденим вершинам сітки; щоразу, коли збільшується комірка, яка вже не~0, додавати~1 до лічильника-відповіді>>}. Величезний time\nolinebreak[2] limit 4~сек насправді потрібен не\nolinebreak[3] для роб\'оти алгоритму, а\nolinebreak[3] для читання величезних вхідних даних. Приклад реалізації наведеного алгоритма\nolinebreak[3] --- \verb"ideone.com/SlR8oV"


